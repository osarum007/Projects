#@ # 
#@ # Running fm_shell Version U-2022.12 for linux64 -- Nov 22, 2022
#@ # Date:   Thu Aug  1 12:24:12 2024
#@ # Run by: aigbe@rs12
#@ 

source /shared/hwmisc/apps/synopsys/fm/2022.12/admin/setup/.synopsys_fm.setup
#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/admin/setup/.synopsys_fm.setup

#@ #
#@ # .synopsys_fm.setup: Initialization File for Formality
#@ #
#@ 
#@ 
#@ #
#@ # Enable stack trace output on fatal.  Not available for all architectures.
#@ #
#@ if { $sh_arch == "sparc" || $sh_arch == "sparcOS5" || \
#@      $sh_arch == "hp700" || $sh_arch == "hpux10" } {
#@   set_unix_variable SYNOPSYS_TRACE ""
#@ }
#@ 
#@ #
#@ # Variable settings
#@ #
#@ set sh_new_variable_message true
#@ 
#@ #
#@ # Synopsys strongly recommends that you uncomment the following command
#@ # in order to set sh_command_abbrev_mode to the value "Command-Line-Only".
#@ # Command abbreviation is intended as an interactive convenience.  Using
#@ # abbreviations in scripts can cause commands to fail in subsequent releases.
#@ # 
#@ #set sh_command_abbrev_mode "Command-Line-Only"
#@ 
#@ #
#@ # Some useful aliases
#@ #
#@ alias list_commands		help
#@ 
#@ #
#@ # The alias of q to quit is commented out.  Remove the comment 
#@ # character if you want this alias.  Some users find that having 
#@ # this particular alias causes problems when mixed with page-mode
#@ # for reports - an accidental repeated 'q' not only cancels the
#@ # output but exits the tool.
#@ #
#@ #alias q quit
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/admin/setup/.synopsys_fm.setup

source -echo -verbose ../common/fms.tcl
#@ # -- Starting source ../common/fms.tcl

#@ #!fm_shell
#@ 
#@ suppress_message CMD-041
#@ 
#@ set script_name fms
#@ 
#@ source ../scripts/project.tcl
#@ # -- Starting source ../scripts/project.tcl

#@ if { ! [info exists synopsys_program_name] } {
#@ 
#@     proc suppress_message args {}
#@     proc unsuppress_message args {}
#@     proc echo args { puts $args }
#@     proc alias args {}
#@     proc define_proc_attributes args {}
#@     proc set_message_info       args {}
#@ 
#@     proc source2 script {
#@         upvar search_path search_path
#@         if { [file exists $script] } {
#@             uplevel "source $script "
#@         } elseif { ! [string match $script "/*"] } {
#@             foreach p $search_path {
#@                 if { [file exists "$p/$script"] } {
#@                     uplevel "source $p/$script"
#@                 }
#@             }
#@         }
#@     }
#@     
#@     proc getenv name {
#@         upvar env env
#@         set env($name)
#@     }
#@ 
#@ } else {
#@     proc source2 script {
#@         uplevel "source $script"
#@     }
#@ }
#@ 
#@ # These seem to help the primetime crashing problem. (Thank you, MC)
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == {pt_shell}} {
#@     set disable_multicore_resource_checks true
#@     set multi_core_allow_overthreading false
#@     set_host_options -max_cores 8
#@ }
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == {fm_shell}} {
#@     set_host_options -max_cores 4
#@     report_host_options
#@ }
#@ 
#@ # I.........n: Defining new variable '%s' (CMD-041)
#@ suppress_message CMD-041
#@ 
#@ # W.....g: Design ... contains . high-fanout nets. A fanout number of 1000 will be used ... (TIM-134)
#@ suppress_message TIM-134
#@ 
#@ # I.........n: Linking logical library CK3G3I10V10G8T10F with physical library asaprfsd2p_512x9cm4sw0_plib. (PSYN-036)
#@ suppress_message PSYN-036
#@ 
#@ # W.....g: Creating virtual clock named 'vrt_core_clock' with no sources. (UID-348)
#@ suppress_message UID-348
#@ 
#@ # W.....g: It is dangerous to create a clock source on inout port '...'. (UID-376)
#@ suppress_message UID-376
#@ 
#@ # W.....g: The clock source 'TC/SRAMDIV/CML2C/U/o_clkout' has ideal timing specified,
#@ #        but the clock was just created as an ideal clock.
#@ #        Ignoring previously-specified ideal timing for this clock source. (UID-427)
#@ suppress_message UID-427
#@ 
#@ # W.....g: Creating virtual clock named '...' with no sources. (UITE-121)
#@ suppress_message UITE-121
#@ 
#@ # W.....g: Creating a clock source on inout port '...'. (UITE-123)
#@ suppress_message UITE-123
#@ 
#@ # W.....g: Creating a clock on internal pin '...'. (UITE-130)
#@ suppress_message UITE-130
#@ 
#@ # W.....g: Creating a generated clock on hierarchical pin ''. (UITE-136)
#@ suppress_message UITE-136
#@ 
#@ # W.....g: Creating 'clock' constraint on a hierarchical pin '...'. (UITE-137)
#@ suppress_message UITE-137
#@ 
#@ # W.....g: Negative clock latency specified: -0.15 (UITE-150)
#@ suppress_message UITE-150
#@ 
#@ # W.....g: Value for <delay> is negative. (UID-450)
#@ suppress_message UID-450
#@ 
#@ # W.....g: Exhaustive path-based analysis may take a long time ... Try ...
#@ #         - Use the -slack_lesser_than option (UITE-479)
#@ suppress_message UITE-479
#@ 
#@ #W.....g: Some timing arcs have been disabled for breaking timing loops
#@ #   or because of constant propagation. Use the 'report_disable_timing'
#@ #   command to get the list of these disabled timing arcs. (PTE-003)
#@ suppress_message PTE-003
#@ 
#@ #W.....g: No clock-gating check is inferred for clock pds_clock 
#@ #        at pins TC/CORE/EVEN_1/U1_dont_touch/sel and TC/CORE/EVEN_1/U1_dont_touch/i1 of cell TC/CORE/EVEN_1/U1_dont_touch. (PTE-060)
#@ suppress_message PTE-060
#@ 
#@ # W.....g: The 'FILLCAP16G1T10W' cell in the 'TSMC_CLN90G_SC9WT_PHYS' physical library does not
#@ #         have corresponding logical cell description. (PSYN-025)
#@ suppress_message PSYN-025
#@ 
#@ # W.....g: Site IOCELL has different height(width) in the pdbs
#@ #          SRMPBV256M32X8G1T10_plib and TSMC_CLN90G_SC9WT_9_KK_ALL_WCS_PHYS . Site defined in TSMC_CLN90G_SC9WT_9_KK_ALL_W
#@ # CS_PHYS will be used.  (PSYN-370)
#@ suppress_message PSYN-370
#@ 
#@ #W.....g: The BC_WC analysis mode will be phased out in future releases. (PT-009)
#@ # We get this when loading W2004.12 DC/PC netlists into 2005.06 SP1 PT
#@ # Each design loaded has an analysis_type attribute set to bc_wc, (subsequently overwritten by our set_operating_conditions -analysis_type on_chip_variation)
#@ suppress_message PT-009
#@ 
#@ #W.....g: The trip points for the library named midl_bisted_wc differ from those in the library named tsmc40g_sc10t090v_ss090-40. (TIM-164)
#@ # This is due to the mixing up of 40g and lp65 libraries (temporarily)
#@ suppress_message TIM-164
#@ 
#@ #W.....g: Conflicted logic driving pin ..x.., setting resolved logic value ..y.. on pin ..x..
#@ # When case analysis conflicts with the value driven by flops
#@ suppress_message PTE-042
#@ 
#@ #W..g: Net "DMFEH/mask_pll_status" has many driver/load combinations (7041984); expect performance degradation. (PTE-038)
#@ suppress_message PTE-038
#@ 
#@ #W.....g: Site row 'CORE_ROW_1820' exists
#@ suppress_message DCT-052
#@ 
#@ #W.....g: The entity 'resync_simple3_boolean' has multiple architectures defined. The last defined architecture 'avago' will be used to build the design by default. (VHD-6)
#@ suppress_message VHD-6
#@ 
#@ # Some pins are both clock and data start points
#@ # W.....g: Clock port 'fcx_clock_1' is assigned input delay relative to clock 'vrt_ref0_fcx_clock_0'. (TIM-111)
#@ suppress_message TIM-111
#@ 
#@ # W.....g: Reference sd16C_txcpam4_rxcm4_ns_01 contains internal pins with clock attribute. (TIM-103)
#@ suppress_message TIM-103
#@ 
#@ # W.....g:  .../ip16_HBM_ctc_stop_dp_0_behavioral_verilog.v:2293: Intraassignment delays for nonblocking assignments are ignored. (VER-130)
#@ suppress_message VER-130
#@ 
#@ #W.....g: Incorrect setting for bus naming style variables. (OPT-916) (14 off)     
#@ suppress_message OPT-916
#@ 
#@ proc q2_suppress_messages {} {
#@ 
#@     # This set of W.....gs is typically suppressed in compile-type scripts
#@     
#@     # w.....g: The mode selected for resource implementation is use_fastest..... (HDL-401)
#@     suppress_message HDL-401
#@ 
#@     # w.....g: In design ... there is . submodule connected to power or ground. (LINT-30)
#@     # w.....g: In design ... there is . submodule with pins connected to the same net. (LINT-30)
#@     suppress_message LINT-30
#@     # W.....g: Reference ... contains internal pins with clock attribute. (TIM-103)
#@     suppress_message TIM-103
#@ 
#@     # w.....g: Design ... inherited license information from design ... (DDB-74)
#@     suppress_message DDB-74
#@ 
#@     # W.....g: Could not buffer the multiple port net X/TC/MACROTXFIFORST_N_43 because
#@     #         doing so would increase the connection class violation of the design. (OPT-140)
#@     suppress_message OPT-140
#@     # W.....g: Fixing max_transition introduces worse max_capacitance from 0.276783 to 0.276995 (OPT-1026)
#@     suppress_message OPT-1026
#@     # W.....g: Pad '.../.../...' connected to port '....' is dont-touch. No optimization done. (OPT-1006)
#@     suppress_message OPT-1006
#@     # W.....g: design 'resync_simple...' has 24 out of 48 cells marked size-only which may limit optimization. (OPT-301)
#@     suppress_message OPT-301
#@ 
#@     # W.....g - Cell xxx marked dont_touch because of fixed_placement attribute. (PSYN-040)"
#@     suppress_message PSYN-040
#@     # W.....g: design cluster 'METAL8_blockage' is an obstruction without design objects.  (PSYN-544)
#@     suppress_message PSYN-544
#@ 
#@ }
#@ 
#@ if {[info exists synopsys_program_name] && $synopsys_program_name == {pt_shell}} {
#@ 
#@     # We want to see all of these ...
#@     
#@         # W.....g: Unable to resolve reference to 'channels' in 'P6'. (LNK-005)
#@         set_message_info -id LNK-005 -limit 1000000
#@ 
#@     # And fewer than the default (100) of these
#@ 
#@         # W.....g: An extrapolation exceeding 10% of the library characterization range has been detected. The delay calculation accuracy may be affected. for the cell timing arc ...
#@         set_message_info -id  RC-011 -limit 4
#@         # W.....g: Failed to compute C-effective for the timing arc (..) because the library data indicates a non-positive drive resistance....
#@         set_message_info -id  RC-004 -limit 4
#@ 
#@     # SPONG:  And these ... (which we would like to know about, but we are swamped by P_S(XPL|SWF) ones
#@     # SPONG2: By saving these we could potentially parse the results later to get a list of actual problems (save_limit 0 means unlimited)
#@ 
#@         # W.....g: The generated clock 'P_SXPL_...' has not been expanded, please create or activate its master clock. (PTE-023)
#@         set_message_info -id PTE-023 -limit 10
#@         set_message_info -id PTE-023 -save_limit 0
#@         
#@         # W.....g: At pin 'Q_DMBUFB_U_1/to_dmfe_reg_7_DATA_0_DATA_32/phi' clock 'core_clock' does not have the needed rise edge. (PTE-074)
#@         set_message_info -id PTE-074 -limit 10
#@         set_message_info -id PTE-074 -save_limit 0
#@         
#@ }
#@ 
#@ proc chip_name {} { 
#@     return {q6chip}
#@ }
#@ 
#@ proc chip_top_name {} {
#@     return {q6core}
#@ }    
#@ 
#@ set chip_name     [chip_name]
#@ set chip_top_name [chip_top_name]
#@ 
#@ set top_level_block [string toupper $chip_top_name]
#@ 
#@ regsub -all -- {\\} [getenv MY_PROJECT] / project_dir
#@ 
#@ foreach dir_name [list [file dirname [pwd]]/common [file dirname [file dirname [pwd]]]/syn/common [file dirname [file dirname [file dirname [file dirname [pwd]]]]]/syn/common $project_dir/common/syn/common] {
#@     if [file exists $dir_name] {
#@         set common_dir $dir_name
#@         break
#@     }
#@ }
#@ 
#@ if {[array get env SHARED] != {}} {
#@     regsub -all -- {\\} [getenv SHARED] / shared_dir
#@ } else {
#@     set shared_dir /shared/synced/
#@ }
#@ 
#@ # Set 'analysis_type' - used to control:
#@ 
#@ # proc set_q2_clock_latencies - to select bc/wc offset
#@ # proc read_some_sdf and the like
#@ # ocv_derate - on/off
#@ 
#@ # For Q1 it was derived early (by proc setup_analysis). Maybe it will be again.
#@ 
#@ if { [info exists env(SYNOPSYS_MACHINE_LOCATION)] } {
#@     set machine_location $env(SYNOPSYS_MACHINE_LOCATION)
#@ } elseif { [regexp "inet( addr:)? ?172\.22\.(0|1)\." [exec /sbin/ifconfig]] } {
#@     echo "UK Subnet detected. Assuming this is a UK machine"
#@     set machine_location uk
#@ } else {
#@     echo "Assuming this machine is located in MV"
#@     set machine_location mv
#@ }
#@ 
#@ if { [string equal $machine_location "uk"] } {
#@     set brcm_dir    "/shared/$chip_name/elway/incoming/pld"
#@     set to_brcm_dir "/shared/$chip_name/elway/release"
#@ } else {
#@     set brcm_dir    "/shared/$chip_name/elway/incoming/pld"
#@     set to_brcm_dir "/shared/$chip_name/elway/release"
#@   # set to_brcm_dir "/shared/$chip_name/to_brcm/"
#@ }
#@ 
#@ if { ! [info exists analysis_type] } {
#@ 
#@     if { [array get env SYNOPSYS_SCRIPT_TYPE] != {} &&          \
#@          [regexp {bc|wc|nom} $env(SYNOPSYS_SCRIPT_TYPE)] } {
#@         set analysis_type $env(SYNOPSYS_SCRIPT_TYPE)
#@         # note: nom not supported yet ...
#@         puts "Using specific analysis_type '$analysis_type'"
#@     } elseif { $script_name == "compile_topo" } {
#@         set analysis_type ocv_wc
#@         puts "Using script specific default analysis_type '$analysis_type'"
#@     } elseif {[string match *postlayout* [pwd]]} {
#@         set analysis_type ocv_wc
#@         puts "Defaulting analysis_type to '$analysis_type' (postlayout default)"
#@     } else {
#@         set analysis_type ocv_wc_prelayout
#@         puts "Defaulting analysis_type to '$analysis_type' (prelayout default)"
#@     }
#@     
#@ 
#@     
#@     # Now we do use OCV derating during DC (?and PC?) as well as PT
#@     # if { [info exists synopsys_program_name] && ( $synopsys_program_name != {pt_shell}) } {
#@     #     # same as not running primetime, but that only appears after common
#@     #     
#@     #     if { [string match "ocv*" $analysis_type] } {
#@     #         puts "Err\or: OCV modes only supported with PrimeTime - bye bye"
#@     #         exit
#@     #     }
#@     # }
#@ }
#@ 
#@ if       { [regexp "bc_wc"   $analysis_type operating_conditions] } {
#@ } elseif { [regexp "bc_hot"  $analysis_type operating_conditions] } {
#@ } elseif { [regexp "bc_cold" $analysis_type operating_conditions] } {
#@ } elseif { [regexp "bc"      $analysis_type operating_conditions] } {
#@ } elseif { [regexp "wc_cold" $analysis_type operating_conditions] } {
#@ } elseif { [regexp "wc_hot"  $analysis_type operating_conditions] } {
#@ } elseif { [regexp "wc"      $analysis_type operating_conditions] } {
#@ } else {
#@     echo "Err\or: Unrecognised analysis type '$analysis_type'"
#@ }
#@ 
#@ # Path to ram instance from wrapper4 level. In this case B*_S* is the wrapper 3, B*_S*/U is the verilog wrapper and B*_S*/U/U is the actual ram
#@ set BS_SS_U     "B*_S*/U/U"
#@ # Path to ram instance from q4s wrapper level. In B* is the q4s bank/column/inner, B*/U are the wrapper 5s, B*/U/U are the wrapper 4s and then its as above
#@ set Q4S_BS_SS_U "B*/U/U/$BS_SS_U"
#@ 
#@ # SPONG: These need to be characterised from a real aldl_structural release (rising edge delay - mean of max derated and min derated)
#@ # SPONG: Currently these are characterised from the logical netlist (rising edge delay - mean of max derated and min derated)
#@ #        ONLY WC/BC !!! (Others are copied from that)
#@ 
#@ array set aldl_coarse_step_delay_ps { wc_cold   10.648
#@                                       wc_hot    10.648
#@                                       wc        10.648
#@                                       bc_hot     7.219
#@                                       bc_cold    7.219
#@                                       bc         7.219
#@                                     }
#@ 
#@ # SPONG: These need to be characterised from a real aldl_structural release (rising edge delay - mean of max derated and min derated)
#@ # SPONG: CURRENTLY THESE ARE ALL JUST GUESSED !!!
#@ # We just tweak these aldl base delays down a smidge, because the analysis is all done with large ck buffers
#@ # on the intermediate clock outputs. Those buffers add about 4 ps (in wc) to the output delay of the aldl.
#@ # While the fcx3 circuits do have this buffer, the fcx2 ones don't so we need to compromise here.
#@ 
#@ array set aldl_base_delay_ps  [ list  wc_cold   [expr 18 - 1.5]     \
#@                                       wc_hot    [expr 18 - 1.5]     \
#@                                       wc        [expr 18 - 1.5]     \
#@                                       bc_hot    [expr 10 - 1.0]     \
#@                                       bc_cold   [expr 10 - 1.0]     \
#@                                       bc        [expr 10 - 1.0]     \
#@                               ]
#@ 
#@ #array set aldl_min_delay_ps         { wc       156.0
#@ #                                      wc_cold  148.0
#@ #                                      bc        80.0
#@ #                                      bc_hot    91.0 }
#@ 
#@ set only_use_min_library false
#@ set only_use_wcc_library false
#@ set only_use_bch_library false
#@ set dont_use_min_library true
#@ 
#@ switch $operating_conditions {
#@ 
#@     {wc}      {  }
#@     {bc_wc}   { set dont_use_min_library false }
#@     {wc_hot}  { set only_use_wch_library true  }
#@     {wc_cold} { set only_use_wcc_library true  }
#@     {bc_hot}  { set only_use_bch_library true  }
#@     {bc_cold} { set only_use_min_library true  }
#@     {bc}      { # As bc_cold
#@                 set only_use_min_library true  }
#@     {}        { puts "Err\or: Unrecognised analysis type '$analysis_type'" }
#@ }
#@ 
#@ # Use runs directory name to determine target technology
#@ if {! [info exists technology]} {
#@     if {[string match *av16od* [pwd]]} {
#@         set technology AV16OD
#@     } elseif {[string match *av16* [pwd]]} {
#@         set technology AV16
#@     } elseif {[string match *brcm40* [pwd]]} {
#@         set technology TSMC40G
#@         # SPONG # probably redundant but leave here for the moment in case we want to compile with q3 libs for comparison
#@     } elseif {[string match *brcm5* [pwd]]} {
#@         set technology TSMC5FF
#@     } elseif {[string match *brcm7* [pwd]]} {
#@         set technology TSMC7FF
#@     } else {
#@         set technology TSMC3FF
#@         # q6 default is avago 3nm
#@     }
#@ }
#@ 
#@ if {[info exists technology]} {
#@ 
#@     if {[string match none $technology]} {
#@     
#@         puts "Info: No technology library loading"
#@         
#@     } elseif {[string match TSMC7FF* $technology]} {
#@ 
#@         puts "Note: Using Avago Lib - technology = '$technology'"
#@         
#@         set use_scan_flops true
#@         
#@         set rams_src_root n/a
#@         set rams_root .
#@ 
#@         puts "rams_src_root = '$rams_src_root'"
#@         puts "rams_root     = '$rams_root'"
#@ 
#@         set additional_link_libraries [concat [glob -nocomplain $rams_root/*_pssg_s250_v0670_t-40_xrcwccwt.db] ]
#@         # If there are no t-40 ram libs, then perhaps try the t125 ones (even though we may not be doing ocv_wc_hot)
#@         if { $additional_link_libraries == {} } {
#@             set additional_link_libraries [concat [glob -nocomplain $rams_root/*_pssg_s250_v0670_t125_xrcwccwt.db] ]
#@         }
#@ 
#@         set additional_mw_reference_libraries {}
#@         
#@         # Set milkyway pointer to physical libraries
#@             # if {[file exists rams]} {
#@                 lappend additional_mw_reference_libraries log/rams
#@             # }
#@         
#@         # Set milkyway pointer to misc ip libraries
#@             # if {[file exists misc]} {
#@                 lappend additional_mw_reference_libraries log/misc
#@             # }
#@         
#@     } elseif {[string match {TSMC[35]FF*} $technology]} {
#@ 
#@         puts "Note: Using Avago Lib - technology = '$technology'"
#@         
#@         set use_scan_flops true
#@         
#@         set rams_src_root n/a
#@         set rams_root .
#@ 
#@         puts "rams_src_root = '$rams_src_root'"
#@         puts "rams_root     = '$rams_root'"
#@ 
#@         set additional_link_libraries [concat [glob -nocomplain $rams_root/*_pssg_s*_v0670_t-40_xrcwccwt.db] \
#@                                               [glob -nocomplain $rams_root/tim/etm/*_pssg_s*_v0670_t-40_xrcwccwt.db] ]
#@         # If there are no t-40 ram libs, then perhaps try the t125 ones (even though we may not be doing ocv_wc_hot)
#@         if { $additional_link_libraries == {} } {
#@             set additional_link_libraries [concat [glob -nocomplain $rams_root/*_pssg_s*_v0670_t125_xrcwccwt.db] \
#@                                                   [glob -nocomplain $rams_root/tim/etm/*_pssg_s*_v0670_t125_xrcwccwt.db] ]
#@         }
#@ 
#@         # And this one gives errors when reading in, and I'm not going to use a wlm, so ...
#@ 
#@         set link_libraries_not_required {*n3_wlm*}
#@ 
#@         set additional_mw_reference_libraries {}
#@         
#@         # Set milkyway pointer to physical libraries
#@             # if {[file exists rams]} {
#@                 lappend additional_mw_reference_libraries log/rams
#@             # }
#@         
#@         # Set milkyway pointer to misc ip libraries
#@             # if {[file exists misc]} {
#@                 lappend additional_mw_reference_libraries log/misc
#@             # }
#@         
#@         set additional_ndm_libraries {}
#@         if {[file exists ndm/rams.ndm]} {
#@             set additional_ndm_libraries ndm/rams.ndm
#@         }
#@ 
#@     } elseif {[string match AV16* $technology]} {
#@     
#@         puts "Note: Using Avago Lib - technology = '$technology'"
#@         
#@         set use_scan_flops true
#@         
#@         # set max_corner ??
#@         
#@         # Temporary hack to get list of rams
#@         
#@             set mak_filename ../src/$chip_name/src/vendors/avago/avago.mak
#@             set rams {}
#@             set infile [open $mak_filename]
#@             while { ![eof $infile] } {
#@                 gets $infile line
#@                 if { [regexp -- {-o:([^\s]*)} $line dummy match]} {
#@                     lappend rams $match
#@                 }
#@             }
#@             close $infile
#@         
#@         # Temporary source directory for ram libs
#@         
#@             set rams_src_root [getenv MY_PROJECT]/$chip_name/src/vendors/avago
#@             set rams_src_root n/a
#@ 
#@         set additional_mw_reference_libraries {}
#@         
#@         # Set milkyway pointer to physical libraries
#@             # if {[file exists rams]} {
#@                 lappend additional_mw_reference_libraries log/rams
#@             # }
#@         
#@         # Set milkyway pointer to misc ip libraries
#@             # if {[file exists misc]} {
#@                 lappend additional_mw_reference_libraries log/misc
#@             # }
#@         
#@         # Temporary (??) destination directory for .dbs
#@             
#@             set rams_root .
#@ 
#@         puts "rams_src_root = '$rams_src_root'"
#@         puts "rams_root     = '$rams_root'"
#@ 
#@         set additional_link_libraries [concat [glob -nocomplain $rams_root/*_ss_slow_0.db] \
#@                                               [glob -nocomplain $rams_root/*_slowg_0c_0p72v.db]]
#@ 
#@     } elseif {[string match TSMC40* $technology]} {
#@ 
#@         if {[info exists sh_product_version] && ([string match *2007.12* $sh_product_version] || [string match *2008* $sh_product_version] || [string match *2009* $sh_product_version])} {
#@             set memlib_version v2007.12
#@         } else {
#@             set memlib_version v2006.06
#@         }
#@         set max_corner ss090125
#@         set rams_root3 $shared_dir/hwcommon/libs/broadcom/tsmc40g/Q4_A0/custom_cells.rel101012/synopsys
#@         # only look for the ss 090125 libs as templates, not the wc_cold 090-40
#@         lappend search_path $rams_root3/$memlib_version/ss $rams_root3/$memlib_version/ff
#@         lappend additional_link_libraries allG40FSRF_tsmc40g_ss090125.db allG40HDOTP_tsmc40g_ss090125.db allG40SP_tsmc40g_ss090125.db
#@         # SPONG # probably redundant but leave here for the moment in case we want to compile with q3 libs for comparison
#@ 
#@     } else {
#@     
#@         puts "Err\or: Undefined technology '$technology'"
#@         exit
#@     }
#@ }
#@ 
#@ proc decode_ulvt_dir { dir } {
#@     array set ulvtmap { ll undef ln 0 ul 99 un 1 el undef en 1000 }
#@     if { [regexp {_([lue][ln])([lue][ln])?(/log)?$} $dir dummy one two three] } {
#@         if { $ulvtmap($one) eq {undef} || $ulvtmap($two) eq {undef} } {
#@             return "Error: Can't derive VTs from directory name '$dir'"
#@             return 0
#@         }
#@         if { ($two == {}) || ($two eq $one) } {
#@             return $ulvtmap($one)
#@         } else {
#@             return "\$topographical_mode ? $ulvtmap($two) : $ulvtmap($one)"
#@         }
#@     } else {
#@         return {$topographical_mode ? 99 : 0}
#@     }
#@ }
#@ 
#@ if { ! [info exists enable_ulvt_cells] } {
#@     set enable_ulvt_cells [decode_ulvt_dir [pwd]]
#@ }
#@ 
#@ if { [info exists sh_product_version] && [string match *2003* $sh_product_version] } {
#@     set specific_library_version 2003.06
#@     puts "Using $specific_library_version library files only - because of $sh_product_version"
#@ }
#@ 
#@ # set use_warpcore_ilm switch based on cfg - effects libraries and search paths defined by common.tcl
#@ if { [array get env SYNOPSYS_SCRIPT_VERSION] != {} && \
#@                $env(SYNOPSYS_SCRIPT_VERSION) != {} } {
#@     if { [ regexp {^q[34]chip_ilmwilm$} $env(SYNOPSYS_SCRIPT_VERSION) ] } {
#@          puts "setting warpcore ilm mode"
#@          set use_warpcore_ilm 1
#@     }
#@ }
#@ 
#@ set memoir_ram_file ../src/$chip_name/src/vendors/memoir/memoir_rams.tcl
#@ if { [file readable $memoir_ram_file]} {
#@     puts "memoir_ram_file = '$memoir_ram_file'"
#@     source $memoir_ram_file
#@ } else {
#@     puts Information: No memoir ram file found at '$memoir_ram_file'
#@ }
#@ # -- Starting source ../src/q6chip/src/vendors/memoir/memoir_rams.tcl

#@ set memoir_rams {
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1024X40R20221VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1024X44R20221VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1280X113R20222VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1280X134R20222VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1280X64R20221VTLPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC15360X22R40421VTHPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1715175950/memory/prod/sim/verilog/M3PD211HC1536X134R20222VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1536X16R20221VTLPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1536X39R20221VTLPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1536X39R20221VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1536X57R20221VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC1536X85R20221VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X24R40421VTHPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X27R40422VTLPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X35R40422VTLPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X36R40422VTLPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X36R40422VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X39R40422VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC16384X40R40422VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC2048X137R20222VTHPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC2048X81R20221VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC4096X102R20421VTHPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC4096X82R20421VTHPEBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC4096X85R20421VTHPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC4096X96R20421VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC4096X98R20421VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PD211HC768X134R20222VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PSP111HD16384X35R30821VTLPEBRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PSP111HD16384X90R30822VTLPEBRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PSP111HD2048X101R20422VTLPEBRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PSP111HD8192X134R30423VTLPEBRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PSP111HD8192X268R20823VTLPEBRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3PSP111HD8192X80R20821VTLPEBRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1717682056/memory/prod/sim/verilog/M3SP111HD16384X130R30823VTNPEBGRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SP111HD16384X27R40421VTLPEBGRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SP111HD16384X88R30823VTNPEBGRCW1H20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SP111HD32768X40R40823VTNPEBGRCW1H20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SP111HD8192X213R20823VTLPEBGRCH20OLD.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC1024X18RR20211VTLPFEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC256X134RR10121VTLPFREBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC256X22RR10111VTLPFREBRCH20OLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC384X144RR10221VTLPFEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC384X71RR10221VTLPFEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1715175950/memory/prod/sim/verilog/M3SRF211HC512X134RR10221VTLPFEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC512X144RR10221VTLPFEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1712937234/memory/prod/sim/verilog/M3SRF211HC64X142RR10121VTLPEBRCH20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC80X32RR10111VTLPEBRCW1H20QOLA.v
#@     /shared/q6chip/elway/memgine/1716570079/memory/prod/sim/verilog/M3SRF211HC80X33RR10111VTLPEBRCW1H20QOLA.v
#@ }
#@ # -- End source ../src/q6chip/src/vendors/memoir/memoir_rams.tcl

#@ 
#@ source $common_dir/common.tcl
#@ # -- Starting source /work/aigbe/syn/q6chip/syn/runs1/brcm3_test_240725/common/common.tcl

#@ 
#@ proc product_version_year {} {
#@     global sh_product_version
#@     if { ! [info exists sh_product_version] } {
#@         puts {Error: Request for [product_version_year] when sh_product_version does not exist}
#@         return 2099
#@     }
#@     return [regsub  {\..*} [regsub {^(.\-)?} $sh_product_version {}] {}]
#@ }
#@ 
#@ proc product_version_month {} {
#@     global sh_product_version
#@     if { ! [info exists sh_product_version] } {
#@         puts {Error: Request for [product_version_month] when sh_product_version does not exist}
#@         return 2099.99
#@     }
#@     return [regsub {(-.*)?$} [regsub {^(.\-)?}  $sh_product_version {}] {}]
#@ }
#@ 
#@ proc recursive_glob { path patt } {
#@     set l [glob -nocomplain $path/$patt]
#@     foreach d [glob -nocomplain $path/*] {
#@         if { [file isdirectory $d] } {
#@             set l [concat $l [recursive_glob $d $patt]]
#@         }
#@     }
#@     return $l
#@ }
#@ 
#@ proc grep { expr list } {
#@     set result {}
#@     upvar _ _
#@     foreach _ $list {
#@         if { [uplevel "expr $expr"] } {
#@             lappend result $_
#@         }
#@     }
#@     return $result
#@ }
#@ 
#@ proc get_library_operating_conditions { selector } {
#@     global library_operating_conditions
#@     array set oper $library_operating_conditions
#@     return $oper($selector)
#@ }
#@ 
#@ proc fixup_lib_name {str} {
#@     global tech_library
#@     global library
#@     if { [regexp {^(.*)/(.*)$} $str whole lib cell] } {
#@         return "$library($lib)/$cell"
#@     } elseif { [regsub {\-lib ([^\s]+)} $str {-lib $library(\1)} str] } {
#@         return [subst $str]
#@     } elseif { [array names library -exact $str] != {} } {
#@         return $library($str)
#@     } else {
#@         # Is this one really what we want ...
#@         return "$tech_library/$str"
#@     }
#@ }
#@ 
#@ proc search_for_file { fnames } {
#@     global search_path
#@     set result [list]
#@     foreach fname $fnames {
#@         if { [ file readable $fname ] } {
#@             lappend result $fname
#@         } else {
#@             # should we check that fname is not an absolute path before doing this check ?
#@             foreach p $search_path {
#@                 if { [ file readable $p/$fname ] } {
#@                     lappend result $p/$fname
#@                     break
#@                 }
#@             }
#@         }
#@     }
#@     return $result
#@ }
#@ 
#@ proc common_exists_and_true { var_name } {
#@     upvar $var_name var 
#@     if { [info exists var] } {
#@         return [expr {$var == "true"} || {$var == 1}]
#@     } else {
#@         return 0
#@     }   
#@     return 0 
#@ }
#@ 
#@ if {! [info exists done_common]} {
#@ 
#@     if { ! [info exists search_path] } {
#@         set search_path {}
#@     }
#@     
#@     set synthesis_dir [file dirname [pwd]]
#@     set main_synthesis_dir $synthesis_dir
#@     foreach dir_name [list [file dirname [file dirname [pwd]]]/syn [file dirname [file dirname [file dirname [file dirname [pwd]]]]]/syn $project_dir/$chip_name/syn] {
#@         if {[file exists $dir_name/scripts]} {
#@             set main_synthesis_dir $dir_name
#@             break
#@         }
#@     }
#@     set log_dir $synthesis_dir/log
#@     set results_dir $synthesis_dir/results
#@     set sdf_dir $synthesis_dir/sdf
#@     set reports_dir $synthesis_dir/reports
#@     set libs_dir $synthesis_dir/libs
#@     set tmp_dir $log_dir/tmp
#@     
#@     foreach dir_name [list $synthesis_dir/src $project_dir] {
#@         if {[file exists $dir_name]} {
#@             set source_dir $dir_name
#@             break
#@         }
#@     }
#@ 
#@     set pc 0
#@     if {[info exists arch]} {
#@         if {$arch == {msvc50}} {
#@             set pc 1
#@         }
#@     }
#@     if {[info exists sh_arch]} {
#@         if {$sh_arch == {msvc50}} {
#@             set pc 1
#@         }
#@     }
#@     set linux 0
#@     if {[info exists arch]} {
#@         if {$arch == {linux}} {
#@             set linux 1
#@         }
#@     }
#@     if {[info exists sh_arch]} {
#@         if {$sh_arch == {linux}} {
#@             set linux 1
#@         }
#@     }
#@     if {$pc} {
#@         set null nul
#@     } else {
#@         set null /dev/null
#@     }
#@ 
#@     set format  db
#@     set format2 db
#@     set xg_force_db {}
#@     
#@     # move format to ddc for dc_shell 2013 etc - should this be in common - check with Michael - SPONG SPONG
#@     if { [info exists sh_product_version] && \
#@          [regexp -inline {20\d\d} $sh_product_version] >= 2013 && \
#@          ! [regexp {np\d?chip} $chip_name] && \
#@          ! [regexp {m\d?chip} $chip_name] } {
#@         set format  ddc
#@         set format2 ddc
#@     }
#@     
#@     if {[array get env HW_SYNCED] != {}} {
#@         regsub -all {\\} $env(HW_SYNCED) / shared_dir
#@         if {[info exists sh_arch] && $sh_arch == {linux}} {
#@             regsub {^([A-Za-z]):} $shared_dir {/cygdrive/\1} shared_dir
#@         }
#@     } else {
#@         if {[info exists sh_arch] && $sh_arch == {linux}} {
#@             set shared_dir /cygdrive/s/synced
#@         } else {
#@             set shared_dir S:/synced
#@         }
#@     }
#@ 
#@     if {[array get env SYNOPSYS_CACHE_DIR] != {}} {
#@         regsub -all -- {\\} $env(SYNOPSYS_CACHE_DIR) / cache_dir
#@     } else {
#@         set cache_dir $project_dir/libs
#@     }
#@ 
#@     if {[info exists version]} {
#@         regsub -all HYPHEN $version - version
#@     }
#@     
#@     if {[info exists script_name]} {
#@         set tmp_script_name _$script_name
#@     } elseif { [array get env SYNOPSYS_SCRIPT_NAME] != {} && \
#@                $env(SYNOPSYS_SCRIPT_NAME) != {} } {
#@         set script_name $env(SYNOPSYS_SCRIPT_NAME)
#@         set tmp_script_name _$script_name
#@     } else {
#@         set script_name unknown
#@         set tmp_script_name {}
#@     }
#@     
#@     if {[info exists previous_script_name]} {
#@         set tmp_previous_script_name _$previous_script_name
#@     } else {
#@         set tmp_previous_script_name {}
#@     }
#@     
#@     if {[info exists version] && $version != {}} {
#@         set tmp_version _$version
#@     } elseif { [array get env SYNOPSYS_SCRIPT_VERSION] != {} && \
#@                $env(SYNOPSYS_SCRIPT_VERSION) != {} } {
#@         set version $env(SYNOPSYS_SCRIPT_VERSION)
#@         set tmp_version _$version
#@     } else {
#@         if {[info exists default_version]} {
#@             set version $default_version
#@         } else {
#@             set version default
#@         }
#@         set tmp_version {}
#@     }
#@ 
#@     if {[info exists type]} {
#@         regsub -all HYPHEN $type - type
#@     } elseif { [array get env SYNOPSYS_SCRIPT_TYPE] != {} && \
#@                $env(SYNOPSYS_SCRIPT_TYPE) != {} } {
#@         set type $env(SYNOPSYS_SCRIPT_TYPE)
#@     } elseif {[info exists default_type]} {
#@         set type $default_type
#@     } else {
#@         set type {}
#@     }
#@ 
#@     if {[regexp {np\d?chip} $chip_name] || [regexp {m\d?chip} $chip_name] || [regexp {q\d?chip} $chip_name] || [regexp {e\d+chip} $chip_name] || [regexp {s\d+chip} $chip_name] || [regexp {pconchip} $chip_name] || $chip_name == {t5chip} || $chip_name == {p5chip} || $chip_name == {t6chip} || $chip_name == {p6chip}} {
#@         set input_file_name ${chip_name}${tmp_previous_script_name}_$version
#@         set output_file_name $chip_name$tmp_script_name$tmp_version
#@         set tmp_file_name tmp_$chip_name$tmp_script_name$tmp_version
#@     } else {
#@         set input_file_name ${chip_name}_$version$tmp_previous_script_name
#@         set output_file_name $chip_name$tmp_version$tmp_script_name
#@         set tmp_file_name tmp_$chip_name$tmp_version$tmp_script_name
#@     }
#@     set input_file_base $results_dir/$input_file_name
#@     set input_file $input_file_base.$format
#@     set report_file_base $reports_dir/$output_file_name
#@     set report_file $report_file_base
#@     set output_file_base $results_dir/$output_file_name
#@     set output_file $output_file_base.$format
#@     set tmp_file_base $tmp_dir/$tmp_file_name
#@     set tmp_file $tmp_file_base.tmp
#@     
#@     foreach dir_name [list $libs_dir $results_dir $results_dir/assignpins $reports_dir $tmp_dir] {
#@         if {! [file exists $dir_name]} {
#@             file mkdir $dir_name
#@         }
#@     }
#@     
#@     if { [info exists synopsys_program_name] && \
#@          ( $synopsys_program_name != {milkyway} && \
#@            $synopsys_program_name != {lc_shell} && \
#@            $synopsys_program_name != {pt_shell} && \
#@            $synopsys_program_name != {ca_shell} && \
#@            $synopsys_program_name != {fm_shell} && \
#@            $synopsys_program_name != {tmax_tcl} && \
#@            $synopsys_program_name != {icc2_lm_shell} && \
#@            $synopsys_program_name != {lm_shell} ) } {
#@         foreach file [list $source_dir/$chip_name/makefile.library_definitions.tcl $source_dir/$chip_name/src/makefile.library_definitions.tcl makefile.library_definitions.tcl] {
#@             if {[file exists $file]} {
#@                 source $file
#@                 break
#@             }
#@         }
#@     } else {
#@         set sh_source_uses_search_path true
#@     }
#@ 
#@     set search_path [concat . $search_path]
#@     lappend search_path $synthesis_dir/scripts $main_synthesis_dir/scripts $common_dir $results_dir
#@ 
#@     set topographical_mode 0
#@     if { ( (! [info exists synopsys_program_name] || $synopsys_program_name == {dc_shell}) && \
#@            [info exists sh_product_version] && \
#@            [regexp -inline {20\d\d} $sh_product_version] >= 2006 ) && \
#@          [shell_is_in_topographical_mode] } {
#@         set topographical_mode 1
#@     }
#@ 
#@     set nxt_mode 0
#@     if { ( (! [info exists synopsys_program_name] || $synopsys_program_name == {dc_shell}) && \
#@            [info exists sh_product_version] && \
#@            [regexp -inline {20\d\d} $sh_product_version] >= 2019 ) && \
#@          [shell_is_dcnxt_shell] } {
#@         set nxt_mode 1
#@     }
#@ 
#@     set shell_prompt {$CI> }
#@     if {! [info exists sh_product_version] || [regexp -inline {20\d\d} $sh_product_version] < 2020} {
#@         set cache_write $cache_dir
#@         set cache_read [list $cache_dir]
#@     }
#@     set test_infer_slave_clock_pulse_after_capture true
#@     set write_name_nets_same_as_ports true
#@     if {! $topographical_mode} {
#@         set auto_wire_load_selection false
#@         if {! [info exists sh_product_version] || [regexp -inline {20\d\d} $sh_product_version] < 2008} {
#@             set hdlin_translate_off_skip_text true
#@         }
#@     }
#@     set hdlin_while_loop_iterations 65536 
#@     if {[info exists sh_product_version] && [regexp -inline {20\d\d} $sh_product_version] >= 2008} {
#@         # Variable hlo_resource_allocation does not have any effect in compile_ultra. (INFO-105)
#@         suppress_message INFO-105
#@     }
#@     set hlo_resource_allocation none
#@     set enable_recovery_removal_arcs true
#@     set physopt_fix_multiple_port_nets true
#@     set sh_enable_page_mode false
#@     set power_keep_license_after_power_commands true
#@     set hdl_preferred_license vhdl
#@     if {[info exists synopsys_program_name] && $synopsys_program_name != {pt_shell} && $synopsys_program_name != {fm_shell} && $synopsys_program_name != {milkyway} && ($synopsys_program_name != {icc2_lm_shell} || [regexp -inline {20\d\d.\d\d} $sh_product_version] > 2019.03)} {
#@         # W.....: Variable sh_enable_line_editing can be set only in the .synopsys_pt.setup file. (CLE-6)
#@         set sh_enable_line_editing true
#@     }
#@ 
#@     if {! [info exists synopsys_program_name] || $synopsys_program_name != {milkyway}} {
#@         set bus_minus_style n%d
#@         set bus_naming_style %s_%d
#@         set bus_inference_style %s_%d
#@         set bus_range_separator_style downto
#@         set bus_dimension_separator_style _
#@         set bus_multiple_separator_style and
#@     }
#@ 
#@     if {[info exists synopsys_program_name] && $synopsys_program_name == {fm_shell}} {
#@         set hdlin_dwroot $env(SYNOPSYS_SYN)
#@         set hdlin_synroot $env(SYNOPSYS_SYN)
#@         if {[info exists sh_product_version] && [regexp -inline {20\d\d} $sh_product_version] >= 2014} {
#@             set hdlin_vhdl_std 1993
#@         }
#@     }
#@ 
#@     if {[info exists synopsys_program_name] && $synopsys_program_name == {pt_shell}} {
#@         set ptxr_root $env(SYNOPSYS_SYN)
#@     }
#@ 
#@     if {! [info exists sh_product_version] || [regexp -inline {20\d\d} $sh_product_version] < 2006} {
#@         set hdlin_write_gtech_design_directory $libs_dir/gtech
#@         if {! [file exists $hdlin_write_gtech_design_directory]} {
#@             file mkdir $hdlin_write_gtech_design_directory
#@         }
#@     }
#@ 
#@     if {! [info exists technology]} {
#@         if {[array get env TECHNOLOGY] != {}} {
#@             set technology $env(TECHNOLOGY)
#@         } else {
#@             set technology {}
#@         }
#@     }
#@ 
#@     if {! [info exists map_effort]} {
#@         set map_effort medium
#@     }
#@ 
#@     if {! [info exists licenses_required]} {
#@         set licenses_required [list]
#@     }
#@ 
#@     if { ! [info exists synopsys_program_name] || \
#@          ( $synopsys_program_name != {pt_shell} && \
#@            $synopsys_program_name != {ca_shell} && \
#@            $synopsys_program_name != {fm_shell} && \
#@            $synopsys_program_name != {tmax_tcl} ) } {
#@         lappend licenses_required DC-Expert DesignWare
#@         if {! [info exists extra_licenses_required] || [lsearch $extra_licenses_required *-Compiler*] == -1} {
#@             lappend licenses_required VHDL-Compiler
#@         }
#@     }
#@ 
#@     if {[info exists extra_licenses_required]} {
#@         lappend licenses_required $extra_licenses_required
#@     }
#@     
#@     set synthetic_library [list standard.sldb]
#@ 
#@     if { [info procs is_false] == {} } {
#@         proc is_false {expression} {
#@             if {$expression == {} || $expression == {false}} {
#@                 return 1
#@             } elseif {$expression == {true}} {
#@                 return 0
#@             } else {
#@                 return [expr $expression == 0]
#@             }
#@         }
#@     }
#@     
#@     if { [info procs is_true] == {} } {
#@         proc is_true {expression} {
#@             if {$expression == {true}} {
#@                 return 1
#@             } elseif {$expression == {} || $expression == {false}} {
#@                 return 0
#@             } else {
#@                 return [expr $expression != 0]
#@             }
#@         }
#@     }
#@ 
#@     if { [info exists enable_ulvt_cells] } {
#@         # So that in project.tcl we can use "set enable_ulvt_cells {$topographical_mode}", for example.
#@         set enable_ulvt_cells [expr $enable_ulvt_cells]
#@     }
#@ 
#@     if {$technology == {} || $technology == {none}} {
#@         set link_library [list {*}]
#@         set target_library [list]
#@         set symbol_library [list]
#@ # pragma sync_to_broadcom off
#@     } elseif {$technology == {CB11}} {
#@         set library_root $shared_dir/hwcommon/libs/nec/opencad6.0/solaris/lib/CB11/cmos_1.8V/synopsys
#@         
#@         lappend search_path \
#@             $library_root/object/basic \
#@             $library_root/object/clockdriver \
#@             $library_root/object/iobuffer \
#@             $library_root/object/primitive \
#@             $library_root/object/scan \
#@             $library_root/object/special \
#@             $library_root/object/testact \
#@             $library_root/wire_model
#@ 
#@         set libraries [list \
#@             CB11_CMOS_18V_?_BASIC \
#@             CB11_CMOS_18V_?_DRIVE \
#@             CB11_CMOS_18V_?_IO \
#@             CB11_CMOS_18V_?_PRIM \
#@             CB11_CMOS_18V_?_SCAN \
#@             CB11_CMOS_18V_?_SPECIAL \
#@             CB11_CMOS_18V_?_TESTACT]
#@         
#@         regsub -all -- {\?} $libraries MAX tmp
#@         set link_library [concat {*} [split [join $tmp {.db }].db] WIRE_F80D6C.db]
#@         set target_library [split [join $tmp {.db }].db]
#@ 
#@         regsub -all -- {\?} $libraries SYMBOL tmp
#@         set symbol_library [split [join $tmp {.sdb }].sdb]
#@ 
#@         set physical_library $cache_dir/${technology}_psyn.pdb
#@         
#@         set lef_technology_dir $library_root/../lef/7L/50u/common
#@         set lef_cell_root_dir $library_root/../../common/lef
#@         set lef_cell_sub_dirs [list basic clockdriver common iobuffer primitive scan special testact]
#@     } elseif {$technology == {CB12}} {
#@         set library_root $shared_dir/hwcommon/libs/nec/opencad6.0_2/solaris/lib/CB12/cmos_1.5V_L/synopsys
#@         
#@         lappend search_path \
#@             $library_root/object/clockdriver \
#@             $library_root/object/iobuffer \
#@             $library_root/object/primitive \
#@             $library_root/object/scan \
#@             $library_root/object/special \
#@             $library_root/object/testact \
#@             $library_root/wire_model
#@ 
#@         set libraries [list \
#@             CB12_CMOS_15V_L_?_DRIVE \
#@             CB12_CMOS_15V_L_?_IO \
#@             CB12_CMOS_15V_L_?_PRIM \
#@             CB12_CMOS_15V_L_?_SCAN \
#@             CB12_CMOS_15V_L_?_SPECIAL \
#@             CB12_CMOS_15V_L_?_TESTACT]
#@         
#@         regsub -all -- {\?} $libraries MAX tmp
#@         set link_library [concat {*} [split [join $tmp {.db }].db] WIRE_F78D5T.db]
#@         set target_library [split [join $tmp {.db }].db]
#@ 
#@         regsub -all -- {\?} $libraries SYMBOL tmp
#@         set symbol_library [split [join $tmp {.sdb }].sdb]
#@ 
#@         set physical_library $cache_dir/${technology}_psyn.pdb
#@         
#@         set lef_technology_dir $library_root/../lef/7L/50u/common
#@         set lef_cell_root_dir $library_root/../../common/lef/L
#@         set lef_cell_sub_dirs [list clockdriver common iobuffer primitive scan special testact]
#@     } elseif {$technology == {HL160C}} {
#@         lappend licenses_required LUCENT-HL160C
#@     
#@         set library_root $shared_dir/hwcommon/libs/lucent/ads80/lib/pclib/hl160c
#@ 
#@         lappend search_path \
#@             $library_root/io_cup/synop/99_05 \
#@             $library_root/io_cup/synop/symbols \
#@             $library_root/maclog/synop \
#@             $library_root/perf/synop/99_05 \
#@             $library_root/perf/synop/symbols \
#@             $library_root/special_io_cup/synop/99_05 \
#@             $library_root/special_io_cup/synop/symbols  
#@ 
#@         set libraries [list \
#@             HL160C \
#@             HL160C_IO_CUP \
#@             HL160C_SPIO_CUP]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db] HL160C_WIRE.db]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $libraries {.sdb }].sdb]
#@     } elseif {$technology == {LP160C}} {
#@         lappend licenses_required LUCENT-LP160C
#@     
#@         set library_root $shared_dir/hwcommon/libs/lucent/ads80/lib/pclib/lp160c
#@ 
#@         lappend search_path \
#@             $library_root/io_cup/synop/99_05 \
#@             $library_root/io_cup/synop/symbols \
#@             $library_root/maclog/synop \
#@             $library_root/perf/synop/99_05 \
#@             $library_root/perf/synop/symbols
#@ 
#@         set libraries [list \
#@             LP160C \
#@             LP160C_IO_CUP]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db] LP160C_WIRE.db]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $libraries {.sdb }].sdb]
#@     } elseif {$technology == {LV160C}} {
#@         lappend licenses_required LUCENT-LV160C
#@     
#@         set library_root $shared_dir/hwcommon/libs/lucent/ads80/lib/pclib/lv160c
#@ 
#@         lappend search_path \
#@             $library_root/io_cup/synop/99_05 \
#@             $library_root/io_cup/synop/symbols \
#@             $library_root/maclog/synop \
#@             $library_root/perf/synop/99_05 \
#@             $library_root/perf/synop/symbols
#@ 
#@         set libraries [list \
#@             LV160C \
#@             LV160C_IO_CUP]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db] LV160C_WIRE.db]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $libraries {.sdb }].sdb]
#@     } elseif {$technology == {SC9T}} {
#@         set library_root $shared_dir/hwcommon/libs/agere/ads/ads400/lib/pclib/tsmc_cln90g/sc9t/synop
#@ 
#@         lappend search_path $library_root $library_root/../../synop
#@ 
#@         set libraries [list TSMC_CLN90G_SC9T_SLOW_125_0P9 TSMC_CLN90G_WIRE]
#@         set symbol_libraries [list TSMC_CLN90G_SC9T]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $symbol_libraries {.sdb }].sdb]
#@ 
#@         set tech_library TSMC_CLN90G_SC9T_SLOW_125_0P9
#@ 
#@     } elseif {$technology == {SC9WT} || $technology == {SC9NT}} {
#@         if {! [info exists library_root]} {
#@             set library_root $shared_dir/hwcommon/libs/agere/ads/ads411.03/lib/pclib/tsmc_cln90g
#@             
#@             # if using ccs compatible primetime pull in the ccs libraries
#@             if { [info exists synopsys_program_name] && $synopsys_program_name == {pt_shell} && \
#@                  [info exists sh_product_version] && ( [string match "*2007.06*" $sh_product_version] || [string match "*2007.12*" $sh_product_version] ) } {
#@                 set library_root $shared_dir/hwcommon/libs/agere/ads/ads90.2.5/lib/pclib/tsmc_cln90g
#@             }
#@         }
#@         if {! [info exists custom_libs_root]} {
#@             set custom_libs_root $shared_dir/hwcommon/libs/agere/custom/custom_alcatel_070323
#@         }
#@         if {! [info exists polaris_root]} {
#@             set polaris_root $shared_dir/hwcommon/libs/agere/custom/POLARIS_release_3.2
#@         }
#@ 
#@         # Technology Libraries
#@ 
#@         set suffix03_6 .2003.06-SP1
#@         if { [info exists sh_product_version] && ! [string match *2003* $sh_product_version] } {
#@             set suffix03_6 {}
#@         }
#@ 
#@         set tech_library TSMC_CLN90G_${technology}_SLOW_125_0P9
#@         set symbol_libraries [list TSMC_CLN90G_$technology]
#@         set physical_library [list TSMC_CLN90G_${technology}_9_KK_ALL_WCS_PHYS.pdb \
#@                                    TSMC_CLN90G_${technology}_PHYS.pdb]
#@ 
#@         lappend search_path \
#@             $library_root/[string tolower $technology]/galaxy_[string tolower $technology]          \
#@             $library_root/[string tolower $technology]/galaxy_[string tolower $technology]/LM       \
#@             $library_root/[string tolower $technology]lvt/galaxy_[string tolower $technology]lvt    \
#@             $library_root/[string tolower $technology]lvt/galaxy_[string tolower $technology]lvt/LM \
#@             $library_root/[string tolower $technology]hvt/galaxy_[string tolower $technology]hvt    \
#@             $library_root/[string tolower $technology]hvt/galaxy_[string tolower $technology]hvt/LM \
#@             $library_root/galaxy
#@ 
#@         set libraries [list TSMC_CLN90G_${technology}_SLOW_125_0P9$suffix03_6 \
#@                             TSMC_CLN90G_WIRE                      \
#@                       ]
#@         set tech_library_file TSMC_CLN90G_${technology}_SLOW_125_0P9$suffix03_6.db
#@ 
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         if {! [info exists dont_use_svt_target_lib]} {
#@             set tech_file_and_libraries [list $tech_file_and_library]
#@             set target_library $tech_library_file
#@         } else {
#@             set tech_file_and_libraries [list]
#@             set target_library [list]
#@         }
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set symbol_library [split [join $symbol_libraries {.sdb }].sdb]
#@ 
#@         if {[info exists use_hvt_target_lib]} {
#@             puts "Using HVT target lib"
#@             lappend target_library TSMC_CLN90G_${technology}HVT_SLOW_125_0P9.db
#@             lappend tech_file_and_libraries TSMC_CLN90G_${technology}HVT_SLOW_125_0P9.db:TSMC_CLN90G_${technology}HVT_SLOW_125_0P9
#@             set use_hvt_link_lib true
#@         }
#@         if {[info exists use_hvt_link_lib]} {
#@             if {$use_hvt_link_lib == {special}} {
#@                 # SPONG: This doesn't change the SVT library to M40_0P9 so this is very conservative
#@                 lappend link_library TSMC_CLN90G_${technology}HVT_SLOW_M40_0P9.db
#@             } else {
#@                 lappend link_library TSMC_CLN90G_${technology}HVT_SLOW_125_0P9.db
#@             }
#@             lappend physical_library TSMC_CLN90G_${technology}HVT_PHYS.pdb
#@         }
#@ 
#@         if {[info exists use_lvt_target_lib]} {
#@             puts "Using LVT target lib"
#@             lappend target_library TSMC_CLN90G_${technology}LVT_SLOW_125_0P9.db
#@             lappend tech_file_and_libraries TSMC_CLN90G_${technology}LVT_SLOW_125_0P9.db:TSMC_CLN90G_${technology}LVT_SLOW_125_0P9
#@             set use_lvt_link_lib true
#@         }
#@         if {[info exists use_lvt_link_lib]} {
#@             lappend link_library     TSMC_CLN90G_${technology}LVT_SLOW_125_0P9.db
#@             lappend physical_library TSMC_CLN90G_${technology}LVT_PHYS.pdb
#@         }
#@ 
#@         if {$technology == {SC9NT}} {
#@             lappend search_path \
#@                 $library_root/sc9wt/galaxy_sc9wt \
#@                 $library_root/sc9wt/galaxy_sc9wt/LM
#@             lappend link_library TSMC_CLN90G_SC9WT_SLOW_125_0P9$suffix03_6.db
#@             lappend physical_library TSMC_CLN90G_SC9WT_PHYS.pdb
#@         }
#@ 
#@         # Agere Custom cell libraries for p2/q2/t2
#@ 
#@         #if { [regexp {05\d\d\d\d} $custom_libs_root] } {
#@             set link_library_x [glob -nocomplain $custom_libs_root/synop/*$suffix03_6.db]
#@         #} else {
#@         #    # for 04xxxx custom deliveries
#@         #    set link_library_x [glob -nocomplain $custom_libs_root/synop/*.db]
#@         #}
#@         set link_library_x [concat $link_library_x [grep {! [string match {*.SYNC*} $_] }                                   \
#@                                                     [recursive_glob $custom_libs_root/galaxy *SLOW_125_0P9$suffix03_6.db] ]]
#@ 
#@         set physical_library_x [glob -nocomplain $custom_libs_root/synop/*.pdb]
#@         set physical_library_x [concat $physical_library_x [grep {! [string match {*.SYNC*} $_] }             \
#@                                                             [recursive_glob $custom_libs_root/galaxy *.pdb] ]]
#@         
#@         if {[info exists no_master_and_slave_delay_line_libs]} {
#@             set link_library_x     [grep {! [regexp "MASTERG1T10W|DELAYLINEG1T10W" $_]} $link_library_x]
#@             set physical_library_x [grep {! [regexp "MASTERG1T10W|DELAYLINEG1T10W" $_]} $physical_library_x]
#@         }
#@         if {[info exists no_min_delay_line_lib]} {
#@             set link_library_x     [grep {! [regexp "MINDELC1G1T10W" $_]} $link_library_x]
#@             set physical_library_x [grep {! [regexp "MINDELC1G1T10W" $_]} $physical_library_x]
#@         }
#@         if {! [info exists no_dlyline90nm_lib]} {
#@             set link_library_x     [concat $link_library_x [glob -nocomplain $custom_libs_root/spef/*SLOW_125_0P9$suffix03_6.db]]
#@         }
#@ 
#@         if {[regexp {q\d?chip} $chip_name] } {
#@             set link_custom_libs_file "./link_custom_libs.tcl"
#@             if { ! [file readable $link_custom_libs_file] } {
#@                 set tclfile [open $link_custom_libs_file w]
#@                 puts $tclfile "# Generated by common.tcl"
#@                 foreach lib_file $link_library_x {
#@                     # put the suffix03_6 into the link_custom_libs.tcl file so that the correct lib is used depending on synopsys version
#@                     # make sure we pick up only files with existing .lib ie files that can be converted to 2003.06
#@                     regsub {.db} $lib_file {.lib} lib_file_lib
#@                     if { [file readable $lib_file_lib] } {
#@                         echo $lib_file_lib
#@                         regsub ${suffix03_6}\.db $lib_file {${suffix03_6}.db} lib_file
#@                         puts $tclfile "lappend link_library $lib_file"
#@                     }
#@                 }
#@                 foreach plib_file $physical_library_x {
#@                     puts $tclfile "lappend physical_library $plib_file"
#@                 }
#@                 close $tclfile
#@             }
#@             source $link_custom_libs_file
#@         } else {
#@             set link_library [concat $link_library $link_library_x]
#@             set physical_library [concat $physical_library $physical_library_x]
#@         }
#@         
#@         # Other custom libs
#@         set link_library [concat $link_library \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/TEFGGT256M8X1G1T10/LM/TEFGGT256M8X1G1T10_SLOW_125_0P9$suffix03_6.db     ]
#@         
#@         lappend physical_library $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/TEFGGT256M8X1G1T10/TEFGGT256M8X1G1T10_PHYS.pdb
#@ 
#@         # Extra P8051 rams available from custom_alcatel_060616 (thank goodness for a sensible date format)
#@         regexp {_([0-9]{6})} $custom_libs_root dummy custom_libs_date
#@         
#@         if { [expr ${custom_libs_date}.0 <= 060919.0] } {
#@             set link_library [concat $link_library \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M4X8G1T10/LM/SRMPBV256M4X8G1T10_SLOW_125_0P9$suffix03_6.db     \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M8X8G1T10/LM/SRMPBV256M8X8G1T10_SLOW_125_0P9$suffix03_6.db     \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M16X8G1T10/LM/SRMPBV256M16X8G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M32X8G1T10/LM/SRMPBV256M32X8G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M4X8G1T10/LM/SRMPBV2048M4X8G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M8X8G1T10/LM/SRMPBV2048M8X8G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M16X8G1T10/LM/SRMPBV2048M16X8G1T10_SLOW_125_0P9$suffix03_6.db \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M32X8G1T10/LM/SRMPBV2048M32X8G1T10_SLOW_125_0P9$suffix03_6.db ]
#@                                        
#@             lappend physical_library $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M4X8G1T10/SRMPBV256M4X8G1T10_PHYS.pdb     \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M8X8G1T10/SRMPBV256M8X8G1T10_PHYS.pdb     \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M16X8G1T10/SRMPBV256M16X8G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M32X8G1T10/SRMPBV256M32X8G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M4X8G1T10/SRMPBV2048M4X8G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M8X8G1T10/SRMPBV2048M8X8G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M16X8G1T10/SRMPBV2048M16X8G1T10_PHYS.pdb \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M32X8G1T10/SRMPBV2048M32X8G1T10_PHYS.pdb 
#@         }
#@         
#@         if { [expr ${custom_libs_date}.0 >= 060616.0] } {
#@             set link_library [concat $link_library \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M4X9G1T10/LM/SRMPBV256M4X9G1T10_SLOW_125_0P9$suffix03_6.db     \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M8X9G1T10/LM/SRMPBV256M8X9G1T10_SLOW_125_0P9$suffix03_6.db     \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M16X9G1T10/LM/SRMPBV256M16X9G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M4X9G1T10/LM/SRMPBV2048M4X9G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M8X9G1T10/LM/SRMPBV2048M8X9G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M16X9G1T10/LM/SRMPBV2048M16X9G1T10_SLOW_125_0P9$suffix03_6.db \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M32X9G1T10/LM/SRMPBV2048M32X9G1T10_SLOW_125_0P9$suffix03_6.db \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV4096M16X9G1T10/LM/SRMPBV4096M16X9G1T10_SLOW_125_0P9$suffix03_6.db \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV4096M32X9G1T10/LM/SRMPBV4096M32X9G1T10_SLOW_125_0P9$suffix03_6.db \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV4096M8X9G1T10/LM/SRMPBV4096M8X9G1T10_SLOW_125_0P9$suffix03_6.db   \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV8192M16X9G1T10/LM/SRMPBV8192M16X9G1T10_SLOW_125_0P9$suffix03_6.db \
#@                                          $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV8192M32X9G1T10/LM/SRMPBV8192M32X9G1T10_SLOW_125_0P9$suffix03_6.db ]
#@                                          
#@             lappend physical_library $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M4X9G1T10/SRMPBV256M4X9G1T10_PHYS.pdb     \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M8X9G1T10/SRMPBV256M8X9G1T10_PHYS.pdb     \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M16X9G1T10/SRMPBV256M16X9G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M4X9G1T10/SRMPBV2048M4X9G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M8X9G1T10/SRMPBV2048M8X9G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M16X9G1T10/SRMPBV2048M16X9G1T10_PHYS.pdb \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M32X9G1T10/SRMPBV2048M32X9G1T10_PHYS.pdb \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV4096M16X9G1T10/SRMPBV4096M16X9G1T10_PHYS.pdb \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV4096M32X9G1T10/SRMPBV4096M32X9G1T10_PHYS.pdb \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV4096M8X9G1T10/SRMPBV4096M8X9G1T10_PHYS.pdb   \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV8192M16X9G1T10/SRMPBV8192M16X9G1T10_PHYS.pdb \
#@                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV8192M32X9G1T10/SRMPBV8192M32X9G1T10_PHYS.pdb
#@         }
#@         # Polaris cell libraries
#@         
#@         if { [string match *POLARIS_release_2.4* $polaris_root] || \
#@              [string match *POLARIS_release_2.5* $polaris_root] || \
#@              [string match *POLARIS_release_2.6* $polaris_root] || \
#@              [string match *POLARIS_release_3.*  $polaris_root]    } {
#@             set link_library [concat $link_library                                               \
#@                                      $polaris_root/synop/P6GCMU18FC_SLOW_125_0P9$suffix03_6.db   \
#@                                      $polaris_root/synop/P6GRXTX18FC_SLOW_125_0P9$suffix03_6.db  \
#@                                      $polaris_root/synop/P6GATMCH18FC_SLOW_125_0P9$suffix03_6.db ]
#@         } else {
#@             set link_library [concat $link_library                                            \
#@                                      $polaris_root/synop/PCMU18FC_SLOW_125_0P9$suffix03_6.db  \
#@                                      $polaris_root/synop/PRXTX18FC_SLOW_125_0P9$suffix03_6.db ]
#@                                      
#@             if {[string match *POLARIS_release_2.* $polaris_root]} {
#@                 lappend link_library $polaris_root/synop/PATMCH18FC_SLOW_125_0P9$suffix03_6.db
#@             } else {
#@                 lappend link_library $polaris_root/synop/PATMCH18FC_lib.db.gz
#@             }
#@         }
#@         
#@         # Polaris/custom_lib physical libraries
#@         if { $chip_name != {t2chip} } {
#@         
#@             if { [regexp {q\d?chip} $chip_name] } {
#@                 set physical_library [concat $physical_library [glob -nocomplain $polaris_root/synop/*.pdb                                                                    \
#@                                                                                  $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M32X8G1T10/LM/*.pdb \
#@                                                                                  $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M32X8G1T10/LM/*.pdb  \
#@                                                                                  $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/TEFGGT256M8X1G1T10/LM/*pdb    ]  ]
#@                 if { [string match *_0606* $custom_libs_root] ||
#@                      [string match *_0607* $custom_libs_root] ||
#@                      [string match *_0609* $custom_libs_root] } { 
#@                     set physical_library [concat $physical_library [glob -nocomplain $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV2048M32X9G1T10/LM/*.pdb \
#@                                                                                      $custom_libs_root/memoir/macrocell_41.tsmc_cln90g/model/galaxy/SRMPBV256M32X9G1T10/LM/*.pdb  ] ]
#@                 }
#@             } else {
#@             
#@                 set physical_library [concat $physical_library [glob -nocomplain $polaris_root/synop/*.pdb] ]
#@             }
#@         }
#@         
#@         if {[info exists sh_product_version] && [string match *2003* $sh_product_version]} {
#@             # Some physical libs compiled under 2004, but we never do physopt under 2003, so don't load them
#@             set physical_library {}
#@         }
#@ 
#@         # Mike McGrath email 1/7/2004
#@     
#@         # P.S. what a load of nonsense this was!
#@ 
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/*X1G1T10W ;* too sensitive
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/*XLG1T10W ; * too sensitive
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/CTUI* ; * CTS buffers
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/CTUN* ; * CTS buffers
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/MXDFF* ; * not suitable for scan
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/LSSD* ; * not suitable for scan
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/DELU* ; * delay cells
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/TBUF* ; * tri-state buffers
#@         # set_dont_use TSMC_CLN90G_SC9WT_SLOW_125_0P9/TG* ; * transmission gates
#@         # dont_use [get_lib_cells " $lib/BUF*X16* $lib/INV*X16* "] ; * don't use the beefiest buffers for synthesis - this allows Astro to upsize if         necessary.
#@         # remove_attribute TSMC_CLN90G_SC9WT_SLOW_125_0P9/VLOX1G1T10W dont_use ; *         allow this X1 buffer
#@         # remove_attribute TSMC_CLN90G_SC9WT_SLOW_125_0P9/VHIX1G1T10W dont_use : *         allow this X1 buffer
#@ 
#@         if {$technology == {SC9NT}} {
#@             set tech_library_tieoff_cells {{VLOX1G1T10N} {VHIX1G1T10N}}
#@             set tech_library_x1_drive_cell {INVX1G1T10N}
#@             set tech_library_load_of_1pf 1
#@             set tech_clock_gating_latch TSMC_CLN90G_SC9NT_SLOW_125_0P9/SGCLATNX2G1T10N
#@             set tech_clock_gating_latch_pattern SGCLATNX*G1T10N
#@         } else {
#@             set tech_library_tieoff_cells {{VLOX1G1T10W} {VHIX1G1T10W}}
#@             set tech_library_x1_drive_cell {INVX1G1T10W}
#@             set tech_library_load_of_1pf 1
#@             set tech_clock_gating_latch TSMC_CLN90G_SC9WT_SLOW_125_0P9/SGCLATNX2G1T10W
#@             set tech_clock_gating_latch_pattern SGCLATNX*G1T10W
#@         }
#@         
#@         set tech_library_dont_use {CTUI* CTUN* MXDFF* DELU* TG*} 
#@ 
#@         if {$chip_name != {npchip} || ! [string match p* $script_name]} {
#@             lappend tech_library_dont_use {*XL*1T10*}
#@         }
#@ 
#@         if {$chip_name != {npchip} && $chip_name != {q2chip} } {
#@             lappend tech_library_dont_use {*X1*1T10*} {TBUF*} {BUF*X16*} {INV*X16*}
#@             set tech_library_do_use   [concat [lindex $tech_library_tieoff_cells 0] [lindex $tech_library_tieoff_cells 1]]
#@         }
#@         
#@         if { [regexp {q\d?chip} $chip_name] } {
#@             lappend tech_library_dont_use {*X16*} {*X12*}
#@             # lappend tech_library_dont_use {*X8*}
#@         }
#@         
#@         if { $chip_name == {npchip} && ! [string match p* $script_name] } {
#@             if { ! [string match lv* $script_name] } {
#@                 lappend tech_library_dont_use {*X16*} {*X12*}
#@             } else {
#@                 lappend tech_library_dont_use {*X16*}
#@             }
#@         }
#@         
#@     } elseif {$technology == {CORE90GPSVT}} {
#@         set library_root $shared_dir/hwcommon/libs/st/CORE90GPSVT_SNPS-AVT_1.2/SNPS
#@ 
#@         lappend search_path $library_root \
#@             $library_root/bc_1.10V_m40C_wc_0.90V_125C/PHS \
#@             $library_root/common/PHYSICAL \
#@             $library_root/common/SYMBOL \
#@             $library_root/../../tech_cmos090_7M2T
#@ 
#@         set libraries [list CORE90GPSVT_Worst]
#@         set symbol_libraries [list CORE90GPSVT]
#@         set physical_libraries [list tech_cmos090_7M2T CORE90GPSVT]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $symbol_libraries {.sdb }].sdb]
#@ 
#@         set physical_library [split [join $physical_libraries {.pdb }].pdb]
#@ 
#@         set tech_library CORE90GPSVT
#@     } elseif {$technology == {CORX90GPSVT}} {
#@         set library_root $shared_dir/hwcommon/libs/st/CORE90GPSVT_SNPS-AVT_1.2/SNPS
#@ 
#@         lappend search_path $library_root \
#@             $library_root/bc_1.10V_m40C_wc_0.90V_125C/PHS \
#@             $library_root/common/PHYSICAL \
#@             $library_root/common/SYMBOL \
#@             $library_root/../../tech_cmos090_7M2T
#@ 
#@         set library_root $shared_dir/hwcommon/libs/st/CORX90GPSVT_SNPS-AVT_3.0/SNPS
#@ 
#@         lappend search_path $library_root \
#@             $library_root/bc_1.10V_m40C_wc_0.90V_125C/PHS \
#@             $library_root/common/PHYSICAL \
#@             $library_root/common/SYMBOL \
#@             $library_root/../../tech_cmos090_7M2T
#@ 
#@         set libraries [list CORE90GPSVT_Worst CORX90GPSVT_Worst]
#@         set symbol_libraries [list CORE90GPSVT CORX90GPSVT]
#@         set physical_libraries [list tech_cmos090_7M2T CORE90GPSVT CORX90GPSVT]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $symbol_libraries {.sdb }].sdb]
#@ 
#@         set physical_library [split [join $physical_libraries {.pdb }].pdb]
#@ 
#@         set tech_library CORE90GPSVT
#@     } elseif {[string match TC260C7* $technology]} {
#@         set base_technology TC260C7
#@ 
#@         # Default only (goes on end of search path)
#@         set library_root $shared_dir/hwcommon/libs/toshiba/NDMR1.10/lib/synopsys/v1999.10/tc260c
#@ 
#@         if {$technology == {TC260C7_ndm112}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/NDMR1.12/standard/synopsys/db_files] $search_path]
#@             set search_path [concat [list  $shared_dir/hwcommon/libs/toshiba/NDMR1.12/compilable/synopsys/db_files] $search_path]
#@ 
#@             set libraries [list tc260c_hs.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c7_wire_load.db]
#@ 
#@             set tech_library {tc260c_hs}
#@             set tech_library_file {tc260c_hs.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_ulvth}} {
#@             set libraries [list tc260c_vs.tmpdb_MAX  \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c}
#@             set tech_library_file {tc260c_vs.tmpdb_MAX}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm110}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm110] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm110_slew}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm110_slew] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm110_xtalk}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm110_xtalk] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm110_xtalk_harsh}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm110_xtalk_harsh] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm112}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm112] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm112_slew}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm112_slew] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm112_xtalk}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm112_xtalk] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hp_ndm112_xtalk_harsh}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hp_ndm112_xtalk_harsh] $search_path]
#@ 
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hs_ndm112}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/NDMR1.12/standard/synopsys/db_files] $search_path]
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hs_ndm112] $search_path]
#@ 
#@ 
#@             set libraries [list tc260c_hs.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c7_wire_load.db]
#@ 
#@             set tech_library {tc260c_hs}
#@             set tech_library_file {tc260c_hs.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7_hs_ndm112_slew}} {
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/NDMR1.12/standard/synopsys/db_files] $search_path]
#@             set search_path [concat [list $shared_dir/hwcommon/libs/toshiba/timetra/tc260c_hs_ndm112_slew] $search_path]
#@ 
#@             set libraries [list tc260c_hs.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c7_wire_load.db]
#@ 
#@             set tech_library {tc260c_hs}
#@             set tech_library_file {tc260c_hs.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         } elseif {$technology == {TC260C7}} {
#@             set libraries [list tc260c_hp.db_WCMIL15 \
#@                                 tc260c_io.db_WCMIL15 \
#@                                 tc260c_wire_load.db]
#@ 
#@             set tech_library {tc260c_hp}
#@             set tech_library_file {tc260c_hp.db_WCMIL15}
#@             set tech_io_library {tc260c_io}
#@             set tech_io_library_file {tc260c_io.db_WCMIL15}
#@         }
#@ 
#@         lappend search_path $library_root      
#@ 
#@         set target_library $libraries
#@ 
#@         if {$chip_name == {qchip}} {
#@             set link_library [concat {*} $libraries tc260c.db_WCMIL15]
#@         } else {
#@             set link_library [concat {*} $libraries]
#@         }
#@ 
#@         set symbol_library {tc260c.workview.sdb}
#@ 
#@         set rc_slew_derate_from_library 0.6
#@ 
#@         set physical_library $cache_dir/TC260C7_psyn.pdb
#@         
#@         set lef_technology_dir $shared_dir/hwcommon/libs/toshiba/NDMR1.10/lib/synopsys/v1999.10/tc260c/../../../../toshiba_common/tlay/lib/TC260C
#@         set lef_files [list  \
#@             TC260C_TECH      \
#@             TC260C_LVth_PRIM \
#@             TC260C_PRIM      \
#@             TC260_IO         \
#@             TC260C_COREGLUE  \
#@             TC260_IOGLUE     \
#@             TC260C_PMEGLUE]
#@     } elseif {$technology == {SA27E}} {
#@         set library_root $shared_dir/hwcommon/libs/ibm/SA27E.v7.0/synthesis/synopsys
#@ 
#@         lappend search_path $library_root
#@ 
#@         set libraries [list \
#@             IBM_SA27E_BC \
#@             IBM_SA27E_GA \
#@             IBM_SA27E_IO \
#@             IBM_SA27E_SC]
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $libraries {.db }].db]
#@ 
#@         set symbol_library [split [join $libraries {.sdb }].sdb]
#@     } elseif {$technology == {CU08}} {
#@         proc get_ibm_library_filename { technology selector } {
#@             if { [info exists library_operating_conditions] } {
#@                 return "IBM_[string toupper $technology]"
#@             }
#@             array set cond [get_library_operating_conditions $selector]
#@             # process voltage - supports x xV 1.xV 1.xx
#@             set voltage $cond(voltage)
#@             regsub ^(.)(V?)$ $voltage {\100} voltage
#@             regsub ^(.)\.(.)(V?)$ $voltage {\1\20} voltage
#@             regsub ^(.)\.(..)(V?)$ $voltage {\1\2} voltage
#@             # process temp - just remove the trailing C
#@             set temp $cond(temperature)
#@             regsub C $temp {} temp
#@             return "IBM_[string toupper $technology]_V${voltage}T${temp}P[string tolower $cond(process)]"
#@         }
#@ 
#@         set library_root $shared_dir/hwcommon/libs/ibm/CU08_v4.0/synthesis/synopsys
#@         set fname IBM_CU08
#@ 
#@         if { [info exists library_operating_conditions] } {
#@             # set the custom library names, fix the path to these and fixup the ram library names too
#@             set fname [get_ibm_library_filename cu08 max]
#@             lappend search_path $shared_dir/hwcommon/libs/ibm/ibm_cu08/custom/synthesis/synopsys
#@             regsub -all IBM_CU08 $additional_link_libraries $fname additional_link_libraries
#@         } else {
#@             lappend search_path $library_root
#@         }
#@ 
#@         set libraries [list ${fname}_BC ${fname}_SC ${fname}_SCLVT]
#@         set target_libraries [list ${fname}_SCLVT]
#@         set symbol_libraries [list IBM_CU08_SCLVT]
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@         set symbol_library [split [join $symbol_libraries {.sdb }].sdb]
#@ 
#@         lappend search_path $library_root/../../psynthesis/pc/cell
#@ 
#@         set physical_library [list IBM_CU08_TECH_520.pdb \
#@                                    IBM_CU08_BC.pdb \
#@                                    IBM_CU08_BCLM.pdb \
#@                                    IBM_CU08_BCLVT.pdb \
#@                                    IBM_CU08_SC.pdb \
#@                                    IBM_CU08_SCLVT.pdb]
#@ 
#@         set tech_library ${fname}_SCLVT
#@     } elseif {$technology == {CU08_V090T125Pwc}} {
#@         set library_root $shared_dir/hwcommon/libs/ibm/ibm_cu08/custom/synthesis/synopsys
#@ 
#@         lappend search_path [list $library_root $shared_dir/hwcommon/libs/ibm/CU08_v4.0/synthesis/synopsys]
#@ 
#@         set libraries [list IBM_CU08_V090T125Pwc_BC IBM_CU08_V090T125Pwc_SC IBM_CU08_V090T125Pwc_SCLVT]
#@         set target_libraries [list IBM_CU08_V090T125Pwc_SCLVT]
#@         set symbol_libraries [list IBM_CU08_SCLVT]
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@         set symbol_library [split [join $symbol_libraries {.sdb }].sdb]
#@ 
#@         lappend search_path $shared_dir/hwcommon/libs/ibm/CU08_v4.0/psynthesis/pc/cell
#@ 
#@         set physical_library [list IBM_CU08_TECH_520.pdb \
#@                                    IBM_CU08_BC.pdb \
#@                                    IBM_CU08_BCLM.pdb \
#@                                    IBM_CU08_BCLVT.pdb \
#@                                    IBM_CU08_SC.pdb \
#@                                    IBM_CU08_SCLVT.pdb]
#@ 
#@         set tech_library IBM_CU08_SCLVT
#@     } elseif {$technology == {artisan}} {
#@         set library_root $shared_dir/hwcommon/libs/artisan/aci/sc-x/synopsys
#@ 
#@         lappend search_path $library_root
#@ 
#@         set libraries [list slow]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $libraries {.db }].db]
#@         set physical_library [list tsmc090.pdb]
#@ 
#@         set tech_library {slow}
#@         set tech_library_file {slow.db}
#@ # pragma sync_to_broadcom on
#@     } elseif {$technology == {TSMC13}} {
#@         set base_technology TSMC13
#@ 
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc13
#@ 
#@         lappend search_path \
#@             $library_root/custom_cells \
#@             $library_root/custom_cells/RAMS/v6/synopsys \
#@             $library_root/custom_cells/RAMS_DSPM/v2/synopsys \
#@             $library_root/custom_cells/RAMS_G13SP/v5/synopsys \
#@             $library_root/custom_cells/XGXS_IP/v17/synopsys \
#@             $library_root/sc/v2/synopsys/v2000/generic \
#@             $library_root/sc/v2/synopsys/v9905/ss \
#@             $library_root/sc/v2/synopsys/v9905/ff \
#@             $library_root/misc/v2/synopsys/v2000/generic \
#@             $library_root/misc/v2/synopsys/v9905/ss \
#@             $library_root/misc/v2/synopsys/v9905/ff \
#@             $library_root/io/v5/synopsys/v2000/generic \
#@             $library_root/io/v5/synopsys/v9905/ss \
#@             $library_root/io/v5/synopsys/v9905/ff \
#@             $library_root/io_35um/v4/synopsys/v2000/generic \
#@             $library_root/io_35um/v4/synopsys/v9905/ss \
#@             $library_root/io_35um/v4/synopsys/v9905/ff
#@ 
#@         set link_libraries [list tsmc13_2.db tsmc13misc_2.db tsmc13io_5.db tsmc13ion_4.db tsmc13_wire_load.db]
#@         set target_libraries [list tsmc13_2.db]
#@ 
#@         set tech_library {tsmc13}
#@         set tech_library_file {tsmc13_2.db}
#@         set tech_io_library {tsmc13io}
#@         set tech_io_library_file {tsmc13io_5.db}
#@ 
#@         set link_library [concat {*} $link_libraries]
#@         set target_library $target_libraries
#@         set symbol_library {broadcom.sdb}
#@         set physical_library [list tsmc13_2d.pdb tsmc13misc_2c.pdb tsmc13io_5a_m7.pdb tsmc13ion_4a_m7.pdb]
#@     } elseif {$technology == {TSMC13_HD}} {
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc13
#@ 
#@         lappend search_path \
#@             $library_root/custom_cells \
#@             $library_root/custom_cells/RAMS/v6/synopsys \
#@             $library_root/custom_cells/RAMS_DSPM/v2/synopsys \
#@             $library_root/custom_cells/RAMS_G13SP/v5/synopsys \
#@             $library_root/custom_cells/XGXS_IP/v17/synopsys \
#@             $library_root/sc_hd/v2/synopsys/v2000/generic \
#@             $library_root/sc_hd/v2/synopsys/v9905/ss \
#@             $library_root/sc_hd/v2/synopsys/v9905/ff \
#@             $library_root/misc/v2/synopsys/v2000/generic \
#@             $library_root/misc/v2/synopsys/v9905/ss \
#@             $library_root/misc/v2/synopsys/v9905/ff \
#@             $library_root/io/v5/synopsys/v2000/generic \
#@             $library_root/io/v5/synopsys/v9905/ss \
#@             $library_root/io/v5/synopsys/v9905/ff \
#@             $library_root/io_35um/v4/synopsys/v2000/generic \
#@             $library_root/io_35um/v4/synopsys/v9905/ss \
#@             $library_root/io_35um/v4/synopsys/v9905/ff
#@ 
#@         set link_libraries [list tsmc13hd_2.db tsmc13misc_2.db tsmc13io_5.db tsmc13ion_4.db tsmc13_wire_load.db]
#@         set target_libraries [list tsmc13hd_2.db]
#@ 
#@         set tech_library {tsmc13hd}
#@         set tech_library_file {tsmc13hd_2.db}
#@         set tech_io_library {tsmc13io}
#@         set tech_io_library_file {tsmc13io_5.db}
#@ 
#@         set link_library [concat {*} $link_libraries]
#@         set target_library $target_libraries
#@         set symbol_library {broadcom.sdb}
#@         set physical_library [list tsmc13hd_2b.pdb tsmc13misc_2c.pdb tsmc13io_5a_m7.pdb tsmc13ion_4a_m7.pdb]
#@     } elseif {$technology == {TSMC13_ALL}} {
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc13
#@ 
#@         lappend search_path \
#@             $library_root/custom_cells \
#@             $library_root/custom_cells/RAMS/v6/synopsys \
#@             $library_root/custom_cells/RAMS_DSPM/v2/synopsys \
#@             $library_root/custom_cells/RAMS_G13SP/v5/synopsys \
#@             $library_root/custom_cells/XGXS_IP/v17/synopsys \
#@             $library_root/sc/v2/synopsys/v2000/generic \
#@             $library_root/sc/v2/synopsys/v9905/ss \
#@             $library_root/sc/v2/synopsys/v9905/ff \
#@             $library_root/sc_hd/v2/synopsys/v2000/generic \
#@             $library_root/sc_hd/v2/synopsys/v9905/ss \
#@             $library_root/sc_hd/v2/synopsys/v9905/ff \
#@             $library_root/misc/v2/synopsys/v2000/generic \
#@             $library_root/misc/v2/synopsys/v9905/ss \
#@             $library_root/misc/v2/synopsys/v9905/ff \
#@             $library_root/io/v5/synopsys/v2000/generic \
#@             $library_root/io/v5/synopsys/v9905/ss \
#@             $library_root/io/v5/synopsys/v9905/ff \
#@             $library_root/io_35um/v4/synopsys/v2000/generic \
#@             $library_root/io_35um/v4/synopsys/v9905/ss \
#@             $library_root/io_35um/v4/synopsys/v9905/ff
#@ 
#@         set link_libraries [list tsmc13_2.db tsmc13hd_2.db tsmc13misc_2.db tsmc13io_5.db tsmc13ion_4.db tsmc13_wire_load.db]
#@         set target_libraries [list tsmc13_2.db tsmc13hd_2.db]
#@ 
#@         set tech_library {tsmc13hd}
#@         set tech_library_file {tsmc13hd_2.db}
#@         set tech_io_library {tsmc13io}
#@         set tech_io_library_file {tsmc13io_5.db}
#@ 
#@         set link_library [concat {*} $link_libraries]
#@         set target_library $target_libraries
#@         set symbol_library {broadcom.sdb}
#@         set physical_library [list tsmc13_2d.pdb tsmc13hd_2b.pdb tsmc13misc_2c.pdb tsmc13io_5a_m7.pdb tsmc13ion_4a_m7.pdb]
#@     } elseif {$technology == {TSMC09}} {
#@         set base_technology TSMC09
#@ 
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc09
#@ 
#@         lappend search_path $library_root $shared_dir/hwcommon/libs/agere/ads/ads411.03/lib/pclib/tsmc_cln90g/galaxy
#@ 
#@         set link_libraries [list tsmc09.ss.db TSMC_CLN90G_WIRE.db]
#@         set target_libraries [list tsmc09.ss.db]
#@ 
#@         set tech_library {tsmc09}
#@         set tech_library_file {tsmc09.ss.db}
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         set link_library [concat {*} $link_libraries]
#@         set target_library $target_libraries
#@ 
#@         #set tech_library_dont_use {HP_* MP_* *BUFAX* *BUFX1 *BUFX16 *BUFX24 *BUSHLDX1 *CK* *DFFMCRX* *DFFMRX* *DFFMSX* *DFFMX* *DFFNM*RX* *DFFNM*SX* *DFFNMX* *INVAX* *INVX0 *X16* *X24* *X30* *X36* *SHDFF* *TRIX* *XOR42X* *XOR62X* *DLY* *X0 *ONA*}
#@         #set tech_library_dont_use {*BUFAX* *BUFX1 *BUFX16 *BUFX24 *BUSHLDX1 *CK* *DFFMCRX* *DFFMRX* *DFFMSX* *DFFMX* *DFFNM*RX* *DFFNM*SX* *DFFNMX* *INVAX* *INVX0 *X16* *X24* *X30* *X36* *SHDFF* *TRIX* *XOR42X* *XOR62X* *DLY* *X0 *ONA*}
#@         #set tech_library_do_use   {LP_SHDFFNX1}
#@         set tech_library_dont_use {LP_* MP_* *_TRIX*}
#@         set tech_library_do_use   {}
#@ 
#@         set tech_clock_gating_latch tsmc09/MP_CKENOAX12
#@         set tech_clock_gating_latch_pattern MP_CKENOAX*
#@     } elseif {[string match TSMC65LP* $technology]} {
#@         set base_technology TSMC65LP
#@         set 16 [expr {"$technology" == "TSMC65LP16"} ? 16 : {"$technology" == "TSMC65LP14"} ? 14 : {""}]
#@         set v  [expr {"$technology" == "TSMC65LP16"} ? 0  : {"$technology" == "TSMC65LP14"} ? 1  : 2]
#@ 
#@         if {! [info exists library_base]} {
#@             set library_base $shared_dir/hwcommon/libs/broadcom/library
#@         }
#@ 
#@         set library_root                $library_base/tsmc65lp/sc/v2_080428/synopsys/v2004/ss
#@         set library_root14              $library_base/tsmc65lp/sc_14/v1_090105_hacked/synopsys/v2004/ss
#@         # sc_16 is obsolete, should actually be removed...
#@         set library_root16              $library_base/tsmc65lp/sc_16/v0/synopsys/v2004/ss
#@         set library_brcm_ios            $library_base/tsmc65lp/io/custom_cells.080922
#@         set library_brcm_ddrios         $library_base/tsmc65lp/ddr_io/iopads_hstl_m5top_metal/custom_cells.rel071119
#@         if {[info exists use_old_hstl_lib] && $use_old_hstl_lib} {
#@             set library_brcm_hstl           $library_base/tsmc65lp/io/BCM65LPF60_HSTL_ALU_152_IO.090107
#@         } else {
#@             set library_brcm_hstl           $library_base/tsmc65lp/io/BCM65LPF60_HSTL_ALU_152_IO.090130
#@         }       
#@         set library_brcm_lcpll          $library_base/PQ_A0/IP/LCPLL65_4CH_BUMP_BYP.rel070511
#@         set library_brcm_pqpll          $library_base/PQ_A0/IP/PLL65_PQchip.A0_patch_7_090209
#@         set library_brcm_pll            $library_base/PQ_A0/IP/PLL_GEN65LP_3CH_BUMP.E0
#@         set library_brcm_serdes         $library_base/PQ_A0/IP/XGXS_Hyperlite.C0_patch4_090212
#@         set library_brcm_mdelay         $library_base/PQ_A0/IP/MIDLMINDLY.rel090213
#@         set library_brcm_delay          $library_base/PQ_A0/IP/MIDL.Q3.rel090213
#@         set library_brcm_lpl_tg2        $library_base/PQ_A0/IP/MIDLLIB.rel090106
#@         set library_brcm_cml2cmos       $library_base/PQ_A0/IP/CLKCH_CML2CMOS.A0_patch5
#@         set library_brcm_cmlbuf         $library_base/PQ_A0/IP/CLKCH_CMLBUF.A0_patch6
#@         set library_brcm_cmlmux         $library_base/PQ_A0/IP/CLKCH_CMLMUX.A0_patch5
#@         set library_brcm_cml2cmosinline $library_base/PQ_A0/IP/CLKCH_CML2CMOS_INLINE.A0_patch1
#@         set library_brcm_cmlbuf_nocap   $library_base/PQ_A0/IP/CLKCH_CMLBUF_NoCAP.A0_patch4
#@         set library_brcm_cmltest        $library_base/PQ_A0/IP/CLKCH_CMLTEST.A0_patch1
#@         set library_t_diode             $library_base/PQ_A0/IP/TEMP_DIODE65LP.A0_patch_2
#@         set library_brcm_ldo25m         $library_base/PQ_A0/IP/LDO25m.A0_patch1
#@         set library_revid               $library_base/tsmc65lp/revid/T65m7lp_3SzB_00000_1
#@         set library_revid_p             $library_base/tsmc65lp/revid/T65m7lp_NpEB_00000_1
#@         set library_misc                $library_base/tsmc65lp/misc/v3_081003
#@         set library_guard               $library_base/PQ_A0/IP/GUARDRINGS
#@ 
#@         if {$chip_name == {np3chip}} {
#@             set library_brcm_delay      $library_base/PQ_A0/IP/MIDL.P3.rel081202
#@             set library_brcm_mdelay     $library_base/PQ_A0/IP/MIDLMINDLY.P3.rel081008
#@         }
#@ 
#@         lappend search_path $library_root \
#@                             $library_root/../ff \
#@                             $library_root/../tt \
#@                             $library_root14 \
#@                             $library_root14/../ff \
#@                             $library_root14/../tt \
#@                             $library_root16 \
#@                             $library_root16/../ff \
#@                             $library_root16/../tt \
#@                             $library_brcm_ios/synopsys \
#@                             $library_brcm_ddrios/synopsys \
#@                             $library_brcm_hstl/synopsys \
#@                             $library_brcm_serdes/synopsys/generic/ss \
#@                             $library_brcm_serdes/synopsys/generic/ff \
#@                             $library_brcm_pll/synopsys/generic/ss \
#@                             $library_brcm_pll/synopsys/generic/ff \
#@                             $library_brcm_lcpll/synopsys/generic/ss \
#@                             $library_brcm_lcpll/synopsys/generic/ff \
#@                             $library_brcm_pqpll/synopsys/generic/ss \
#@                             $library_brcm_pqpll/synopsys/generic/ff \
#@                             $library_brcm_cmlbuf/synopsys/generic/ss \
#@                             $library_brcm_cmlbuf/synopsys/generic/ff \
#@                             $library_brcm_cml2cmos/synopsys/generic/ss \
#@                             $library_brcm_cml2cmos/synopsys/generic/ff \
#@                             $library_brcm_cmlmux/synopsys/generic/ss \
#@                             $library_brcm_cmlmux/synopsys/generic/ff \
#@                             $library_brcm_cml2cmosinline/synopsys/generic/ss \
#@                             $library_brcm_cml2cmosinline/synopsys/generic/ff \
#@                             $library_brcm_cmlbuf_nocap/synopsys/generic/ss \
#@                             $library_brcm_cmlbuf_nocap/synopsys/generic/ff \
#@                             $library_brcm_cmltest/synopsys/generic/ss \
#@                             $library_brcm_cmltest/synopsys/generic/ff \
#@                             $library_brcm_mdelay/synopsys \
#@                             $library_brcm_delay/synopsys \
#@                             $library_brcm_lpl_tg2/synopsys \
#@                             $library_t_diode/synopsys/generic/ss \
#@                             $library_t_diode/synopsys/generic/ff \
#@                             $library_brcm_ldo25m/synopsys/generic/ss \
#@                             $library_brcm_ldo25m/synopsys/generic/ff \
#@                             $library_revid/synopsys/ss \
#@                             $library_revid/synopsys/ff \
#@                             $library_revid_p/synopsys/ss \
#@                             $library_revid_p/synopsys/ff \
#@                             $library_misc/synopsys/v2004/ss \
#@                             $library_misc/synopsys/v2004/ff \
#@                             $library_guard/synopsys \
#@                             $shared_dir/hwcommon/libs/agere/ads/ads411.03/lib/pclib/tsmc_cln90g/galaxy
#@ 
#@         if {[info exists use_old_hstl_lib] && $use_old_hstl_lib} {
#@             set library_brcm_hstl_db SS108125_IO297.db 
#@         } else {
#@             set library_brcm_hstl_db bcm65lpf_hstl_alu_152_v2004.06_ss108125_io297.db
#@         }       
#@ 
#@         set link_libraries [list tsmc65lp${16}_ss108125_$v.db \
#@                                  tsmc65lp_ss108125_2.db \
#@                                  TSMC_CLN90G_WIRE.db \
#@                                  bcm65lpf_v2004.06_ss108125_io297.db \
#@                                  m5_bcm65lpf_v2004.06_ss108125_io297.db \
#@                                  $library_brcm_hstl_db \
#@                                  PLL_GEN65LP_3CH_BUMP_ss.db \
#@                                  LCPLL65_4CH_BUMP_BYP_ss.db \
#@                                  PLL65_PQchip_ss.db \
#@                                  XGXS_Hyperlite_125_ss.db \
#@                                  midl_bisted_wc.db \
#@                                  MIDLMINDLY_wc.db \
#@                                  LPL_TG2_ss108125.db \
#@                                  CLKCH_CML2CMOS_125_ss.db \
#@                                  CLKCH_CMLBUF_125_ss.db \
#@                                  CLKCH_CMLMUX_125_ss.db \
#@                                  CLKCH_CML2CMOS_INLINE_125_ss.db \
#@                                  CLKCH_CMLBUF_NoCAP_125_ss.db \
#@                                  CLKCH_CMLTEST_125_ss.db \
#@                                  tsmc65lpmisc_ss108125_3.db \
#@                                  TEMP_DIODE65LP_ss.db \
#@                                  LDO25m_ss.db \
#@                                  Guardrings_ss.db \
#@                                  T65m7lp_3SzB_00000_1_ss108125.db \
#@                                  T65m7lp_NpEB_00000_1_ss108125.db]
#@                                  
#@         set target_libraries [list tsmc65lp${16}_ss108125_$v.db]
#@ 
#@         set tech_library tsmc65lp${16}_108125
#@         set tech_library_file tsmc65lp${16}_ss108125_$v.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         set link_library [concat {*} $link_libraries]
#@         set target_library $target_libraries
#@ 
#@         # Use only low VT cells for performance
#@         if {$technology == {TSMC65LP16}} {
#@             set tech_library_dont_use {LP16S_*}
#@             set tech_library_x1_drive_cell {LP16L_BUFX1}
#@         } elseif {$technology == {TSMC65LP14}} {
#@             set tech_library_dont_use {LP14H_* LP14S_*}
#@             set tech_library_x1_drive_cell {LP14L_BUFX1}
#@         } else {
#@             set tech_library_dont_use {LPH7_* LPH_* LPS_*}
#@             set tech_library_x1_drive_cell {LPL_BUFX1}
#@         }
#@         set tech_library_load_of_1pf 1
#@ 
#@         # The following cells are deleted in magma, so we don't use them
#@         # Use only low VT cells for performance
#@         if {$technology == {TSMC65LP14}} {
#@             if {[string match */v1/* $library_root14]} {
#@                 lappend tech_library_dont_use *X0 *X24 *X28 *X32 *X36 *_BUSHLDX* *_TRIX*
#@             } else {
#@                 # *_BUSHLDX* *_CDM2NDESD* *_ISOLOW* *_ISOHIGH* are already dont_use'd in the library, *_TRIX* would only be instantiated if the RTL inferred them
#@                 lappend tech_library_dont_use *X0 *X0P4 *X0P8 *X20 *X24 *X28 *X32 *X36 *_DDRFF* *_*DFF*3X* *_*DFFRS* *_DLY* *_SRESYNC*
#@             }
#@         } elseif {$technology == {TSMC65LP16}} {
#@             lappend tech_library_dont_use *X0 *X24 *X28 *X32 *X36 *_BUSHLDX* *_TRIX*
#@         } else {
#@             lappend tech_library_dont_use *X0 *X24 *X28 *X32 *X36 *_PG8X* *_BUSHLDX* *DFFM* *DFFNM* *_TRIX* *_XOR42X* *_XOR62X* *_NOR8X* *_NOR5X* *_SCHMTL* *_BSELX* *_BSELIX* *_AND5X* *_NAND5X* *_SHDFF* *_DDRFFX* *_CDM2NDESD *_IROSCX* *_DLY*
#@         }
#@ 
#@         set tech_clock_gating_latch $tech_library/LP${16}L_CKENOAX12
#@         set tech_clock_gating_latch_pattern LP*L_CKENOAX*
#@ 
#@         # Seem to get LP14H_CKENOAX4 instantiated with this:
#@         #set tech_library_do_use LP14L_CKENOAX*
#@ 
#@         set physical_library tsmc65lp${16}.pdb
#@ 
#@         set mw_reference_library [expr $\library_root$16]/../../../mw/tsmc65lp${16}
#@         set mw_tech_file [expr $\library_root$16]/../../../mw/scripts_mw/datafiles/tsmc65m7rdllp.tf
#@         set mw_max_tluplus [expr $\library_root$16]/../../../../../tluplus/tsmc65m7rdllpt.itf.tlu
#@         set mw_tech2itf_map [file dirname $mw_max_tluplus]/layer.map
#@         if {! $topographical_mode} {
#@             set mpc_dont_cut_pnet_over_macros true
#@         }
#@ 
#@     } elseif {$technology == {TSMC40G}} {
#@ 
#@         if {! [info exists max_corner]} {
#@             set max_corner ss081125
#@         }
#@ 
#@         if {! [info exists max_corner_temp]} {
#@            if {([string match {q3chip*} $chip_name] || $chip_name == {t3chip} || $chip_name == {s3chip})} {
#@                set max_corner_temp {125}
#@            } else {
#@                set max_corner_temp {-40}
#@            }
#@         } 
#@ 
#@         if {! [info exists max_corner_oc]} {
#@            if { [string match {q3chip*} $chip_name] } {
#@                set max_corner_oc wc
#@            } else {
#@                set max_corner_oc wc_cold
#@            }
#@         }
#@         
#@         puts "max_corner = $max_corner"
#@         
#@         if {! [info exists library_synopsys_version]} {
#@             if {[info exists sh_product_version] && [regexp -inline {20\d\d.\d\d} $sh_product_version] >= 2007.12} {
#@                 # brcm used 2008.09 for sc.100601 (and later ?)
#@                 # not bothering to fix the PT = 2007 case
#@                 set library_synopsys_version 2008.09-SP5-1
#@                 if {($chip_name == {np3chip}) || ($chip_name == {t3chip})} {
#@                     set library_synopsys_version 2007.12-SP5
#@                 }
#@             } else {
#@                 set library_synopsys_version 2006.06-SP1
#@             }
#@         }
#@         
#@         if {! [info exists library_root]} {
#@         
#@             # Most recent library
#@             
#@             set library_root $shared_dir/hwcommon/libs/broadcom/tsmc40g/tsmc40g/sc/sc.100726/synopsys/$library_synopsys_version/ss
#@             
#@             # Most recent 2006.06-SP1 library (if different)
#@             
#@             # Chip specific deviations
#@             
#@             if {$chip_name == {t3chip} || $chip_name == {s3chip}} {
#@                 set library_root $shared_dir/hwcommon/libs/broadcom/tsmc40g/tsmc40g/sc/sc.100726/synopsys/$library_synopsys_version/ss
#@             }
#@ 
#@             if {$chip_name == {np3chip} || $chip_name == {np4chip} || $chip_name == {m4chip}} {
#@                 if {[info exists library_base] && [string match /projects/* $library_base]} {
#@                     set library_synopsys_version 2008.09-SP5-1
#@                     set library_root $library_base/tsmc40g/sc/custom_cells.100601/synopsys/$library_synopsys_version/ss
#@                 } else {
#@                     set library_synopsys_version 2006.06-SP1
#@                     set library_root $shared_dir/hwcommon/libs/broadcom/tsmc40g/tsmc40g/sc/sc.100723/synopsys/$library_synopsys_version/ss
#@                 }
#@             }
#@         }
#@         
#@         if {[string match *sc.090209* $library_root]} {
#@             set library_prefix A0_Alcatel_P
#@         } else {
#@             set library_prefix tsmc40g
#@         }
#@ 
#@         if {! [info exists library_base]} {
#@             set library_base $shared_dir/hwcommon/libs/broadcom/tsmc40g
#@         }
#@ 
#@         # These are all the 'latest' IP deliveries (that have been tested)
#@ 
#@         if {! [info exists ip_library_synopsys_version]} {
#@             if {$chip_name == {np3chip} && [info exists sh_product_version] && [regexp -inline {20\d\d.\d\d} $sh_product_version] >= 2007.12} {
#@                 set ip_library_synopsys_version generic
#@             } else {
#@                 set ip_library_synopsys_version 2006.06-SP1
#@             }
#@         }
#@         
#@         set library_brcm_guardring      $library_base/A0_IP/guardring.100317
#@         set library_brcm_ldonldl        $library_base/A0_IP/ANA_LDONLDL40G_M7NP_A0_patch1.100323
#@         set library_brcm_pll            $library_base/A0_IP/ANA_DPLLPHY25_40G_M7FC_C0_p4.100813
#@         set library_brcm_pllnp          $library_base/A0_IP/ANA_DPLLPHY_40G_M6NP_B0_p5.100813
#@ 
#@         set library_brcm_vtmon          $library_base/A0_IP/ANA_VTMON40G_M7FC.A0_patch2_100503_ALU
#@         set library_brcm_io             $library_base/tsmc40g/io/custom_cells.100812
#@         set library_brcm_io_q3b0        $library_base/tsmc40g/io/custom_cells.B0.120320
#@         set library_brcm_revid          $library_base/tsmc40g/revid/revid.090612
#@         set library_brcm_revid_bis      $library_base/tsmc40g/revid/revid.110315
#@ 
#@         set library_brcm_ddr_io_1p2     $library_base/A0_IP/DDR_IO_1P2.100520
#@         set library_brcm_ddr_io_1p5     $library_base/A0_IP/DDR_IO_1P5.100520
#@         set ddr_io_1p2_lib              tsmc40giofd3_SS090${max_corner_temp}_IO297.db
#@         set ddr_io_1p5_lib              tsmc40giofdr_SS090${max_corner_temp}_IO297.db
#@ 
#@         set library_brcm_nldl           $library_base/A0_IP/NLDL.100604
#@         set library_brcm_nldlmindelay   $library_base/A0_IP/NLDLMINDELAY.100604
#@         set nldl_lib                    NLDL_ss.db
#@         set nldlmindelay_lib            NLDLMINDELAY_ss.db
#@ 
#@         set library_brcm_serdes         $library_base/A0_IP/XGXS_WarpCore.101202
#@         set library_brcm_serdes2        $library_brcm_serdes/synopsys_preDFT/2006.06-SP1
#@         set warpcore_h_lib              XGXS_WarpCore_H_si_125_ss.db 
#@         set warpcore_v_lib              XGXS_WarpCore_V_si_125_ss.db
#@ 
#@         set library_brcm_wc_libs        $library_base/A0_IP/WC_LIBS
#@         set library_wcpll               $library_brcm_wc_libs/wc_pll/ANA_WARPCORE40G_M7FC_from_CE.100707
#@         set library_wcmems              $library_brcm_wc_libs/memories/WC_custom_cells.100604
#@         set library_wcrevid             $library_brcm_wc_libs/revid/T40m5_TIEA_00000_1.091231
#@ 
#@  
#@         set library_brcm_tcd            $library_base/tsmc40g/TCD/TCD_100812
#@         set library_brcm_bump           $library_base/tsmc40g/bump/bump_091510
#@ 
#@         if {[info exists postlayout_netlist]} {
#@             if {$postlayout_netlist} {
#@                 set library_brcm_serdes2 $library_brcm_serdes/synopsys/generic
#@             }
#@         } else {
#@             # But normally in fact postlayout_netlist has not been configured by this time.
#@             # This heuristic below is what the Q3 team use to differentiate postlayout analysis directories
#@             # (other hacks are equally welcome here)
#@             if {[regexp {vgp|postlayout} [pwd]]} {
#@                 set library_brcm_serdes2 $library_brcm_serdes/synopsys/generic
#@             }
#@         }
#@ 
#@         # Per-chip deviations from 'latest' IP library deliveries
#@ 
#@         if {$chip_name == {np3chip}} {
#@             #set library_brcm_io             $library_base/tsmc40g/io/custom_cells.100621
#@             set library_brcm_tcd            $library_base/tsmc40g/TCD
#@             set nldl_lib                    NLDL_ss_cold.db
#@             set nldlmindelay_lib            NLDLMINDELAY_ss_cold.db
#@             set library_brcm_ddr_io_1p2     {}
#@             set library_brcm_ddr_io_1p5     {}
#@             set ddr_io_1p2_lib              tsmc40g_iopads_ss090${max_corner_temp}_io297.db
#@             set ddr_io_1p5_lib              tsmc40g_iopads_ss090${max_corner_temp}_io297.db
#@ 
#@             if {[string match /projects/* $library_base]} {
#@                 set library_brcm_guardring      $library_base/tsmc40g/guardring/guardring.100317
#@                 set library_brcm_ldonldl        $library_base/P3_A0/DDR/ANA_LDONLDL40G_M7NP_A0_patch1.100323
#@                 set library_brcm_pll            $library_base/P3_A0/PLL/ANA_DPLLPHY25_40G_M7FC_C0_p4.100813
#@                 set library_brcm_pllnp          $library_base/P3_A0/PLL/ANA_DPLLPHY_40G_M6NP_B0_p5.100813
#@ 
#@                 set library_brcm_vtmon          $library_base/P3_A0/Temperature_Monitor/ANA_VTMON40G_M7FC.A0_patch2_100503_ALU
#@                 set library_brcm_io             $library_base/P3_A0/IO/custom_cells.100812
#@                 set library_brcm_revid          $library_base/tsmc40g/revid/revid.090612
#@                 set library_brcm_revid_bis      $library_base/tsmc40g/revid/revid.110315
#@ 
#@                 set library_brcm_ddr_io_1p2     $library_base/P3_A0/DDR/DDR_IO_1P2.100520
#@                 set library_brcm_ddr_io_1p5     $library_base/P3_A0/DDR/DDR_IO_1P5.100520
#@                 set ddr_io_1p2_lib              tsmc40giofd3_SS090${max_corner_temp}_IO297.db
#@                 set ddr_io_1p5_lib              tsmc40giofdr_SS090${max_corner_temp}_IO297.db
#@ 
#@                 set library_brcm_nldl           $library_base/P3_A0/DDR/NLDL.100604
#@                 set library_brcm_nldlmindelay   $library_base/P3_A0/DDR/NLDLMINDELAY.100604
#@                 set nldl_lib                    NLDL_ss.db
#@                 set nldlmindelay_lib            NLDLMINDELAY_ss.db
#@ 
#@                 set library_brcm_serdes         $library_base/P3_A0/WarpCore/XGXS_WarpCore.100913
#@                 set library_brcm_serdes2        $library_brcm_serdes/synopsys_preDFT/$ip_library_synopsys_version
#@                 set warpcore_h_lib              XGXS_WarpCore_H_si_125_ss.db 
#@                 set warpcore_v_lib              XGXS_WarpCore_V_si_125_ss.db
#@          
#@                 set library_brcm_tcd            $library_base/tsmc40g/TCD/TCD_100812
#@                 set library_brcm_bump           $library_base/tsmc40g/bump/bump_091510
#@             }
#@         }
#@ 
#@         if {$chip_name == {t3chip}} {
#@             set library_brcm_serdes         $library_base/A0_IP/XGXS_WarpCore.101202
#@             if {$run_ctl_vars(netlist_type) == "pred"} {
#@                 set library_brcm_serdes2        $library_brcm_serdes/synopsys_preDFT/2006.06-SP1
#@             } else {
#@                 set library_brcm_serdes2        $library_brcm_serdes/synopsys/generic
#@             }
#@             set ddr_io_1p2_lib              tsmc40g_iopads_ss090${max_corner_temp}_io297.db
#@             set ddr_io_1p5_lib              tsmc40g_iopads_ss090${max_corner_temp}_io297.db
#@         }
#@ 
#@         puts "Info: Searching for Warpcore lib in $library_brcm_serdes2"
#@ 
#@         lappend search_path $library_root                                       \
#@                             $library_root/../ff                                 \
#@                             $library_root/../tt                                 \
#@                             $library_brcm_nldl/synopsys/$ip_library_synopsys_version/ss          \
#@                             $library_brcm_nldl/synopsys/$ip_library_synopsys_version/ff          \
#@                             $library_brcm_nldlmindelay/synopsys/$ip_library_synopsys_version/ss  \
#@                             $library_brcm_nldlmindelay/synopsys/$ip_library_synopsys_version/ff  \
#@                             $library_brcm_ldonldl/synopsys/$ip_library_synopsys_version/ss       \
#@                             $library_brcm_ldonldl/synopsys/$ip_library_synopsys_version/ff       \
#@                             $library_brcm_pll/synopsys/$ip_library_synopsys_version/ss           \
#@                             $library_brcm_pll/synopsys/$ip_library_synopsys_version/ff           \
#@                             $library_brcm_pllnp/synopsys/$ip_library_synopsys_version/ss         \
#@                             $library_brcm_pllnp/synopsys/$ip_library_synopsys_version/ff         \
#@                             $library_brcm_vtmon/synopsys/$ip_library_synopsys_version/ss         \
#@                             $library_brcm_vtmon/synopsys/$ip_library_synopsys_version/ff         \
#@                             $library_brcm_io/synopsys/v2004.06/ss                                \
#@                             $library_brcm_io/synopsys/v2004.06/ff                                \
#@                             $library_brcm_revid/synopsys/$ip_library_synopsys_version/ss         \
#@                             $library_brcm_revid/synopsys/$ip_library_synopsys_version/ff         \
#@                             $library_brcm_revid/synopsys/ss                                      \
#@                             $library_brcm_revid/synopsys/ff                                      \
#@                             $library_brcm_revid_bis/synopsys/$ip_library_synopsys_version/ss     \
#@                             $library_brcm_revid_bis/synopsys/$ip_library_synopsys_version/ff     \
#@                             $library_brcm_revid_bis/synopsys/ss                                  \
#@                             $library_brcm_revid_bis/synopsys/ff                                  \
#@                             $shared_dir/hwcommon/libs/agere/ads/ads411.03/lib/pclib/tsmc_cln90g/galaxy
#@ 
#@         set link_libraries [list ${library_prefix}_sc10t090v_$max_corner.db TSMC_CLN90G_WIRE.db     \
#@                                  $nldl_lib                                                          \
#@                                  $nldlmindelay_lib                                                  \
#@                                  ANA_LDONLDL40G_M7NP_ss.db                                          \
#@                                  ANA_DPLLPHY25_40G_M7FC_ss.db                                       \
#@                                  ANA_DPLLPHY_40G_M6NP_ss.db                                         \
#@                                  ANA_VTMON40G_M7FC_ss.db                                            \
#@                                  T40m6_AP3A_00000_1_ss090${max_corner_temp}.db                      \
#@                                  T40m6_AP3A_20000_0_ss090${max_corner_temp}.db                      \
#@                            ]
#@         
#@         if {[info exists postlayout_netlist]} {
#@             if {$postlayout_netlist} {
#@                 lappend search_path                                                                 \
#@                             $library_brcm_bump/synopsys/generic/ss                                  \
#@                             $library_brcm_bump/synopsys/generic/ff                                  \
#@                             $library_brcm_tcd/synopsys/generic/ss                                   \
#@                             $library_brcm_tcd/synopsys/generic/ff
#@                 lappend link_libraries                                                              \
#@                                  BCM40LPF25_BMP_150_ss090125.db                                     \
#@                                  DummyTCD_9um_ss.db                                                 
#@             }
#@         } else {
#@             # But normally in fact postlayout_netlist has not been configured by this time.
#@             # This heuristic below is what the Q3 team use to differentiate postlayout analysis directories
#@             # (other hacks are equally welcome here)
#@             if {[regexp {vgp|postlayout} [pwd]]} {
#@                 lappend search_path                                                                 \
#@                             $library_brcm_bump/synopsys/generic/ss                                  \
#@                             $library_brcm_bump/synopsys/generic/ff                                  \
#@                             $library_brcm_tcd/synopsys/generic/ss                                   \
#@                             $library_brcm_tcd/synopsys/generic/ff
#@                 lappend link_libraries                                                              \
#@                                  BCM40LPF25_BMP_150_ss090125.db                                     \
#@                                  DummyTCD_9um_ss.db                                                 
#@             }
#@         }
#@ 
#@         if {0 && $chip_name == {np3chip}} {
#@         
#@             if {! [info exists library_base_65lp]} {
#@                 set library_base_65lp $shared_dir/hwcommon/libs/broadcom/library
#@             }
#@             
#@             # Legacy cell support for np3
#@             
#@             set library_brcm_ddr_io         $library_base/tsmc40g/ddr_io/custom_cells.091110
#@             set library_brcm_ldo            $library_base/A0_IP/DDR_LDO.091110
#@             set library_brcm_hstl           $library_base_65lp/tsmc65lp/io/BCM65LPF60_HSTL_ALU_152_IO.090130
#@             set library_brcm_delay_65lp     $library_base_65lp/PQ_A0/IP/MIDL.P3.rel081202
#@             set library_brcm_mdelay_65lp    $library_base_65lp/PQ_A0/IP/MIDLMINDLY.P3.rel081008
#@ 
#@             lappend search_path                                                     \
#@                                 $library_brcm_ddr_io/synopsys/v2004.06/ss           \
#@                                 $library_brcm_ddr_io/synopsys/v2004.06/ff           \
#@                                 $library_brcm_ldo/synopsys/v2006.06/ss              \
#@                                 $library_brcm_ldo/synopsys/v2006.06/ff              \
#@                                 $library_brcm_mdelay_65lp/synopsys                  \
#@                                 $library_brcm_delay_65lp/synopsys                   \
#@                                 $library_brcm_hstl/synopsys
#@ 
#@             lappend link_libraries                                                  \
#@                                  tsmc40g_ddr_iopads_ss090${max_corner_temp}_io297.db \
#@                                  bcm65lpf_hstl_alu_152_v2004.06_ss108125_io297.db   \
#@                                  DDR_LDO_ss.db                                      \
#@                                  midl_bisted_wc.db                                  \
#@                                  MIDLMINDLY_wc.db
#@         }
#@ 
#@         if { $chip_name == {np3chip} } {
#@             set library_brcm_bump $library_base/tsmc40g/bump/bump_112008
#@             lappend search_path                                                     \
#@                                 $library_brcm_ddr_io_1p2/synopsys/$ip_library_synopsys_version/ss    \
#@                                 $library_brcm_ddr_io_1p2/synopsys/$ip_library_synopsys_version/ff    \
#@                                 $library_brcm_ddr_io_1p5/synopsys/$ip_library_synopsys_version/ss    \
#@                                 $library_brcm_ddr_io_1p5/synopsys/$ip_library_synopsys_version/ff    \
#@                                 $library_brcm_bump/synopsys/$ip_library_synopsys_version/ss          \
#@                                 $library_brcm_bump/synopsys/$ip_library_synopsys_version/ff          \
#@                                 $library_brcm_tcd/synopsys/$ip_library_synopsys_version/ss           \
#@                                 $library_brcm_tcd/synopsys/$ip_library_synopsys_version/ff
#@             lappend link_libraries                                                  \
#@                                  $ddr_io_1p2_lib                                    \
#@                                  $ddr_io_1p5_lib                                    \
#@                                  BCM40LPF25_BMP_150_ss090125.db                     \
#@                                  DummyTCD_9um_ss.db                                                 
#@         }
#@         
#@         if { $chip_name == {t3chip} } {
#@             if {$run_ctl_vars(netlist_type) == "postl"} {
#@                 lappend search_path                                                                 \
#@                                 $library_brcm_bump/synopsys/generic/ss                              \
#@                                 $library_brcm_bump/synopsys/generic/ff                              \
#@                                 $library_brcm_tcd/../synopsys/generic/ss                            \
#@                                 $library_brcm_tcd/../synopsys/generic/ff
#@                 lappend link_libraries                                                              \
#@                                  BCM40LPF25_BMP_150_ss090125.db                                     \
#@                                  DummyTCD_9um_ss.db                                                 
#@             }
#@         }
#@ 
#@         if { $chip_name == {q3chip} } {
#@             
#@             # Legacy cell support for q3
#@             
#@             if {[regexp {rel_1\.[0123]} [pwd]]} {
#@                 set library_brcm_ddr_io         $library_base/tsmc40g/ddr_io/custom_cells.091110
#@                 lappend search_path                                                     \
#@                                 $library_brcm_ddr_io/synopsys/v2004.06/ss               \
#@                                 $library_brcm_ddr_io/synopsys/v2004.06/ff           
#@                 lappend link_libraries                                                  \
#@                                  tsmc40g_ddr_iopads_ss090${max_corner_temp}_io297.db
#@             }
#@         }
#@ 
#@         if { $chip_name == {t3chip} } {
#@  
#@             # Legacy cell support for t3
#@  
#@             set library_brcm_ddr_io         $library_base/tsmc40g/ddr_io/custom_cells.091110
#@             lappend search_path                                                     \
#@                             $library_brcm_ddr_io/synopsys/v2004.06/ss               \
#@                             $library_brcm_ddr_io/synopsys/v2004.06/ff           
#@             lappend link_libraries                                                  \
#@                              tsmc40g_ddr_iopads_ss090${max_corner_temp}_io297.db
#@         }
#@ 
#@         if { [common_exists_and_true use_warpcore_ilm] } {
#@ 
#@             lappend search_path  $library_wcpll/synopsys/generic/ss              \
#@                             $library_wcrevid/synopsys/ss                        \
#@                             $library_wcmems/synopsys/v2007.12/ss                 \
#@                             $library_wcpll/synopsys/generic/ff                  \
#@                             $library_wcrevid/synopsys/ff                        \
#@                             $library_wcmems/synopsys/v2007.12/ff                 
#@ 
#@             lappend link_libraries                                               \
#@                                  ANA_WARPCORE40G_M7FC_ss.db                      \
#@                                  WC_allG40RF_tsmc40g_ss090125.db                 \
#@                                  WC_allG40SP_tsmc40g_ss090125.db                 \
#@                                  T40m5_TIEA_00000_1_ss090125.db                  \
#@         } else {
#@             lappend search_path  $library_brcm_serdes2/ss                        \
#@                                  $library_brcm_serdes2/ff                            
#@             lappend link_libraries                                               \
#@                                  $warpcore_h_lib                                 \
#@                                  $warpcore_v_lib                                 
#@         }
#@ 
#@         set target_libraries [list ${library_prefix}_sc10t090v_$max_corner.db]
#@ 
#@         if {! [string match */sc.090209* $library_root] && ! [string match */sc.090424* $library_root] && ! [string match */sc.090612* $library_root]} {
#@             lappend link_libraries ${library_prefix}_misc_$max_corner.db
#@         }
#@         if {   [regexp {custom_cells\.(0909|0912|10)} $library_brcm_io]  } {
#@             lappend link_libraries tsmc40g_iopads_ss090${max_corner_temp}_io297.db
#@         } else {
#@             lappend link_libraries bcm40gfdr_ss090-40_io297.db
#@         }
#@         if { [string match {q3chip*} $chip_name] } {
#@             lappend search_path    $library_brcm_io_q3b0/synopsys/v2006.06/ss \
#@                                    $library_brcm_io_q3b0/synopsys/v2006.06/ff
#@ 
#@             lappend link_libraries tsmc40g_iopads_ss090${max_corner_temp}_io297_S154.db
#@         }
#@ 
#@ 
#@         set tech_library ${library_prefix}_sc10t090v_$max_corner
#@         set tech_library_file ${library_prefix}_sc10t090v_$max_corner.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         set link_library [concat {*} $link_libraries]
#@         set target_library $target_libraries
#@ 
#@         if {! [string match */sc.090209* $library_root]} {
#@             set brcm_use_list [list GH5_AND2X2 GH5_AND2X3 GH5_AND2X4 GH5_AND2X6 GH5_AND2X8 GH5_AND3X2 GH5_AND3X4 GH5_AND3X8 GH5_AO21X2 GH5_AO21X4 GH5_AO21X8 GH5_AOI21MX4 GH5_AOI21MX8 GH5_AOI21X2 GH5_AOI22X2 GH5_AOI22X4 GH5_BUFX10 GH5_BUFX12 GH5_BUFX14 GH5_BUFX16 GH5_BUFX2 GH5_BUFX3 GH5_BUFX4 GH5_BUFX5 GH5_BUFX6 GH5_BUFX7 GH5_BUFX8 GH5_CAX2 GH5_CAX4 GH5_CAX8 GH5_DFFNRSX2 GH5_DFFNRX1 GH5_DFFNRX2 GH5_DFFNSX1 GH5_DFFNSX2 GH5_DFFNX1 GH5_DFFNX2 GH5_DFFRSX2 GH5_DFFRX1 GH5_DFFRX2 GH5_DFFSX1 GH5_DFFSX2 GH5_DFFX1 GH5_DFFX2 GH5_DLATX1 GH5_DLATX2 GH5_FAX2 GH5_FAX4 GH5_FAX6 GH5_HAX2 GH5_HAX4 GH5_HAX8 GH5_INVX10 GH5_INVX12 GH5_INVX14 GH5_INVX16 GH5_INVX2 GH5_INVX3 GH5_INVX4 GH5_INVX5 GH5_INVX6 GH5_INVX7 GH5_INVX8 GH5_MUX2IMX4 GH5_MUX2IMX8 GH5_MUX2IX2 GH5_MUX2X2 GH5_MUX2X4 GH5_MUX2X8 GH5_NAND2IX2 GH5_NAND2MX8 GH5_NAND2X2 GH5_NAND2X3 GH5_NAND2X4 GH5_NAND2X6 GH5_NAND2X8 GH5_NAND3IX2 GH5_NAND3MX8 GH5_NAND3X2 GH5_NAND3X4 GH5_NAND3X8 GH5_NOR2IX2 GH5_NOR2MX8 GH5_NOR2X2 GH5_NOR2X3 GH5_NOR2X4 GH5_NOR2X6 GH5_NOR3IX2 GH5_NOR3MX8 GH5_NOR3X2 GH5_OA21X2 GH5_OA21X4 GH5_OA21X8 GH5_OAI21MX4 GH5_OAI21MX8 GH5_OAI21X2 GH5_OR2X2 GH5_OR2X3 GH5_OR2X4 GH5_OR2X6 GH5_OR2X8 GH5_OR3X2 GH5_OR3X4 GH5_OR3X8 GH5_SDFFNRX1 GH5_SDFFNRX2 GH5_SDFFNSX1 GH5_SDFFNSX2 GH5_SDFFNX1 GH5_SDFFNX2 GH5_SDFFRSX2 GH5_SDFFRX1 GH5_SDFFRX2 GH5_SDFFRX4 GH5_SDFFRX8 GH5_SDFFSX1 GH5_SDFFSX2 GH5_SDFFX1 GH5_SDFFX2 GH5_SDFFX4 GH5_SDFFX8 GH5_XNOR2PTX2 GH5_XNOR2PTX4 GH5_XNOR2X2 GH5_XNOR3X2 GH5_XNOR3X4 GH5_XNOR3X8 GH5_XOR22X2 GH5_XOR2MX2 GH5_XOR2MX4 GH5_XOR2MX8 GH5_XOR2PTX2 GH5_XOR2PTX4 GH5_XOR2X2 GH5_XOR3X2 GH5_XOR3X4 GH5_XOR3X8 \
#@                                      GH_AND2X2  GH_AND2X3  GH_AND2X4  GH_AND2X6  GH_AND2X8  GH_AND3X2  GH_AND3X4  GH_AND3X8  GH_AO21X2  GH_AO21X4  GH_AO21X8  GH_AOI21MX4  GH_AOI21MX8  GH_AOI21X2  GH_AOI22X2  GH_AOI22X4  GH_BUFX10  GH_BUFX12  GH_BUFX14  GH_BUFX16  GH_BUFX2  GH_BUFX3  GH_BUFX4  GH_BUFX5  GH_BUFX6  GH_BUFX7  GH_BUFX8  GH_CAX2  GH_CAX4  GH_CAX8  GH_DFFNRSX2  GH_DFFNRX1  GH_DFFNRX2  GH_DFFNSX1  GH_DFFNSX2  GH_DFFNX1  GH_DFFNX2  GH_DFFRSX2  GH_DFFRX1  GH_DFFRX2  GH_DFFSX1  GH_DFFSX2  GH_DFFX1  GH_DFFX2  GH_DLATX1  GH_DLATX2  GH_FAX2  GH_FAX4  GH_FAX6  GH_HAX2  GH_HAX4  GH_HAX8  GH_INVX10  GH_INVX12  GH_INVX14  GH_INVX16  GH_INVX2  GH_INVX3  GH_INVX4  GH_INVX5  GH_INVX6  GH_INVX7  GH_INVX8  GH_MUX2IMX4  GH_MUX2IMX8  GH_MUX2IX2  GH_MUX2X2  GH_MUX2X4  GH_MUX2X8  GH_NAND2IX2  GH_NAND2MX8  GH_NAND2X2  GH_NAND2X3  GH_NAND2X4  GH_NAND2X6  GH_NAND2X8  GH_NAND3IX2  GH_NAND3MX8  GH_NAND3X2  GH_NAND3X4  GH_NAND3X8  GH_NOR2IX2  GH_NOR2MX8  GH_NOR2X2  GH_NOR2X3  GH_NOR2X4  GH_NOR2X6  GH_NOR3IX2  GH_NOR3MX8  GH_NOR3X2  GH_OA21X2  GH_OA21X4  GH_OA21X8  GH_OAI21MX4  GH_OAI21MX8  GH_OAI21X2  GH_OR2X2  GH_OR2X3  GH_OR2X4  GH_OR2X6  GH_OR2X8  GH_OR3X2  GH_OR3X4  GH_OR3X8  GH_SDFFNRX1  GH_SDFFNRX2  GH_SDFFNSX1  GH_SDFFNSX2  GH_SDFFNX1  GH_SDFFNX2  GH_SDFFRSX2  GH_SDFFRX1  GH_SDFFRX2  GH_SDFFRX4  GH_SDFFRX8  GH_SDFFSX1  GH_SDFFSX2  GH_SDFFX1  GH_SDFFX2  GH_SDFFX4  GH_SDFFX8  GH_XNOR2PTX2  GH_XNOR2PTX4  GH_XNOR2X2  GH_XNOR3X2  GH_XNOR3X4  GH_XNOR3X8  GH_XOR22X2  GH_XOR2MX2  GH_XOR2MX4  GH_XOR2MX8  GH_XOR2PTX2  GH_XOR2PTX4  GH_XOR2X2  GH_XOR3X2  GH_XOR3X4  GH_XOR3X8                             GH_DLY100X3  GH_DLY200X3   GH_ISOHIGH350POX4  GH_ISOHIGH700POX4  GH_ISOLOW350POX4  GH_ISOLOW700POX4 \
#@                                      GS_AND2X2  GS_AND2X3  GS_AND2X4  GS_AND2X6  GS_AND2X8  GS_AND3X2  GS_AND3X4  GS_AND3X8  GS_AO21X2  GS_AO21X4  GS_AO21X8  GS_AOI21MX4  GS_AOI21MX8  GS_AOI21X2  GS_AOI22X2  GS_AOI22X4  GS_BUFX10  GS_BUFX12  GS_BUFX14  GS_BUFX16  GS_BUFX2  GS_BUFX3  GS_BUFX4  GS_BUFX5  GS_BUFX6  GS_BUFX7  GS_BUFX8  GS_CAX2  GS_CAX4  GS_CAX8  GS_DFFNRSX2  GS_DFFNRX1  GS_DFFNRX2  GS_DFFNSX1  GS_DFFNSX2  GS_DFFNX1  GS_DFFNX2  GS_DFFRSX2  GS_DFFRX1  GS_DFFRX2  GS_DFFSX1  GS_DFFSX2  GS_DFFX1  GS_DFFX2  GS_DLATX1  GS_DLATX2  GS_FAX2  GS_FAX4  GS_FAX6  GS_HAX2  GS_HAX4  GS_HAX8  GS_INVX10  GS_INVX12  GS_INVX14  GS_INVX16  GS_INVX2  GS_INVX3  GS_INVX4  GS_INVX5  GS_INVX6  GS_INVX7  GS_INVX8  GS_MUX2IMX4  GS_MUX2IMX8  GS_MUX2IX2  GS_MUX2X2  GS_MUX2X4  GS_MUX2X8  GS_NAND2IX2  GS_NAND2MX8  GS_NAND2X2  GS_NAND2X3  GS_NAND2X4  GS_NAND2X6  GS_NAND2X8  GS_NAND3IX2  GS_NAND3MX8  GS_NAND3X2  GS_NAND3X4  GS_NAND3X8  GS_NOR2IX2  GS_NOR2MX8  GS_NOR2X2  GS_NOR2X3  GS_NOR2X4  GS_NOR2X6  GS_NOR3IX2  GS_NOR3MX8  GS_NOR3X2  GS_OA21X2  GS_OA21X4  GS_OA21X8  GS_OAI21MX4  GS_OAI21MX8  GS_OAI21X2  GS_OR2X2  GS_OR2X3  GS_OR2X4  GS_OR2X6  GS_OR2X8  GS_OR3X2  GS_OR3X4  GS_OR3X8  GS_SDFFNRX1  GS_SDFFNRX2  GS_SDFFNSX1  GS_SDFFNSX2  GS_SDFFNX1  GS_SDFFNX2  GS_SDFFRSX2  GS_SDFFRX1  GS_SDFFRX2  GS_SDFFRX4  GS_SDFFRX8  GS_SDFFSX1  GS_SDFFSX2  GS_SDFFX1  GS_SDFFX2  GS_SDFFX4  GS_SDFFX8  GS_XNOR2PTX2  GS_XNOR2PTX4  GS_XNOR2X2  GS_XNOR3X2  GS_XNOR3X4  GS_XNOR3X8  GS_XOR22X2  GS_XOR2MX2  GS_XOR2MX4  GS_XOR2MX8  GS_XOR2PTX2  GS_XOR2PTX4  GS_XOR2X2  GS_XOR3X2  GS_XOR3X4  GS_XOR3X8  GS_CKENNOOX4  GS_CKENOAX4  GS_DLY100X3  GS_DLY200X3   GS_ISOHIGH350POX4  GS_ISOHIGH700POX4  GS_ISOLOW350POX4  GS_ISOLOW700POX4]
#@ 
#@             set brcm_gs5_use_list [list \
#@                                     GS5_AND2IX1  GS5_AND2IX2  GS5_AND2IX4  GS5_AND2IX8  GS5_AND2X1  GS5_AND2X2  GS5_AND2X3  GS5_AND2X4  GS5_AND2X6  GS5_AND2X8  GS5_AND3X1  GS5_AND3X2  GS5_AND3X4  GS5_AND3X8  GS5_AND4X1  GS5_AND4X2  GS5_AND4X4  GS5_AND4X8  GS5_ANOI22X1  GS5_ANOI22X2  GS5_AO211X1  GS5_AO211X2  GS5_AO211X4  GS5_AO211X8  GS5_AO21X1  GS5_AO21X2  GS5_AO21X4  GS5_AO21X8  GS5_AO22X1  GS5_AO22X2  GS5_AO22X4  GS5_AO22X8  GS5_AO31X1  GS5_AO31X2  GS5_AO31X4  GS5_AO31X8  GS5_AOI211MX4  GS5_AOI211MX8  GS5_AOI211X1  GS5_AOI211X2  GS5_AOI211X4  GS5_AOI211X8  GS5_AOI21MX4  GS5_AOI21MX8  GS5_AOI21X1  GS5_AOI21X2  GS5_AOI21X4  GS5_AOI21X8  GS5_AOI222X1  GS5_AOI222X2  GS5_AOI222X4  GS5_AOI222X8  GS5_AOI22MX4  GS5_AOI22MX8  GS5_AOI22X1  GS5_AOI22X2  GS5_AOI22X4  GS5_AOI22X8  GS5_AOI31MX4  GS5_AOI31MX8  GS5_AOI31X1  GS5_AOI31X2  GS5_AOI31X4  GS5_AOI31X8  GS5_BNAND2X4  GS5_BUFX1  GS5_BUFX10  GS5_BUFX12  GS5_BUFX14  GS5_BUFX16  GS5_BUFX2  GS5_BUFX3  GS5_BUFX4  GS5_BUFX5  GS5_BUFX6  GS5_BUFX7  GS5_BUFX8  GS5_CAX1  GS5_CAX2  GS5_CAX4  GS5_CAX8  GS5_DFFNRSX2  GS5_DFFNRX1  GS5_DFFNRX2  GS5_DFFNSX1  GS5_DFFNSX2  GS5_DFFNX1  GS5_DFFNX2  GS5_DFFRSX2  GS5_DFFRX1  GS5_DFFRX2  GS5_DFFRX4  GS5_DFFRX8  GS5_DFFSX1  GS5_DFFSX2  GS5_DFFX1  GS5_DFFX2  GS5_DFFX4  GS5_DFFX8  GS5_DLATNRX1  GS5_DLATNRX2  GS5_DLATNSX1  GS5_DLATNSX2  GS5_DLATNX1  GS5_DLATNX2  GS5_DLATRX1  GS5_DLATRX2  GS5_DLATSX1  GS5_DLATSX2  GS5_DLATX1  GS5_DLATX2                   GS5_FAX1  GS5_FAX2  GS5_FAX4  GS5_FAX6  GS5_HAX1  GS5_HAX2  GS5_HAX4  GS5_HAX8  GS5_INVX0  GS5_INVX1  GS5_INVX10  GS5_INVX12  GS5_INVX14  GS5_INVX16  GS5_INVX2  GS5_INVX3  GS5_INVX4  GS5_INVX5  GS5_INVX6  GS5_INVX7  GS5_INVX8  GS5_ISOHIGH350POX4  GS5_ISOHIGH700POX4  GS5_ISOLOW350POX4  GS5_ISOLOW700POX4  GS5_MUX2IMX4  GS5_MUX2IMX8  GS5_MUX2IX1  GS5_MUX2IX2  GS5_MUX2IX4  GS5_MUX2IX8  GS5_MUX2X1  GS5_MUX2X2  GS5_MUX2X4  GS5_MUX2X8  GS5_MUX3X1  GS5_MUX3X2  GS5_MUX3X4  GS5_MUX3X8  GS5_MUX4X1  GS5_MUX4X2  GS5_MUX4X4  GS5_MUX4X8  GS5_NAND2IX1  GS5_NAND2IX2  GS5_NAND2IX4  GS5_NAND2MX8  GS5_NAND2X1  GS5_NAND2X2  GS5_NAND2X3  GS5_NAND2X4  GS5_NAND2X6  GS5_NAND2X8  GS5_NAND3IX1  GS5_NAND3IX2  GS5_NAND3IX4  GS5_NAND3MX8  GS5_NAND3X1  GS5_NAND3X2  GS5_NAND3X4  GS5_NAND3X8  GS5_NAND4MX8  GS5_NAND4X1  GS5_NAND4X2  GS5_NAND4X4  GS5_NAND4X8  GS5_NOR2IX1  GS5_NOR2IX2  GS5_NOR2IX4  GS5_NOR2MX8  GS5_NOR2X1  GS5_NOR2X2  GS5_NOR2X3  GS5_NOR2X4  GS5_NOR2X6  GS5_NOR2X8  GS5_NOR3IX1  GS5_NOR3IX2  GS5_NOR3IX4  GS5_NOR3MX8  GS5_NOR3X1  GS5_NOR3X2  GS5_NOR3X4  GS5_NOR3X8  GS5_NOR4MX4  GS5_NOR4MX8  GS5_NOR4X1  GS5_NOR4X2  GS5_NOR4X4  GS5_NOR4X8  GS5_OA211X1  GS5_OA211X2  GS5_OA211X4  GS5_OA211X8  GS5_OA21X1  GS5_OA21X2  GS5_OA21X4  GS5_OA21X8  GS5_OA22X1  GS5_OA22X2  GS5_OA22X4  GS5_OA22X8  GS5_OA31X1  GS5_OA31X2  GS5_OA31X4  GS5_OA31X8  GS5_OAI211MX4  GS5_OAI211MX8  GS5_OAI211X1  GS5_OAI211X2  GS5_OAI211X4  GS5_OAI211X8  GS5_OAI21MX4  GS5_OAI21MX8  GS5_OAI21X1  GS5_OAI21X2  GS5_OAI21X4  GS5_OAI21X8  GS5_OAI22MX4  GS5_OAI22MX8  GS5_OAI22X1  GS5_OAI22X2  GS5_OAI22X4  GS5_OAI22X8  GS5_OAI31MX4  GS5_OAI31MX8  GS5_OAI31X1  GS5_OAI31X2  GS5_OAI31X4  GS5_OAI31X8  GS5_ONAI22X1  GS5_ONAI22X2  GS5_OR2X1  GS5_OR2X2  GS5_OR2X3  GS5_OR2X4  GS5_OR2X6  GS5_OR2X8  GS5_OR3X1  GS5_OR3X2  GS5_OR3X4  GS5_OR3X8  GS5_OR4X1  GS5_OR4X2  GS5_OR4X4  GS5_OR4X8  GS5_SDFFNRSX2  GS5_SDFFNRX1  GS5_SDFFNRX2  GS5_SDFFNSX1  GS5_SDFFNSX2  GS5_SDFFNX1  GS5_SDFFNX2  GS5_SDFFRSX2  GS5_SDFFRX1  GS5_SDFFRX2  GS5_SDFFRX4  GS5_SDFFRX8  GS5_SDFFSX1  GS5_SDFFSX2  GS5_SDFFSX4  GS5_SDFFX1  GS5_SDFFX2  GS5_SDFFX4  GS5_SDFFX8  GS5_SHDFFNRX1  GS5_SHDFFNRX2  GS5_SHDFFNSX1  GS5_SHDFFNSX2  GS5_SHDFFNX1  GS5_SHDFFNX2  GS5_SHDFFRX1  GS5_SHDFFRX2  GS5_SHDFFSX1  GS5_SHDFFSX2  GS5_SHDFFX1  GS5_SHDFFX2          GS5_XNOR2PTX2  GS5_XNOR2PTX4  GS5_XNOR2X1  GS5_XNOR2X2  GS5_XNOR2X4  GS5_XNOR2X8  GS5_XNOR3X1  GS5_XNOR3X2  GS5_XNOR3X4  GS5_XNOR3X8  GS5_XNOR4X1  GS5_XNOR4X2  GS5_XNOR4X4  GS5_XNOR4X8  GS5_XOR22X2  GS5_XOR2MX2  GS5_XOR2MX4  GS5_XOR2MX8  GS5_XOR2PTX2  GS5_XOR2PTX4  GS5_XOR2X1  GS5_XOR2X2  GS5_XOR2X4  GS5_XOR2X8  GS5_XOR3X1  GS5_XOR3X2  GS5_XOR3X4  GS5_XOR3X8  GS5_XOR4X1  GS5_XOR4X2  GS5_XOR4X4  GS5_XOR4X8]
#@ 
#@             set brcm_s3_use_list [concat $brcm_use_list $brcm_gs5_use_list]
#@             if {[string match */brcm40h* [pwd]]} {
#@                 # Use only high VT cells
#@               if { $chip_name == {s3chip} && $run_ctl_vars(use_gs5_gh5) == "1"} {
#@                 echo " IN S3CHIP"
#@                 set tech_library_do_use [lsearch -all -inline -regexp -not $brcm_s3_use_list {^(GH_|GH_DLY|GH_ISO|GS_|GS5_ISO)}]
#@                 set tech_library_x1_drive_cell {GH_SDFFX1}
#@               } else {
#@                 set tech_library_do_use [lsearch -all -inline -regexp -not $brcm_use_list {^(GH5_|GH_DLY|GH_ISO|GS_)}]
#@                 set tech_library_x1_drive_cell {GH_SDFFX1}
#@               }
#@                 if { [info exists synopsys_program_name] && \
#@                      ( $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui} ) && \
#@                      [string match */brcm40*d_* [pwd]] } {
#@                     set tech_library_dont_use {GH5_* GS_* GM?S_* GH_DLY* GH_ISO* GH_A* GH_CA* GH_D* GH_F* GH_H* GH_M* GH_N* GH_O* GH_S* GH_X* *X24}
#@                 } else {
#@                     set tech_library_dont_use {*}
#@                 }
#@             } else {
#@                 # Use only standard VT cells
#@                 set tech_library_do_use [lsearch -all -inline -regexp -not $brcm_use_list {^(GH5_|GH_|GS_CKEN|GS_DLY|GS_ISO)}]
#@                 set tech_library_x1_drive_cell {GS_SDFFX1}
#@                 if { [info exists synopsys_program_name] && \
#@                      ( $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui} ) && \
#@                      [string match */brcm40*d_* [pwd]] } {
#@                     set tech_library_dont_use {GH5_* GH_* GM?H_* GS_CKEN* GS_DLY* GS_ISO* GS_A* GS_CA* GS_D* GS_F* GS_H* GS_M* GS_N* GS_O* GS_S* GS_X* *X24}
#@                     if {1} {
#@                         lappend tech_library_dont_use GS_CK*
#@                     }
#@                 } else {
#@                     set tech_library_dont_use {*}
#@                 }
#@             }
#@         } else {
#@             set brcm_use_list [list AND2X1 AND2X2 AND2X3 AND2X4 AND2X6 AND2X8 AND3X1 AND3X2 AND3X4 AND3X8 \
#@                                     AND4X1 AND4X2 AND4X4 AND4X8 ANOI22X1 ANOI22X2 AO211X1 AO211X2 AO211X4 AO211X8 \
#@                                     AO21X1 AO21X2 AO21X4 AO21X8 AO22X1 AO22X2 AO22X4 AO22X8 AO31X1 AO31X2 AO31X4 AO31X8 \
#@                                     AOI211MX4 AOI211MX8 AOI211X1 AOI211X2 AOI211X4 AOI211X8 AOI21MX4 AOI21MX8 \
#@                                     AOI21X1 AOI21X2 AOI21X4 AOI21X8 AOI22MX4 AOI22MX8 AOI22X1 AOI22X2 AOI22X4 AOI22X8 \
#@                                     AOI31MX4 AOI31MX8 AOI31X1 AOI31X2 AOI31X4 AOI31X8 \
#@                                     BUFX1 BUFX10 BUFX12 BUFX14 BUFX16 BUFX18 BUFX2 BUFX20 BUFX3 BUFX4 BUFX5 BUFX6 BUFX7 BUFX8 \
#@                                     CAX1 CAX2 CAX4 CAX8 DFFNRSX2 DFFNRX1 DFFNRX2 DFFNSX1 DFFNSX2 DFFNX1 DFFNX2 DFFRSX2 DFFRX1 DFFRX2 DFFSX1 DFFSX2 DFFX1 DFFX2 \
#@                                     DLATX1 DLATX2 DLY100X3 DLY200X3 FAX1 FAX2 FAX4 FAX6 HAX1 HAX2 HAX4 HAX8 \
#@                                     INVX1 INVX10 INVX12 INVX14 INVX16 INVX18 INVX2 INVX20 INVX3 INVX4 INVX5 INVX6 INVX7 INVX8 \
#@                                     MUX2IMX4 MUX2IMX8 MUX2IX1 MUX2IX2 MUX2IX4 MUX2IX8 MUX2X1 MUX2X2 MUX2X4 MUX2X8 MUX3X1 MUX3X2 MUX3X4 MUX3X8 MUX4X1 MUX4X2 MUX4X4 MUX4X8 \
#@                                     NAND2IX1 NAND2IX2 NAND2MX8 NAND2X1 NAND2X2 NAND2X3 NAND2X4 NAND2X6 NAND2X8 NAND3IX1 NAND3IX2 NAND3MX8 NAND3X1 NAND3X2 NAND3X4 NAND3X8 NAND4MX8 NAND4X1 NAND4X2 NAND4X4 NAND4X8 \
#@                                     NOR2IX1 NOR2IX2 NOR2MX8 NOR2X1 NOR2X2 NOR2X3 NOR2X4 NOR2X6 NOR2X8 NOR3IX1 NOR3IX2 NOR3MX8 NOR3X1 NOR3X2 NOR3X4 NOR3X8 NOR4MX4 NOR4MX8 NOR4X1 NOR4X2 NOR4X4 NOR4X8 \
#@                                     OA211X1 OA211X2 OA211X4 OA211X8 OA21X1 OA21X2 OA21X4 OA21X8 OA22X1 OA22X2 OA22X4 OA22X8 \
#@                                     OA31X1 OA31X2 OA31X4 OA31X8 OAI211MX4 OAI211MX8 OAI211X1 OAI211X2 OAI211X4 OAI211X8 \
#@                                     OAI21MX4 OAI21MX8 OAI21X1 OAI21X2 OAI21X4 OAI21X8 OAI22MX4 OAI22MX8 OAI22X1 OAI22X2 OAI22X4 OAI22X8 \
#@                                     OAI31MX4 OAI31MX8 OAI31X1 OAI31X2 OAI31X4 OAI31X8 ONAI22X1 ONAI22X2 \
#@                                     OR2X1 OR2X2 OR2X3 OR2X4 OR2X6 OR2X8 OR3X1 OR3X2 OR3X4 OR3X8 OR4X1 OR4X2 OR4X4 OR4X8 \
#@                                     SDFFNRX1 SDFFNRX2 SDFFNSX1 SDFFNSX2 SDFFNX1 SDFFNX2 SDFFR3X1 SDFFR3X2 SDFFR3X4 SDFFR3X8 SDFFRS3X2 SDFFRSX2 SDFFRX1 SDFFRX2 SDFFRX4 SDFFRX8 SDFFS3X2 SDFFSX1 SDFFSX2 SDFFX1 SDFFX2 SDFFX4 SDFFX8 \
#@                                     XNOR2PTX2 XNOR2PTX4 XNOR2X1 XNOR2X2 XNOR2X4 XNOR2X8 XNOR3X1 XNOR3X2 XNOR3X4 XNOR3X8 XNOR4X1 XNOR4X2 XNOR4X4 XNOR4X8 XOR22X2 XOR2MX2 XOR2MX4 XOR2MX8 XOR2PTX2 XOR2PTX4 XOR2X1 XOR2X2 XOR2X4 XOR2X8 XOR3X1 XOR3X2 XOR3X4 XOR3X8 XOR4X1 XOR4X2 XOR4X4 XOR4X8]
#@ 
#@             if {[string match */brcm40_46* [pwd]] || [string match */brcm40h* [pwd]]} {
#@                 # Use only high VT cells
#@                 set tech_library_dont_use {GL_* GS_*}
#@                 set tech_library_x1_drive_cell {GH_BUFX1}
#@                 if {[string match */sc.090209* $library_root]} {
#@                     lappend tech_library_dont_use GM?L_* GM?S_*
#@                     if {[string match */brcm40h92* [pwd]]} {
#@                         set tech_library_do_use [split GH_[join $brcm_use_list { GH_}]]
#@                         set tech_library_do_use [lsearch -all -inline -regexp -not $tech_library_do_use {X(0|24|28|32|36)$}]
#@                         if { [info exists synopsys_program_name] && \
#@                              ( $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui} ) } {
#@                             lappend tech_library_dont_use GH_A* GH_CA* GH_CD* GH_D* GH_F* GH_H* GH_M* GH_N* GH_O* GH_S* GH_T* GH_X*
#@                         } else {
#@                             lappend tech_library_dont_use GH_* GM?H_*
#@                             set tech_library_do_use [lsearch -all -inline -regexp -not $tech_library_do_use {X(18|20)$}]
#@                         }
#@                     }
#@                 }
#@             } else {
#@                 # Use only standard VT cells
#@                 set tech_library_dont_use {GL_* GH_*}
#@                 set tech_library_x1_drive_cell {GS_BUFX1}
#@                 if {[string match */sc.090209* $library_root]} {
#@                     lappend tech_library_dont_use GM?L_* GM?H_*
#@                     if {[string match */brcm4092* [pwd]]} {
#@                         set tech_library_do_use [split GS_[join $brcm_use_list { GS_}]]
#@                         set tech_library_do_use [lsearch -all -inline -regexp -not $tech_library_do_use {X(0|24|28|32|36)$}]
#@                         if { [info exists synopsys_program_name] && \
#@                              ( $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui} ) } {
#@                             lappend tech_library_dont_use GS_A* GS_CA* GS_CD* GS_D* GS_F* GS_H* GS_M* GS_N* GS_O* GS_S* GS_T* GS_X*
#@                         } else {
#@                             lappend tech_library_dont_use GS_* GM?S_*
#@                             set tech_library_do_use [lsearch -all -inline -regexp -not $tech_library_do_use {X(18|20)$}]
#@                         }
#@                     }
#@                 }
#@             }
#@         }
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@ 
#@         set tech_library_load_of_1pf 1
#@ 
#@         # The following cells are deleted in magma, so we don't use them
#@               if {[string match */sc.080908* $library_root]} {
#@             lappend tech_library_dont_use *X0 *X20 *X24 *X28 *X32 *X36 *_*DFF*3X* *_*DFFRS* *_DLY*
#@         } elseif {[string match */sc.081210* $library_root]} {
#@             lappend tech_library_dont_use *X18 *X20 *X24 *X32 *_*DFFRS* *_DLY*
#@         } elseif {[string match */sc.090209* $library_root]} {
#@             lappend tech_library_dont_use *X0 *X18 *X20 *X24 *X28 *X32 *X36 *_*DFF*3X* *_*DFFRS* *_DLY*
#@             if { ( [string match */brcm40h92* [pwd]] || [string match */brcm4092* [pwd]] ) && \
#@                  [info exists synopsys_program_name] && \
#@                  ( $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui} ) } {
#@                 set tech_library_dont_use [lsearch -all -inline -regexp -not $tech_library_dont_use {X(18|20)$}]
#@             }
#@         }
#@ 
#@         if {! [string match */sc.090209* $library_root]} {
#@             set tech_clock_gating_latch $tech_library/GS_CKENOAX12
#@         } else {
#@             set tech_clock_gating_latch $tech_library/${tech_library_cell_prefix}_CKENOAX12
#@         }
#@         set tech_clock_gating_latch_pattern G*_CKENOAX*
#@ 
#@         set physical_library tsmc40g.pdb
#@ 
#@         if {[string match */sc.08* $library_root] || [string match */sc.090209* $library_root]} {
#@             set mw_reference_library $library_root/../../../milkyway
#@         } else {
#@             if {! [info exists mw_reference_library_synopsys_version]} {
#@                 if {[info exists sh_product_version] && [regexp -inline {20\d\d} $sh_product_version] >= 2013} {
#@                     set mw_reference_library_synopsys_version 2013.03-SP1
#@                 } elseif {[info exists sh_product_version] && ((! [info exists synopsys_program_name] || $synopsys_program_name != {milkyway}) && [regexp -inline {20\d\d.\d\d} $sh_product_version] >= 2007.12)} {
#@                     set mw_reference_library_synopsys_version 2007.12-SP3/generic/tsmc40g_sc10t090v
#@                 } else {
#@                     set mw_reference_library_synopsys_version 2006.06-SP1
#@                 }
#@             }
#@             set mw_reference_library $library_root/../../../milkyway/$mw_reference_library_synopsys_version
#@         }
#@         set mw_tech_file $library_root/../../../../../tluplus/tsmc40g_M1_5Mx_1Mz_1RDL.tf
#@         if {$topographical_mode} {
#@             set mw_max_tluplus $library_root/../../../../../tluplus/tsmc40g_M1_5Mx_1Mz_1RDL_worst_RC.tluplus.orig
#@         } else {
#@             set mw_max_tluplus $library_root/../../../../../tluplus/tsmc40g_M1_5Mx_1Mz_1RDL_worst_RC.tluplus
#@         }
#@         set mw_tech2itf_map [file dirname $mw_max_tluplus]/tsmc40g_M1_5Mx_1Mz_1RDL.map
#@ 
#@         if {! $topographical_mode} {
#@             set mpc_dont_cut_pnet_over_macros true
#@         }
#@     } elseif {[string match AV16* $technology]} {
#@         if {$chip_name != {np4chip} && $chip_name != {m4chip} && $chip_name != {q4chip} && ! [info exists use_old_library]} {
#@             set use_old_library 2
#@         } elseif {! [info exists use_old_library] || $use_old_library == 0} {
#@             set use_old_library 10
#@         }
#@         
#@         if {$use_old_library == 10} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/160616
#@             set av16_library_version_number 9
#@         } elseif {$use_old_library == 9} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/160202
#@             set av16_library_version_number 8
#@         } elseif {$use_old_library == 8} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/151217
#@             set av16_library_version_number 7
#@         } elseif {$use_old_library == 7} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/150925
#@             set av16_library_version_number 6
#@         } elseif {$use_old_library == 6} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/150701
#@             set av16_library_version_number 5
#@         } elseif {$use_old_library == 5} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/150217
#@             set av16_library_version_number 4
#@         } elseif {$use_old_library == 4} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/141210
#@             set av16_library_version_number 3
#@         } elseif {$use_old_library == 3} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/140728
#@             set av16_library_version_number 2
#@         } elseif {$use_old_library == 2} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/140416
#@             set av16_library_version_number 1
#@         } elseif {$use_old_library == 1} {
#@             set library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/std_cell_libs/131009
#@             set av16_library_version_number 0
#@         } else {
#@             echo Err\or: use_old_library is $use_old_library
#@         }
#@ 
#@         lappend search_path [list $library_root/timing_power_analysis]
#@ 
#@         if {[info exists use_svt_target_lib]} {
#@             set vt svt
#@             set ckvt lvt
#@         } elseif {[info exists use_ulvt_target_lib]} {
#@             set vt ulvt
#@             set ckvt ulvt
#@         } else {
#@             set vt lvt
#@             set ckvt lvt
#@         }
#@ 
#@         if {$av16_library_version_number >= 3} {
#@             if {$technology == {AV16}} {
#@                 set slow ss
#@                 set od slow_0
#@                 set od2 _slow_0
#@                 set od3 {}
#@             } elseif {$technology == {AV16OD}} {
#@                 set slow ss
#@                 set od slowhod_0
#@                 set od2 _slowhod_0
#@                 set od3 {}
#@             } elseif {$technology == {AV16QOD}} {
#@                 set slow ss
#@                 set od slowqod_0
#@                 set od2 _slowqod_0
#@                 set od3 {}
#@             }
#@         } elseif {$av16_library_version_number == 2} {
#@             if {$technology == {AV16}} {
#@                 set slow ss
#@                 set od slow_0
#@                 set od2 _slow_0
#@                 set od3 {}
#@             } elseif {$technology == {AV16OD}} {
#@                 set slow ss
#@                 set od slowhod_0
#@                 set od2 _slowhod_0
#@                 set od3 {}
#@             } elseif {$technology == {AV16QOD}} {
#@                 set slow ss
#@                 set od slowsvs_0
#@                 set od2 _slowsvs_0
#@                 set od3 {}
#@             }
#@         } elseif {$av16_library_version_number == 1} {
#@             if {$technology == {AV16}} {
#@                 set slow ss
#@                 set od slow_0
#@                 set od2 _slow_0
#@                 set od3 {}
#@             } elseif {$technology == {AV16OD}} {
#@                 set slow ss
#@                 set od slowod_0
#@                 set od2 _slowod_0
#@                 set od3 _od
#@             }
#@         } else {
#@             if {$technology == {AV16}} {
#@                 set slow slow
#@                 set od native
#@                 set od2 {}
#@                 set od3 {}
#@             } elseif {$technology == {AV16OD}} {
#@                 set slow slow
#@                 set od slowod_0
#@                 set od2 _slowod_0
#@                 set od3 _od
#@             }
#@         }
#@         set od4 slow_0
#@         set od5 slow_0_15v
#@         
#@         set libraries [list av16_lvt16_${slow}_$od av16_ck_lvt16_${slow}_$od   \
#@                             av16_svt16_${slow}_$od av16_ck_svt16_${slow}_$od   \
#@                             av16_ulvt16_${slow}_$od av16_ck_ulvt16_${slow}_$od \
#@                             av16_ulvt20_${slow}_$od ]
#@         
#@         set target_libraries [list av16_${vt}16_${slow}_$od av16_ck_${ckvt}16_${slow}_$od]
#@         
#@         # now incorporate ip libs - as per common/vendors/avago/av16_pqst4/av16_pqst4.mak
#@         
#@         set design_support_root        $shared_dir/hwcommon/libs/avago/tsmc16ff/design_support/160426
#@         set pll_dll_library_root       $shared_dir/hwcommon/libs/avago/tsmc16ff/pll_dll/160616
#@         set serdes_library_root        $shared_dir/hwcommon/libs/avago/tsmc16ff/serdes/160721
#@         set cm4_06_serdes_library_root $shared_dir/hwcommon/libs/avago/tsmc16ff/serdes/160824
#@         set p1_serdes_library_root     $shared_dir/hwcommon/libs/avago/tsmc16ff/serdes/160403
#@         set pads_library_root          $shared_dir/hwcommon/libs/avago/tsmc16ff/pads/160721
#@         set internal_ip_library_root   $shared_dir/hwcommon/libs/avago/tsmc16ff/internal_ip/151217
#@ 
#@         set sd16C_extension ports_only
#@         if { [string match *150701 $serdes_library_root] || [string match *150925 $serdes_library_root] } {
#@             set sd16C_extension ss_slow_0
#@         } elseif { [string match */16* $serdes_library_root] } {
#@             set sd16C_extension ${slow}_$od
#@         }
#@         set sd16Q_extension .ss.c_wc
#@         if { [string match *151217 $p1_serdes_library_root] || [string match */16* $serdes_library_root] } {
#@             set sd16Q_extension _${slow}_$od
#@         }
#@ 
#@         set misc_avago_ip_roots [list $design_support_root/db        \
#@                                       $pll_dll_library_root/db       \
#@                                       $serdes_library_root/db        \
#@                                       $cm4_06_serdes_library_root/db \
#@                                       $p1_serdes_library_root/db     \
#@                                       $pads_library_root/db          \
#@                                       $internal_ip_library_root/db ]
#@ 
#@         set search_path [concat $search_path $misc_avago_ip_roots]
#@         
#@         ## SPONG *** NEED FURTHER WORK ON THESE LIB NAMES FOR 141010 ***
#@         ## 141010 LV/HSTL pads have added _15v to their name
#@         ## also od version of efuse and pmro reads _ss_slowhod_0 - so not compatible with 140728 standard cell
#@ 
#@         # Ideally set sd16sbus_master_02_rom_01_${slow}_$od
#@         # BUT in 150217 only options are:
#@         # ss slowqod_0
#@         # ff fast_0
#@         #    fastqod_0
#@         # AND we operate with ss slow_0 - No db available
#@         #
#@         # NOTE - These library files are available in the latest release (150511)
#@         set misc_avago_ip_libraries [list phy16_HBMtop_0_${slow}_${od4}_12v_rc_wc     \
#@                                           cpll16FFP_v10P0_p03_${slow}_$od4            \
#@                                           cpll16FFP_v10P0_p04_${slow}_$od4            \
#@                                           sd16C_txcpam4_rxcm4_ns_04_${sd16C_extension} \
#@                                           sd16C_txcpam4_rxcm4_ns_06_${sd16C_extension} \
#@                                           sd16Q_p1_ew_03${sd16Q_extension}            \
#@                                           sd16sbus_master_03_${slow}_$od              \
#@                                           rom16_24kx48_03_${slow}_$od                 \
#@                                           ip16_SENS_thermvolt25_0_${slow}_$od4        \
#@                                           ip16_SENS_remote_diode_0_port_only          \
#@                                           pad16_HCSLdin_acclk18_0_${slow}_$od5        \
#@                                           pad16_HSTLdio_tran15_0_${slow}_$od5         \
#@                                           pad16_HSTLpvt_drv15_0_${slow}_$od5          \
#@                                           pad16_HSTLpvt_term15_0_${slow}_$od5         \
#@                                           pad16_HSTLsdio_tran15_0_${slow}_$od5        \
#@                                           pad16_HSTLsio_tran15_0_${slow}_$od5         \
#@                                           pad16_LVCMOSsin_rst18_0_${slow}_$od5        \
#@                                           pad16_LVCMOSsio_tap18_0_${slow}_$od5        \
#@                                           pad16_LVCMOSsio_tran18_0_${slow}_$od5       \
#@                                           pad16_LVCMOSsio_tran25_0_${slow}_${od4}_25v \
#@                                           pad16_OBSdot_clkobs_0_${slow}_$od4          \
#@                                           ds16_efuse_03_${slow}_$od4                  \
#@                                           ds16_pmro_03_${slow}_$od4                   \
#@                                           ds16_coreflopsx8d8_01_${slow}_$od4          \
#@                                           ds16_coreflopsx8d48_01_${slow}_$od4         \
#@                                           ds16_clock_control1_03_${slow}_$od4         \
#@                                           ds16_toprevbit0_01_${slow}_$od4             \
#@                                           ds16_toprevbit1_01_${slow}_$od4             \
#@                                           ds16_memmaster_03_${slow}_$od4              \
#@                                           AVAGO_TAP_a16_04_ROUTE_ONLY_NOT_FOR_STA     \
#@                                           aldl_structural_${slow}_$od4                \
#@                                      ]
#@ 
#@         set libraries [concat $libraries $misc_avago_ip_libraries]
#@ 
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@ 
#@         set tech_library av16_${vt}16_ss$od2
#@         set tech_library_file av16_${vt}16_${slow}_$od.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         if {$av16_library_version_number == 0 || $av16_library_version_number == 1} {
#@             set tech_library_dont_use [split [read -nonewline [open $library_root/db/av16_${vt}16_dont_use_list r]] \n]
#@         } else {
#@             set tech_library_dont_use [list]
#@         }
#@         if {[info exists use_scan_flops]} {
#@             lappend tech_library_dont_use UUa16${vt}16_apcdff* UUa16${vt}16_dff* UUa16${vt}16_rstdff* UUa16${vt}16_syncdff*
#@             lappend tech_library_do_use a16${vt}16_apcdff* a16${vt}16_dff0_* a16${vt}16_dff0m_* a16${vt}16_dff0qn_* a16${vt}16_dff1_* a16${vt}16_rstdff*
#@             lappend tech_library_really_dont_use a16${vt}16_dff*a0p* a16${vt}16_rstdff*a0p*
#@             if {$av16_library_version_number != 0 && $av16_library_version_number != 1} {
#@                 lappend tech_library_dont_use UUa16${vt}16_lpwdff* UUa16${vt}16_lpwrstdff*
#@                 lappend tech_library_do_use a16${vt}16_lpwdff* a16${vt}16_lpwrstdff*
#@                 if {$av16_library_version_number != 2} {
#@                     lappend tech_library_dont_use UUa16${vt}16_hddff* UUa16${vt}16_lpwhddff* UUa16${vt}16_lpwrsthddff* UUa16${vt}16_rsthddff*
#@                     lappend tech_library_do_use a16${vt}16_hddff* a16${vt}16_lpwhddff* a16${vt}16_lpwrsthddff* a16${vt}16_rsthddff*
#@                 }
#@                 if {$av16_library_version_number >= 5} {
#@                     lappend tech_library_dont_use UUa16${vt}16_acdff* UUa16${vt}16_apdff* UUa16${vt}16_lpwrstshddff* UUa16${vt}16_rstshddff* a16${vt}16_tiedff*
#@                     lappend tech_library_do_use a16${vt}16_acdff* a16${vt}16_apdff* a16${vt}16_lpwrstshddff* a16${vt}16_rstshddff*
#@                 }
#@                 if {$av16_library_version_number >= 7} {
#@                     lappend tech_library_dont_use UUa16${vt}16_lpwacdff* UUa16${vt}16_lpwapcdff* UUa16${vt}16_lpwapdff*
#@                     lappend tech_library_do_use a16${vt}16_lpwacdff* a16${vt}16_lpwapcdff* a16${vt}16_lpwapdff*
#@                 }
#@             }
#@         } else {
#@             set tech_library_do_use [list UUa16${vt}16_apcdff*]
#@             if {$av16_library_version_number >= 5} {
#@                 lappend tech_library_do_use UUa16${vt}16_acdff* UUa16${vt}16_apdff*
#@             }
#@         }
#@ 
#@         set tech_library_tieoff_cells [list a16${vt}16_tie0_a1 a16${vt}16_tie1_a1]
#@         set tech_library_x1_drive_cell a16${vt}16_buf_a1
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@         set tech_library_load_of_1pf 1
#@ 
#@         set tech_clock_gating_latch av16_ck_${ckvt}16_ss$od2/a16${ckvt}16_ckg_a4
#@         set tech_clock_gating_latch_pattern a16*vt16_ck*g_a*
#@ 
#@         if {$av16_library_version_number == 1} {
#@             set physical physical2
#@         } elseif {$av16_library_version_number == 5} {
#@             set physical physical.150708
#@         } else {
#@             set physical physical
#@         }
#@         set mw_reference_library [list $library_root/$physical/av16_${vt}16$od3.mdb \
#@                                        $library_root/$physical/av16_ck_${ckvt}16$od3.mdb \
#@                                        $library_root/$physical/av16_ulvt16$od3.mdb \
#@                                        $library_root/$physical/av16_ck_ulvt16$od3.mdb \
#@                                        $library_root/$physical/av16_ulvt20$od3.mdb]
#@         if {! [info exists use_svt_target_lib]} {
#@             lappend mw_reference_library $library_root/$physical/av16_svt16$od3.mdb
#@             lappend mw_reference_library $library_root/$physical/av16_ck_svt16$od3.mdb
#@         }
#@         if {$av16_library_version_number == 4 || $av16_library_version_number == 5 || $av16_library_version_number == 6} {
#@             set mw_tech_file $library_root/../../tech/141210/12M_1x2xa2xy2y2yy1z1r_R.tf
#@         } else {
#@             set mw_tech_file $library_root/../../tech/[file tail $library_root]/12M_1x2xa2xy2y2yy1z1r_R.tf
#@         }
#@         set mw_max_tluplus  [file dirname $mw_tech_file]/12M_1x2xa2xy2y2yy1z1r_R0818FF_rc_worst.tlup
#@         if {$av16_library_version_number == 2} {
#@             set mw_tech2itf_map [file dirname $mw_tech_file]/../140416/12M_1x2xa2xy2y2yy1z1r_R0818FF_plib_2_itf.map
#@         } else {
#@             set mw_tech2itf_map [file dirname $mw_tech_file]/12M_1x2xa2xy2y2yy1z1r_R0818FF_plib_2_itf.map
#@         }
#@ 
#@         # Warning: Layer 'via4' attribute 'enclosureTbl' has a value of 0.018. (TFCHK-064)
#@         suppress_message TFCHK-064
#@         # Warning: Valid ContactCode not found for enclosureTbl = (Vs,0.018,0.018,0.005,0.040,...) on Layer 'via4'. (TFCHK-106w)
#@         suppress_message TFCHK-106w
#@ 
#@         proc use_avago_top_cells {} {
#@             global tech_library
#@             global vt
#@             global tech_library_tieoff_cells
#@ 
#@             set_dont_use [get_lib_cells $tech_library/*]
#@ 
#@             set top_cells [list a16${vt}16_topand2_b4   \
#@                                 a16${vt}16_topdff0m2_b8 \
#@                                 a16${vt}16_topinv_a4    \
#@                                 a16${vt}16_topmux2_a4   \
#@                                 a16${vt}16_topmux4_a4   \
#@                                 a16${vt}16_topmuxi2_a4  \
#@                                 a16${vt}16_topmuxi4_a4  \
#@                                 a16${vt}16_topor2_a4    \
#@                                 a16${vt}16_toprptrm2_a4 \
#@                                 a16${vt}16_toptie0_a8   \
#@                                 a16${vt}16_toptie1_a8   \
#@                                 a16${vt}16_topxor2_a4   \
#@                                 a16${vt}16_topxor3_a4   \
#@                                 a16${vt}16_topxor4_a4   \
#@                                 a16${vt}16_topxnor2_a4  \
#@                                 a16${vt}16_topxnor3_a4  \
#@                                 a16${vt}16_topxnor4_a4]
#@ 
#@             foreach cell $top_cells {
#@                 remove_attribute [get_lib_cells $tech_library/$cell] dont_use
#@             }
#@ 
#@             set tech_library_tieoff_cells [list a16${vt}16_toptie0_a8 a16${vt}16_toptie1_a8]
#@         }
#@ 
#@         global clock_gate_cells
#@         #                            ref name           clock pin name
#@         array set clock_gate_cells " a16${vt}16_ckg     CK
#@                                      a16${vt}16_ckgtst  CK
#@                                    "
#@     } elseif {[string match TSMC7FF* $technology]} {
#@ 
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc7ff
#@ 
#@         if {1} {
#@             set DESIGN_SUPPORT_VERSION 210406
#@             set IO_VERSION             210406
#@             set PLL_VERSION            210406
#@             set SERDES_VERSION         210406
#@             set STD_CELL_LIBS_VERSION  210406
#@             set TECH_VERSION           191203
#@             set CUSTOM_VERSION         200316
#@         } elseif {1} {
#@             set DESIGN_SUPPORT_VERSION 200316
#@             set IO_VERSION             200914
#@             set PLL_VERSION            200316
#@             set SERDES_VERSION         200914
#@             set STD_CELL_LIBS_VERSION  200316
#@             set TECH_VERSION           191203
#@             set CUSTOM_VERSION         200316
#@         } elseif {1} {
#@             set DESIGN_SUPPORT_VERSION 200316
#@             set IO_VERSION             200421
#@             set PLL_VERSION            200316
#@             set SERDES_VERSION         200316
#@             set STD_CELL_LIBS_VERSION  200316
#@             set TECH_VERSION           191203
#@             set CUSTOM_VERSION         200316
#@         } elseif {1} {
#@             set DESIGN_SUPPORT_VERSION 190925
#@             set IO_VERSION             190925
#@             set PLL_VERSION            190925
#@             set SERDES_VERSION         190925
#@             set STD_CELL_LIBS_VERSION  190925
#@             set TECH_VERSION           190925
#@             set CUSTOM_VERSION         190925
#@         } else {
#@             set DESIGN_SUPPORT_VERSION 190402
#@             set IO_VERSION             190402
#@             set PLL_VERSION            190402
#@             set SERDES_VERSION         190412
#@             set STD_CELL_LIBS_VERSION  190402
#@             set TECH_VERSION           190402
#@             set CUSTOM_VERSION         190402
#@         }
#@ 
#@         if {$STD_CELL_LIBS_VERSION > 171220} {
#@             set s 250
#@             set p p
#@             set prefix P
#@         } else {
#@             set s 300
#@             set p {}
#@             set prefix F
#@         }
#@         if {$technology == {TSMC7FFQOD}} {
#@             set v 0720
#@         } else {
#@             set v 0670
#@         }
#@         if {[info exists use_svt_target_lib]} {
#@             set vt S
#@         } elseif {[info exists use_ulvt_target_lib]} {
#@             set vt U
#@         } else {
#@             set vt L
#@         }
#@         if {$IO_VERSION >= 190402} {
#@             set hstl_suffix noupf_nopwrpins
#@         } else {
#@             set hstl_suffix without_power
#@         }
#@         if {$IO_VERSION >= 190925} {
#@             set x o1620_xcwccwt
#@             set y o1350_xcwccwt
#@             set s2 250
#@             set z 03
#@             set hcsl_suffix noupf_nopwrpins
#@         } else {
#@             set x xcwccwt_o1620
#@             set y xcwccwt_15v
#@             set s2 300
#@             set z 02
#@             set hcsl_suffix without_power
#@         }
#@ 
#@         set misc_avago_ip_roots [list $library_root/DESIGN_SUPPORT/$DESIGN_SUPPORT_VERSION/db \
#@                                       $library_root/IO/$IO_VERSION/db                         \
#@                                       $library_root/PLL/$PLL_VERSION/db                       \
#@                                       $library_root/SERDES/$SERDES_VERSION/db                 \
#@                                       $library_root/CUSTOM/$CUSTOM_VERSION/db                 \
#@                                 ]
#@ 
#@         set search_path [concat $search_path $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/db $misc_avago_ip_roots]
#@ 
#@         set library    tsmc7ff${p}_sc06t0750v_pssg_s${s}_v${v}_t000_xcwccwt
#@         set ck_library tsmc7ff${p}_ck06t0750v_pssg_s${s}_v${v}_t000_xcwccwt
#@ 
#@         set misc_avago_ip_libraries [list ds07p_clock_control1_01_pssg_s250_v${v}_t000_xcwccw                                    \
#@                                           ds07p_efuse_wrapper_03_pssg_s250_v${v}_t000_xcwccw                                     \
#@                                           ds07p_memmaster_02_pssg_s250_v${v}_t000_xcwccw                                         \
#@                                           ds07p_pmro_01_pssg_s250_v${v}_t000_xcwccw                                              \
#@                                           ds07p_serdes_pmro_01_pssg_s250_v${v}_t000_xcwccw                                       \
#@                                           ds07p_sbus2apb_03_pssg_s250_v${v}_t000_xcwccw                                          \
#@                                           ds07p_ANA_RESCAL_TS7FFP_15M_01_pssg_s250_v${v}_t000_xcwccw                             \
#@                                           ds07p_ANA_RESCAL_TS7FFP_mb_15M_01_pssg_s250_v${v}_t000_xcwccw                          \
#@                                           ds07p_tap_controller_04_TIMING_FOR_ROUTE_ONLY                                          \
#@                                           T7m11_06tE_00000000_1_pssg_s250_v${v}_t000_xcwccwt                                     \
#@                                           BCM7FFPX22D18APD_B08AH_AIO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_B08AH_AVDD_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_B08GH_AVSS_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_BX18H_AVDD_ISO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins              \
#@                                           BCM7FFPX22D18APD_BXXH_BBDIODE2_AVDD_VDDC_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins     \
#@                                           BCM7FFPX22D18APD_BXXH_BBDIODE_AVSS_VSSC_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins      \
#@                                           BCM7FFPX22D18APD_BXXH_END_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                    \
#@                                           BCM7FFPX22D18APD_E1825H_ODTRAN_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_E1825H_RST_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_E1825H_TAP_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_E1825H_TRAN_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                 \
#@                                           BCM7FFPX22D18APD_E1825V_ODTRAN_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_E1825V_RST_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_E1825V_TAP_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_E1825V_TRAN_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                 \
#@                                           BCM7FFPX22D18APD_E18XH_POR_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_E18XH_VBIAS_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                 \
#@                                           BCM7FFPX22D18APD_E18XV_POR_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_E18XV_VBIAS_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                 \
#@                                           BCM7FFPX22D18APD_ECXH_ALL_1UM_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                \
#@                                           BCM7FFPX22D18APD_ECXH_VSSC_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_ECXV_ALL_1UM_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                \
#@                                           BCM7FFPX22D18APD_ECXV_VSSC_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EE25H_VESD_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_EE25V_VESD_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                  \
#@                                           BCM7FFPX22D18APD_EECH_VDDC_ISO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_EECH_VDDC_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EECV_VDDC_ISO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_EECV_VDDC_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EPNH_VDDO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EPNH_VDDO_VSSO_DECAP_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins        \
#@                                           BCM7FFPX22D18APD_EPNH_VSSO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EPNV_VDDO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EPNV_VDDO_VSSO_DECAP_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins        \
#@                                           BCM7FFPX22D18APD_EPNV_VSSO_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EXXH_DDRV_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EXXH_END_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                    \
#@                                           BCM7FFPX22D18APD_EXXV_DDRV_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                   \
#@                                           BCM7FFPX22D18APD_EXXV_END_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins                    \
#@                                           BCM7FFPX22D18APD_X08AH_ESD_INT_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_X08AV_ESD_INT_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_X18AH_ESD_INT_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_X18AV_ESD_INT_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins               \
#@                                           BCM7FFPX22D18APD_XXXO_MIMCAP1X1_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins              \
#@                                           BCM7FFPX22D18APD_XXXO_MIMCAP4X4_pssg_s300_v${v}_t000_${x}_noupf_nopwrpins              \
#@                                           BCM7FFPXHCSL_D08NH_CLKOBS_pssg_s300_v${v}_t000_${x}_$hcsl_suffix                       \
#@                                           BCM7FFPXHCSL_D18NH_ACCKIN_pssg_s300_v${v}_t000_${x}_$hcsl_suffix                       \
#@                                           BCM7FFPXHSTL_P15EH_CLAMP_ONLY_pssg_s300_v${v}_t000_${y}_$hstl_suffix                   \
#@                                           BCM7FFPXHSTL_P15EH_VDDO_VSSC_pssg_s300_v${v}_t000_${y}_$hstl_suffix                    \
#@                                           BCM7FFPXHSTL_PMNH_PVT15_DRV_pssg_s300_v${v}_t000_${y}_$hstl_suffix                     \
#@                                           BCM7FFPXHSTL_PMNH_PVT15_TERM_pssg_s300_v${v}_t000_${y}_$hstl_suffix                    \
#@                                           BCM7FFPXHSTL_PMNH_TRAN15_CAP2X_pssg_s300_v${v}_t000_${y}_$hstl_suffix                  \
#@                                           BCM7FFPXHSTL_PMNH_TRAN15_DIFG_pssg_s300_v${v}_t000_${y}_$hstl_suffix                   \
#@                                           BCM7FFPXHSTL_PMNH_TRAN15_DSIG_pssg_s300_v${v}_t000_${y}_$hstl_suffix                   \
#@                                           BCM7FFPXHSTL_PMNH_TRAN15_SING_pssg_s300_v${v}_t000_${y}_$hstl_suffix                   \
#@                                           LIB_VTMON_REMOTE_SENSOR_TS7FFP_S0_pssg_s${s2}_v0670_t000_o1800_xcwccwt_noupf_nopwrpins \
#@                                           LIB_VTMON_TS7FFP_ALL_NP_X_E_pssg_s${s2}_v0670_t000_o1800_xcwccwt_noupf_nopwrpins       \
#@                                           phy07p_HBM2e_top_0_pssg_s250_v0670_t000_xcwccwt_o1140                                  \
#@                                           cpll07p_ANA_PLL3_REF_NOBUMP_1P8V_TS7FFP_S1_01_pssg_s250_v0670_t000_xcwccw              \
#@                                           cpll07p_ANA_PLL4_DLL_NOBUMP_1P8V_TS7FFP_S1_01_pssg_s250_v0670_t000_xcwccw              \
#@                                           sd07C_cpam4os_oct_pll1x_ub_ns_${z}_pssg_s250_v0670_t000_xcwccw                         \
#@                                           sd07C_cpam4os_quad_pll1x_ub_ns_01_pssg_s250_v0670_t000_xcwccw                          \
#@                                           sd07sbus_master_05_pssg_s250_v0670_t000_xrcwccwt                                       \
#@                                           aldl_structural_pssg_s250_v0670_t000_xcwccwt                                           \
#@                                           tsmc7ffp_top06t0750v_pssg_s250_v0670_t000_xcwccwt                                      \
#@                                     ]
#@ 
#@         if {[info exists use_tsmc7ff_ga_library] && [is_true $use_tsmc7ff_ga_library]} {
#@             lappend misc_avago_ip_libraries tsmc7ff${p}_ga06t0750v_pssg_s${s}_v${v}_t000_xcwccwt
#@         }
#@ 
#@         if {$SERDES_VERSION >= 200914} {
#@             lappend misc_avago_ip_libraries sd07C_cpam4os_oct_pll2x_mb_ns_011_pssg_s250_v0670_t000_xcwccw   \
#@                                             sd07C_cpam4os_quad_pll1x_mb_ns_011_pssg_s250_v0670_t000_xcwccw
#@         }
#@ 
#@         if {$SERDES_VERSION >= 210406} {
#@             lappend misc_avago_ip_libraries sd07C_cpam4os_oct_pll2x_mb_ns_012_pssg_s250_v0670_t000_xcwccw   \
#@                                             sd07C_cpam4os_quad_pll1x_mb_ns_012_pssg_s250_v0670_t000_xcwccw
#@         }
#@         set slow pssg
#@ 
#@         set libraries [concat $library $ck_library $misc_avago_ip_libraries]
#@         set target_libraries [list $library]
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@ 
#@         set tech_library $library
#@         set tech_library_file $library.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         if {$STD_CELL_LIBS_VERSION > 171220} {
#@             set tech_library_dont_use {*_CK* *_BDFF* *INVX2 *INVAX2}
#@             if {! [info exists enable_ulvt_cells] || ! [is_true $enable_ulvt_cells]} {
#@                 lappend tech_library_dont_use P6U*
#@                 set tech_library_high_effort_lib_cells P6U*
#@             }
#@         } else {
#@             set tech_library_dont_use {F6U* *_CKLPD* *_BDFF* *INVX2 *INVAX2}
#@             if {! [info exists enable_ulvt_cells] || ! [is_true $enable_ulvt_cells]} {
#@                 lappend tech_library_dont_use F6U*
#@                 set tech_library_high_effort_lib_cells F6U*
#@             }
#@         }
#@ 
#@         set tech_library_tieoff_cells [list ${prefix}6S8B_TIELO ${prefix}6S8B_TIEHI]
#@         set tech_library_x1_drive_cell ${prefix}6L8B_BUFX2
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@         set tech_library_load_of_1pf 1
#@ 
#@         set tech_clock_gating_latch         $tech_library/${tech_library_cell_prefix}_CKENOAX12
#@         set tech_clock_gating_latch_pattern ${prefix}*B_*CKEN*
#@         
#@         set tech_library_do_use [regsub {^[^/]*/} $tech_clock_gating_latch {}]
#@         
#@         set tech_library_x1_load_cell                ${tech_library_cell_prefix}_INVX2
#@         set tech_library_x1_input_isolation_buffer   ${tech_library_cell_prefix}_BUFAX2
#@         set tech_library_x1_output_isolation_buffer  $ck_library/${tech_library_cell_prefix}_LPDBUFX4
#@ 
#@         if {$TECH_VERSION  == {170912}} {
#@             set mw_dir              milkyway2
#@             set mw_suffix           {}
#@             set mw_tech_file_suffix _hacked
#@         } else {
#@             set mw_dir              milkyway
#@             set mw_suffix           .mdb
#@             set mw_tech_file_suffix _hacked
#@         }
#@         set mw_reference_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_sc06t0750v$mw_suffix $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_ck06t0750v$mw_suffix]
#@         set ndm_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_sc06t0750v.ndm $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_ck06t0750v.ndm]
#@         set mw_tech_file $library_root/TECH/$TECH_VERSION/15M_1x1xa1ya5y2yy2yx2r_R.tf$mw_tech_file_suffix
#@         set mw_max_tluplus  [file dirname $mw_tech_file]/15M_1x1xa1ya5y2yy2yx2r_R07518FF_rcworst_CCworst_T.tlup
#@         set mw_tech2itf_map [file dirname $mw_tech_file]/15M_1x1xa1ya5y2yy2yx2r_R07518FF_plib_2_itf.map.hacked
#@ 
#@         if {[info exists use_tsmc7ff_ga_library] && [is_true $use_tsmc7ff_ga_library]} {
#@             lappend mw_reference_library $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_ga06t0750v$mw_suffix
#@             lappend ndm_library $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_ga06t0750v.ndm
#@         }
#@ 
#@         proc get_all_memory_cells {} {
#@             return [get_cells -quiet -hierarchical -filter ref_name=~PM7*X*VT*&&ref_name!~*_v*]
#@         }
#@ 
#@         if {$STD_CELL_LIBS_VERSION > 171220} {
#@             proc apply_library_derates {} {
#@                 ##### 7nm Synthesis StdCell and Memory Derates
#@                 ## Set STD_CELL_AGING_DERATE to 0.06 for HOD, 0.05 for QOD, 0.04 for NOD
#@                 set STD_CELL_AGING_DERATE   0.04
#@                 ## Set the STD_CELL_PROCESS_DERATE to 0.00 for Elway chips
#@                 set STD_CELL_PROCESS_DERATE 0.00
#@                 ## Set memory aging to 3%
#@                 set MEMORY_AGING_DERATE     0.03
#@                 ## Set the MEMORY_PROCESS_DERATE to 0.00 for Elway chips
#@                 set MEMORY_PROCESS_DERATE   0.00
#@ 
#@                 ## standard cell: aging + process cell_delay derate
#@                 set_timing_derate  -late  [expr 1.0 + $STD_CELL_AGING_DERATE + $STD_CELL_PROCESS_DERATE] -cell_delay -data [current_design]
#@ 
#@                 set memory_cells [get_all_memory_cells]
#@ 
#@                 if {[sizeof_collection $memory_cells] > 0} {
#@                     ## memory: 5% default margin + 3% aging + process cell_delay derate
#@                     set_timing_derate  -late  [expr 1.05 + $MEMORY_AGING_DERATE + $MEMORY_PROCESS_DERATE] -cell_delay -data $memory_cells
#@                     ## memory: 5% default margin + 3% aging + process cell_check derate
#@                     set_timing_derate  -late  [expr 1.05 + $MEMORY_AGING_DERATE + $MEMORY_PROCESS_DERATE] -cell_check       $memory_cells
#@                 }
#@             }
#@             global clock_gate_cells
#@             #                            ref name           clock pin name
#@             array set clock_gate_cells " ${prefix}6${vt}8B_CKENOAX12    phi 
#@                                        " 
#@         }
#@ 
#@     } elseif {[string match TSMC5FF* $technology]} {
#@ 
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc5ff
#@ 
#@         if {! [info exists use_old_library]} {
#@             set STD_CELL_LIBS_VERSION 231212
#@             set TECH_VERSION          231212
#@         } else {
#@             set STD_CELL_LIBS_VERSION 220923
#@             set TECH_VERSION          220923
#@         }
#@ 
#@         set search_path [concat $search_path $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/db $library_root/TECH/$TECH_VERSION]
#@ 
#@         set library tsmc5ff_sc06t0750v_pssg_s300_v0670_t000_xcwccwt
#@         set ck_library tsmc5ff_ck06t0750v_pssg_s300_v0670_t000_xcwccwt
#@ 
#@         if {$STD_CELL_LIBS_VERSION >= 220923} {
#@             set libraries [concat $library $ck_library n5_wlm]
#@             if {[info exists use_tsmc5ff_mb_library] && [is_true $use_tsmc5ff_mb_library]} {
#@                 lappend libraries        tsmc5ff_mb06t0750v_pssg_s300_v0670_t000_xcwccwt
#@                 lappend target_libraries tsmc5ff_mb06t0750v_pssg_s300_v0670_t000_xcwccwt
#@             }
#@         } else {
#@             set libraries [concat $library n5_wlm]
#@         }
#@         set target_libraries [list $library]
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@ 
#@         set tech_library $library
#@         set tech_library_file $library.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list]
#@         foreach tmp $target_libraries {
#@             lappend tech_file_and_libraries $tmp.db:$tmp
#@         }
#@ 
#@         set tech_library_dont_use {*_CK* *_BDFF* *AO2222* *BSDFFAO22*}
#@         if {! [info exists enable_ulvt_cells] || ! [is_true $enable_ulvt_cells]} {
#@             lappend tech_library_dont_use F6U*
#@             set tech_library_high_effort_lib_cells F6U*
#@         }
#@         lappend tech_library_dont_use F6S* F6E*
#@ 
#@         set tech_library_tieoff_cells [list F6LNAA_TIELO F6LNAA_TIEHI]
#@         set tech_library_x1_drive_cell F6LNAA_BUFX2
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@         set tech_library_load_of_1pf 1
#@ 
#@         set tech_clock_gating_latch         $tech_library/${tech_library_cell_prefix}_CKENOAX8
#@         set tech_clock_gating_latch_pattern F*A_*CKEN*
#@ 
#@         set tech_library_do_use [regsub {^[^/]*/} $tech_clock_gating_latch {}]
#@         
#@         set tech_library_x1_load_cell                ${tech_library_cell_prefix}_INVX2
#@         set tech_library_x1_input_isolation_buffer   ${tech_library_cell_prefix}_BUFAX2
#@         set tech_library_x1_output_isolation_buffer  ${tech_library_cell_prefix}_BUFX4
#@ 
#@         if {$STD_CELL_LIBS_VERSION >= 220923} {
#@             set mw_reference_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway2/tsmc5ff_sc06t0750v.mdb $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway2/tsmc5ff_ck06t0750v.mdb]
#@             set ndm_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm2/tsmc5ff_sc06t0750v.ndm $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm2/tsmc5ff_ck06t0750v.ndm]
#@             if {[info exists use_tsmc5ff_mb_library] && [is_true $use_tsmc5ff_mb_library]} {
#@                 lappend mw_reference_library $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway2/tsmc5ff_mb06t0750v.mdb
#@                 lappend ndm_library $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm2/tsmc5ff_mb06t0750v.ndm
#@             }
#@         } else {
#@             set mw_reference_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway/tsmc5ff_sc06t0750v.mdb]
#@             set ndm_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc5ff_sc06t0750v.ndm]
#@         }
#@         set mw_tech_file $library_root/TECH/$TECH_VERSION/17M_1x1xb1xe1ya1yb5y2yy2yx2r_R_enterprise.tf
#@         set mw_max_tluplus  [file dirname $mw_tech_file]/17M_1x1xb1xe1ya1yb5y2yy2yx2r_R07512FF_rcworst_CCworst_T.nxtgrd
#@         if {$TECH_VERSION >= 220923} {
#@             set mw_tech2itf_map [file dirname $mw_tech_file]/17M_1x1xb1xe1ya1yb5y2yy2yx2r_R07512FF_lefdef_rcxt_map
#@         } else {
#@             set mw_tech2itf_map [file dirname $mw_tech_file]/17M_1x1xb1xe1ya1yb5y2yy2yx2r_R07512FF_plib_2_itf.map.hacked
#@         }
#@ 
#@         proc get_all_memory_cells {} {
#@             return [get_cells -quiet -hierarchical -filter ref_name=~M5*X*VT*&&ref_name!~*_v*]
#@         }
#@ 
#@         proc apply_library_derates {} {
#@             ##### Preliminary 5nm Synthesis StdCell and Memory Derates
#@             ## Set STD_CELL_AGING_DERATE to 0.06 for HOD, 0.05 for QOD, 0.04 for NOD
#@             set STD_CELL_AGING_DERATE   0.04
#@             ## Set the STD_CELL_PROCESS_DERATE to 0.00
#@             set STD_CELL_PROCESS_DERATE 0.00
#@             ## Set memory aging to 3%
#@             set MEMORY_AGING_DERATE     0.03
#@             ## Set the MEMORY_PROCESS_DERATE to 0.0
#@             set MEMORY_PROCESS_DERATE   0.00
#@ 
#@             ## standard cell: aging + process cell_delay derate
#@             set_timing_derate  -late  [expr 1.0 + $STD_CELL_AGING_DERATE + $STD_CELL_PROCESS_DERATE] -cell_delay -data [current_design]
#@ 
#@             set memory_cells [get_all_memory_cells]
#@ 
#@             if {[sizeof_collection $memory_cells] > 0} {
#@                 ## memory: 5% default margin + 3% aging + process cell_delay derate
#@                 set_timing_derate  -late  [expr 1.05 + $MEMORY_AGING_DERATE + $MEMORY_PROCESS_DERATE] -cell_delay -data $memory_cells
#@                 ## memory: 5% default margin + 3% aging + process cell_check derate
#@                 set_timing_derate  -late  [expr 1.05 + $MEMORY_AGING_DERATE + $MEMORY_PROCESS_DERATE] -cell_check       $memory_cells
#@             }
#@         }
#@ 
#@         global clock_gate_cells
#@         #                            ref name        clock pin name
#@         array set clock_gate_cells " F6LNAA_CKENOAX8 phi 
#@                                    " 
#@     } elseif {[string match TSMC3FF* $technology]} {
#@ 
#@         set library_root $shared_dir/hwcommon/libs/broadcom/tsmc3ff
#@ 
#@         if {! [info exists use_old_library]} {
#@             set STD_CELL_LIBS_VERSION  231130
#@             set TECH_VERSION           231130
#@             set DESIGN_SUPPORT_VERSION 240318
#@             set PADS_VERSION           240318
#@             set PLL_VERSION            240318
#@             set SERDES_VERSION         240517
#@             set HBM_CORTEX_VERSION     231130
#@         } else {
#@             set STD_CELL_LIBS_VERSION  231009
#@             set TECH_VERSION           231009
#@             set DESIGN_SUPPORT_VERSION 231009
#@             set PADS_VERSION           231009
#@             set PLL_VERSION            231009
#@             set SERDES_VERSION         231009
#@             set HBM_CORTEX_VERSION     231009
#@         }
#@ 
#@         set slow pssg
#@     
#@         if {$topographical_mode} {
#@             if {$nxt_mode} {
#@                 if { $TECH_VERSION >= 230118 && \
#@                      ( [regexp -inline {20\d\d.\d\d} $sh_product_version] < 2022.12 || \
#@                        ( [regexp -inline {20\d\d.\d\d} $sh_product_version] == 2022.12 && [array get env SYNOPSYS_ICC2] != {} && [regexp -inline {20\d\d.\d\d} $env(SYNOPSYS_ICC2)] < 2022.12 ) ) } {
#@                     echo Err\or: Need DC shell 2022.12 or later and ICC2 2022.12 or later for compile_ultra -spg with 3nm library. Don't forget to call dcnxt_use_icc2_link before compile_ultra -spg.
#@                 }
#@             } else {
#@                 if {! ( [string match floorplan* $script_name] || [string match repblock* $script_name] || [string match pilm* $script_name] || [string match dcs* $script_name] || [string match dv* $script_name] )} {
#@                     echo Err\or: 3nm library needs DC NXT mode
#@                 }
#@             }
#@         }
#@ 
#@         if {$STD_CELL_LIBS_VERSION > 211112} {
#@             set e e
#@             set prefix E
#@         } else {
#@             set e {}
#@             set prefix A
#@         }
#@ 
#@         set misc_avago_ip_roots [list $library_root/DESIGN_SUPPORT/$DESIGN_SUPPORT_VERSION/db \
#@                                       $library_root/HBM_CORTEX/$HBM_CORTEX_VERSION/db         \
#@                                       $library_root/PADS/$PADS_VERSION/db                     \
#@                                       $library_root/PLL/$PLL_VERSION/db                       \
#@                                       $library_root/SERDES/$SERDES_VERSION/db                 \
#@                                 ]
#@ 
#@         set search_path [concat $search_path $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/db $library_root/TECH/$TECH_VERSION $misc_avago_ip_roots]
#@ 
#@         set library    tsmc3ff${e}_sc05t0750v_pssg_s300_v0670_t000_xcwccwt
#@         set ck_library tsmc3ff${e}_ck05t0750v_pssg_s300_v0670_t000_xcwccwt
#@ 
#@         set misc_avago_ip_libraries [list ds03_efuse_controller_01_pssg_s300_v0670_t000_xcwccw                                    \
#@                                           ds03_maxahb_bridge_1x4_bm_01_pssg_s300_v0670_t000_xcwccw                                \
#@                                           ds03_memmaster_01_pssg_s300_v0670_t000_xcwccw                                           \
#@                                           ds03_pmro_01_pssg_s300_v0670_t000_xcwccw                                                \
#@                                           ds03_sbus2apb_01_pssg_s300_v0670_t000_xcwccw                                            \
#@                                           ds03_sbus2efuse_01_pssg_s300_v0670_t000_xcwccw                                          \
#@                                           ds03_sbus2vtmon_02_pssg_s300_v0670_t000_xcwccw                                          \
#@                                           LIB_VTMON_REGULATOR_TS3FFE_S0_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins        \
#@                                           LIB_VTMON_ANALOG_TS3FFE_S0_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins           \
#@                                           LIB_VTMON_REMOTE_SENSOR_D2_TS3FFE_S0_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins \
#@                                           E2UNRA_BCM_WATERMARK_IPm34a5pmmps00x5n0As00_pssg_s300_v0670_t000_xcwccwt                \
#@                                           sd03sbus_master_01_pssg_s300_v0670_t000_xcwccw                                          \
#@                                           ds03Cortexm0p_sbus_memory_64kx39_wrapper_01_pssg_s300_v0670_t000_xcwccw                 \
#@                                           BCM3FFEXD18DFT_D1818H_ODTRAN_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins         \
#@                                           BCM3FFEXD18DFT_D1818H_RST_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins            \
#@                                           BCM3FFEXD18DFT_D1818H_TAP_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins            \
#@                                           BCM3FFEXD18DFT_D1818H_TRAN_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins           \
#@                                           BCM3FFEXD18DFT_D1818V_ODTRAN_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins         \
#@                                           BCM3FFEXD18DFT_D1818V_RST_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins            \
#@                                           BCM3FFEXD18DFT_D1818V_TAP_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins            \
#@                                           BCM3FFEXD18DFT_D1818V_TRAN_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins           \
#@                                           BCM3FFEXD18DFT_D18XH_POR_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_D18XH_VBIAS_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins           \
#@                                           BCM3FFEXD18DFT_D18XV_POR_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_D18XV_VBIAS_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins           \
#@                                           BCM3FFEXD18DFT_DCXV_SPACER_P912UM_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins    \
#@                                           BCM3FFEXD18DFT_DECV_VDDC_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_DPEV_VSSC_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_DPNV_VDDO_DECAP_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins       \
#@                                           BCM3FFEXD18DFT_DPNV_VDDO_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_DXXH_DDRV_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_DXXH_END_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins              \
#@                                           BCM3FFEXD18DFT_DXXV_DDRV_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXD18DFT_DXXV_END_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins              \
#@                                           BCM3FFEXHCSL_D08NH_CLKOBS_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins            \
#@                                           BCM3FFEXHCSL_D18NH_ACCKIN_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins            \
#@                                           BCM3FFXD18DFT_X08AV_ESD_INT_pssg_s300_v0670_t000_o1620_xcwccwt_noupf_nopwrpins          \
#@                                           BCM3FFEXHSTL_P15EH_CLAMP_ONLY_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins        \
#@                                           BCM3FFEXHSTL_P15EH_VDDO_VSSC_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins         \
#@                                           BCM3FFEXHSTL_PCXH_SPACER_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins             \
#@                                           BCM3FFEXHSTL_PMNH_PVT15_DRV_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins          \
#@                                           BCM3FFEXHSTL_PMNH_PVT15_TERM_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins         \
#@                                           BCM3FFEXHSTL_PMNH_TRAN15_CAP2X_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins       \
#@                                           BCM3FFEXHSTL_PMNH_TRAN15_DIFG_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins        \
#@                                           BCM3FFEXHSTL_PMNH_TRAN15_DSIG_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins        \
#@                                           BCM3FFEXHSTL_PMNH_TRAN15_SING_pssg_s300_v0670_t000_o1500_xcwccwt_noupf_nopwrpins        \
#@                                           phy03_hbm3_ew_top_2_N3E_N3PPD_pssg_s300_v0670_t125_o0670_xcwccwt                        \
#@                                           phy03_max3_ew_fb_top_0_pssg_s300_v0670_t000_o0670_xcwccwt                               \
#@                                           cpll03_pllsys01_top_ns_02_pssg_s300_v0670_t000_xcwccwt                                  \
#@                                           ds03_ANA_RESCAL_TS3FFE_ub_19M_01_pssg_s300_v0670_t000_xcwccw                            \
#@                                           sd03C_cpam4cd_oct_pll1x_ub_ns_01_pssg_s300_v0670_t000_xcwccw                            \
#@                                           sd03C_cpam4pg3_oct_pll1x_ub_ns_01_pssg_s300_v0670_t000_xcwccw                           \
#@                                           sd03C_cpam4pg3_quad_pll1x_ub_ns_01_pssg_s300_v0670_t000_xcwccw                          \
#@                                           tsmc3ff${e}_lp05t0750v_pssg_s300_v0670_t000_xcwccwt                                     \
#@                                           tsmc3ff${e}_lscore_pssg_s300_v0670_t000_o0670_xcwccwt                                   \
#@                                           tsmc3ff${e}_top05t0750v_pssg_s300_v0670_t000_xcwccwt                                    \
#@                                     ]
#@ 
#@         set libraries [concat $library $ck_library $misc_avago_ip_libraries n3_wlm]
#@         set target_libraries [list $library]
#@ 
#@         if {[info exists use_tsmc3ff_mb_library] && [is_true $use_tsmc3ff_mb_library]} {
#@             lappend libraries        tsmc3ff${e}_mb05t0750v_pssg_s300_v0670_t000_xcwccwt
#@             lappend target_libraries tsmc3ff${e}_mb05t0750v_pssg_s300_v0670_t000_xcwccwt
#@         }
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@ 
#@         set tech_library $library
#@         set tech_library_file $library.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list]
#@         foreach tmp $target_libraries {
#@             lappend tech_file_and_libraries $tmp.db:$tmp
#@         }
#@ 
#@         set tech_library_dont_use {*_CK* *_BDFF*}
#@         if {$STD_CELL_LIBS_VERSION < 230118} {
#@             lappend tech_library_dont_use ?1*DFF*
#@         }
#@ 
#@         # enable_ulvt_cells
#@         # 0 = Allow LL and LN only
#@         # 1 = Allow LL, LN, UL and UN
#@         # 99 Special code for allow LL, LN and UL
#@         # 1000 Special code for allow L*, U* and EN
#@         
#@         lappend tech_library_dont_use ${prefix}?S*
#@         
#@         if {! [info exists enable_ulvt_cells] || ! [is_true $enable_ulvt_cells]} {
#@             lappend tech_library_dont_use ${prefix}?U*
#@             lappend tech_library_dont_use ${prefix}?E*
#@             set tech_library_high_effort_lib_cells ${prefix}?U*
#@         } else {
#@             if { $enable_ulvt_cells == 99 } {
#@                 lappend tech_library_dont_use ${prefix}?UN*
#@             }
#@             if { $enable_ulvt_cells != 1000 } {
#@                 lappend tech_library_dont_use ${prefix}?E*
#@             }
#@         }
#@ 
#@         set tech_library_tieoff_cells [list ${prefix}2LNRA_TIELO ${prefix}2LNRA_TIEHI]
#@         set tech_library_x1_drive_cell ${prefix}2LNRA_BUFX2
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@         set tech_library_load_of_1pf 1
#@ 
#@         set tech_clock_gating_latch         $tech_library/${prefix}2LLRA_CKENOAX8
#@         set tech_clock_gating_latch_pattern ${prefix}*A_*CKEN*
#@ 
#@         set tech_library_do_use [regsub {^[^/]*/} $tech_clock_gating_latch {}]
#@         if {([string match */genus [info nameofexecutable]] || [string match */innovus [info nameofexecutable]]) && $STD_CELL_LIBS_VERSION <= 220923} {
#@             lappend tech_library_do_use ${prefix}2LLGA_CKENOAX8
#@         }
#@ 
#@         set tech_library_x1_load_cell                ${tech_library_cell_prefix}_INVX2
#@         set tech_library_x1_input_isolation_buffer   ${tech_library_cell_prefix}_BUFAX2
#@         set tech_library_x1_output_isolation_buffer  ${tech_library_cell_prefix}_BUFX4
#@ 
#@         set mw_reference_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway2/tsmc3ff${e}_sc05t0750v.mdb $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway2/tsmc3ff${e}_ck05t0750v.mdb]
#@         set ndm_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm2/tsmc3ff${e}_sc05t0750v.ndm $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm2/tsmc3ff${e}_ck05t0750v.ndm]
#@         if {[info exists use_tsmc3ff_mb_library] && [is_true $use_tsmc3ff_mb_library]} {
#@             lappend mw_reference_library $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/milkyway2/tsmc3ff${e}_mb05t0750v.mdb
#@             lappend ndm_library $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm2/tsmc3ff${e}_mb05t0750v.ndm
#@         }
#@         if {$TECH_VERSION > 211112} {
#@             if {$TECH_VERSION >= 231009} {
#@                 set mw_tech_file_suffix _hacked
#@             } else {
#@                 set mw_tech_file_suffix {}
#@             }
#@             set mw_tech_file $library_root/TECH/$TECH_VERSION/19M_1xa1xb1xc1xd1ya1yb6y2yy2yx2r_R_enterprise_MH143.tf$mw_tech_file_suffix
#@             set mw_max_tluplus  [file dirname $mw_tech_file]/19M_1xa1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FFE_rcworst_CCworst_T.nxtgrd
#@             set mw_min_tluplus  [file dirname $mw_tech_file]/19M_1xa1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FFE_rcbest_CCbest.nxtgrd
#@             if {$TECH_VERSION >= 220923} {
#@                 set mw_tech2itf_map [file dirname $mw_tech_file]/19M_1xa1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FFE_lefdef_rcxt_map
#@             } else {
#@                 set mw_tech2itf_map [file dirname $mw_tech_file]/19M_1xa1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FFE_plib_2_itf.map.hacked
#@             }
#@         } else {
#@             set mw_tech_file $library_root/TECH/$TECH_VERSION/19M_1x1xb1xc1xd1ya1yb6y2yy2yx2r_R_enterprise_MH143.tf
#@             set mw_max_tluplus  [file dirname $mw_tech_file]/19M_1x1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FF_rcworst_CCworst_T.nxtgrd
#@             set mw_min_tluplus  [file dirname $mw_tech_file]/19M_1x1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FF_rcbest_CCbest.nxtgrd
#@             set mw_tech2itf_map [file dirname $mw_tech_file]/19M_1x1xb1xc1xd1ya1yb6y2yy2yx2r_R07512FF_plib_2_itf.map.hacked
#@         }
#@ 
#@         proc get_all_memory_cells {} {
#@             return [get_cells -quiet -hierarchical -filter ref_name=~M3*X*VT*&&ref_name!~*_v*]
#@         }
#@ 
#@         proc apply_library_derates {} {
#@             ##### Preliminary 3nm Synthesis StdCell and Memory Derates
#@             ## Set STD_CELL_AGING_DERATE to 0.06 for HOD, 0.05 for QOD, 0.04 for NOD
#@             set STD_CELL_AGING_DERATE   0.04
#@             ## Set the STD_CELL_PROCESS_DERATE to 0.0
#@             set STD_CELL_PROCESS_DERATE 0.00
#@             ## Set memory aging to 3%
#@             set MEMORY_AGING_DERATE     0.03
#@             ## Set the MEMORY_PROCESS_DERATE to 0.0
#@             set MEMORY_PROCESS_DERATE   0.00
#@ 
#@             ## standard cell: aging + process cell_delay derate
#@             set_timing_derate  -late  [expr 1.0 + $STD_CELL_AGING_DERATE + $STD_CELL_PROCESS_DERATE] -cell_delay -data [current_design]
#@ 
#@             set memory_cells [get_all_memory_cells]
#@ 
#@             if {[sizeof_collection $memory_cells] > 0} {
#@                 ## memory: 5% default margin + 3% aging + process cell_delay derate
#@                 set_timing_derate  -late  [expr 1.05 + $MEMORY_AGING_DERATE + $MEMORY_PROCESS_DERATE] -cell_delay -data $memory_cells
#@                 ## memory: 5% default margin + 3% aging + process cell_check derate
#@                 set_timing_derate  -late  [expr 1.05 + $MEMORY_AGING_DERATE + $MEMORY_PROCESS_DERATE] -cell_check       $memory_cells
#@             }
#@         }
#@ 
#@         global clock_gate_cells
#@         #                            ref name                clock pin name
#@         array set clock_gate_cells " ${prefix}2LLRA_CKENOAX8 phi 
#@                                    " 
#@ 
#@ ################################# ONSEMI  ####################################################################
#@ 
#@     } elseif {[string match ONK65* $technology]} {
#@ 
#@         set library_root $shared_dir/hwcommon/libs/onsemi/onk65
#@ 
#@         set STD_CELL_LIBS_VERSION 220502
#@         set TECH_VERSION          220502
#@         set IO_VERSION            220502
#@         set PLL_VERSION           220715
#@         
#@         set std_rev               Rev1.300
#@         set io_rev                Rev1.200
#@ 
#@         #The <PVT> used in the file names is in the form of Process_Voltage_Temperature.
#@         #Process can be one of tt, ff, ss, meaning typical, fast, or slow process with 
#@         #an optional specifier suffix (e.g. 5s for 5sigma corners, f for functional 
#@         #corners etc.).
#@         #Temperature is the value in centigrade and has a suffix of 'c' to represent this
#@         #measurement quantity. If the temperature is below zero, it is prefixed with 'm'
#@         #for minus, instead of '-'.
#@         #The supply voltage is the number with the 'v' suffix and has no prefix.       
#@ 
#@      
#@         #Onsemi (Namitha) response on Aug. 11., 2022: 
#@         #FOR SLOW       (WC)  : ssf3s_1.08v_150c
#@         #FOR FAST       (BC)  : fff3s_1.32v_m40c 
#@         #FOR TYPICAL    (TYP) : tt_1.2v_25c
#@ 
#@ 
#@         set slow ssf
#@         set typ  tt
#@         set fast ff
#@     
#@ 
#@         set p ${slow}
#@         set v 1.08
#@         set t 125 
#@         set s 3s   
#@      
#@         set io_v 2.97
#@      
#@         if {[info exists use_lvt_target_lib]} {
#@             set vt c
#@         } elseif {[info exists use_ulvt_target_lib]} {
#@             set vt d
#@         } else {
#@             set vt b
#@         }    
#@             
#@         set std_cell    sc${vt}
#@         set io_cell     pc3
#@     
#@ 
#@         set std_libs    onnn065cxo${std_cell}/${std_rev}/liberty/ccs
#@         set io_libs     onnn065cxo${io_cell}/${io_rev}/liberty
#@         set pll_libs    liberty
#@     
#@         set misc_onsemi_ip_roots [list  $library_root/IO/$IO_VERSION/${io_libs}                         \
#@                                         $library_root/PLL/$PLL_VERSION/${pll_libs}                      \
#@                                  ]
#@         set search_path [concat $search_path $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/${std_libs} $misc_onsemi_ip_roots ]
#@ 
#@ 
#@         set library     onnn065cxo${std_cell}_${p}${s}_${v}v_${t}c
#@         set io_library  onnn065cxo${io_cell}_wc_c${v}v_p${io_v}v_${t}c
#@ 
#@         # TBD: add the corner of interest for the PLL.
#@         # 220718 email from Namitha of Onsemi: 
#@         # "At this time, we only have the typical corner. I will check with the designer and see what the ETA is for the other corners."
#@         #
#@         set pll_library   onk65_pll1201_tc_1.2v_25c_FUNC 
#@ 
#@ 
#@         set libraries [concat $library $io_library $pll_library]
#@         set target_libraries [list $library]
#@ 
#@         #################################################################################################################### 
#@         #if required to use higher speed vt library
#@         global allow_high_speed_library_cells
#@         global hs_vt
#@         global hs_std_rev
#@         if {[info exists allow_high_speed_library_cells] && [info exists hs_vt] && [info exists hs_std_rev] && $allow_high_speed_library_cells } {
#@         set std_cell_hs sc${hs_vt}
#@         set std_libs_hs onnn065cxo${std_cell_hs}/${hs_std_rev}/liberty/ccs
#@         set search_path [concat $search_path $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/${std_libs_hs}]
#@             set hs_library  onnn065cxo${std_cell_hs}_${p}${s}_${v}v_${t}c
#@         lappend libraries $hs_library
#@         lappend target_libraries $hs_library
#@             echo "===>Information:allow_high_speed_library_cells is set\n===>SEARCH PATH=${search_path}\n===>TARGET LIBRARIES=${target_libraries}\n===>LINK LIBRARIES=${libraries}"
#@     }
#@         #################################################################################################################### 
#@ 
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@       
#@         set tech_library $library
#@         set tech_library_file $library.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         set tech_library_dont_use {dff* lat*}
#@ 
#@ 
#@         set tech_library_tieoff_cells [list   tolx1_${vt}   tohx1_${vt}]
#@         set tech_library_x1_drive_cell bufx1_${vt}
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@      
#@         #TBD: what is this?
#@         set tech_library_load_of_1pf 1
#@ 
#@         #TBD: do we need the observable pin, and how to tie?
#@         set tech_clock_gating_latch         $tech_library/clksgpx6_${vt}
#@ 
#@ 
#@         set tech_clock_gating_latch_pattern *clkgsp*
#@         
#@ 
#@         set tech_library_do_use [regsub {^[^/]*/} $tech_clock_gating_latch {}]
#@         
#@         set tech_library_x1_load_cell                invx1_${vt}
#@         set tech_library_x1_input_isolation_buffer   bufx1_${vt} 
#@         set tech_library_x1_output_isolation_buffer  bufx2_${vt}
#@ 
#@ 
#@ 
#@ #        #TBD Do we need to get milkyway libraries from ONSEMI? 
#@ #
#@ #        if {$TECH_VERSION  == {170912}} {
#@ #            set mw_dir              milkyway2
#@ #            set mw_suffix           {}
#@ #            set mw_tech_file_suffix _hacked
#@ #        } else {
#@ #            set mw_dir              milkyway
#@ #            set mw_suffix           .mdb
#@ #            set mw_tech_file_suffix _hacked
#@ #        }
#@ #
#@ #
#@ #        set mw_reference_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_sc06t0750v$mw_suffix $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_ck06t0750v$mw_suffix]
#@ #        set ndm_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_sc06t0750v.ndm $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_ck06t0750v.ndm]
#@ #        set mw_tech_file $library_root/TECH/$TECH_VERSION/15M_1x1xa1ya5y2yy2yx2r_R.tf$mw_tech_file_suffix
#@ #        set mw_max_tluplus  [file dirname $mw_tech_file]/15M_1x1xa1ya5y2yy2yx2r_R07518FF_rcworst_CCworst_T.tlup
#@ #        set mw_tech2itf_map [file dirname $mw_tech_file]/15M_1x1xa1ya5y2yy2yx2r_R07518FF_plib_2_itf.map.hacked
#@ #
#@ 
#@ 
#@         global clock_gate_cells
#@         #                            ref name        clock pin name
#@         array set clock_gate_cells " clksgpx6_${vt}     CK
#@                                    "
#@ 
#@ 
#@ 
#@ ################################# ALPHAWAVE-TSMC TCBN55LP ####################################################################
#@ 
#@     } elseif {[string match tcbn55lp* $technology]} {
#@ 
#@ #        set library_root $shared_dir/hwcommon/libs/onsemi/onk65
#@ #For now                
#@         set library_root  /shared/pconchip/alphawave/incoming/hwcommon/libs/alphawave/${technology}
#@ 
#@         set STD_CELL_LIBS_VERSION 230602
#@         set IO_VERSION            230602
#@ 
#@ #TBD: Populate these when available
#@         set TECH_VERSION          ""
#@ #TBD
#@         set PLL_VERSION           220715
#@         
#@         set std_rev               "200a"
#@         set io_rev                "210a"
#@ 
#@ 
#@         # There are 3 delay models, CCS, ECSM, NLDM.
#@         # CCS (Composite Current Source) offers the best accuracy
#@ 
#@         set STD_DELAY_MODEL CCS
#@         set IO_DELAY_MODEL  NLDM
#@ 
#@         ####################
#@         # STD CELLS        #
#@         #################################################################################################################################################
#@         # hwcommon/libs/alphawave/tcbn55lp/STD_CELL_LIBS/230602/tcbn55lp_200a/TSMCHOME/digital/Documentation/release_note/RN_TCBN55LP_200A.pdf
#@         #################################################################################################################################################
#@         # 4. CHARACTERIZATION CONDITIONS
#@         # I. Base characterization corners
#@         # Corner Voltage(V) Temperature(C) Process   Library              Current Selection (for now) (TBD:Try all)
#@         # BCCOM   1.32          0             FF     tcbn55lpbc_ccs          
#@         # LTCOM   1.32        -40             FF     tcbn55lplt_ccs <--------  FAST    (BC)
#@         # MLCOM   1.32        125             FF     tcbn55lpml_ccs             
#@         # NCCOM   1.2          25             TT     tcbn55lptc_ccs <--------  TYPICAL (TYP) 
#@         # WCCOM   1.08        125             SS     tcbn55lpwc_ccs <--------  SLOW    (WC)
#@         # WCLCOM  1.08        -40             SS     tcbn55lpwcl_ccs
#@         # WCZCOM  1.08          0             SS     tcbn55lpwcz_ccs
#@         #################################################################################################################################################
#@         # TBD: CONSIDER ADDING:
#@         #     Low/High-voltage characterization corners
#@         #     Multi-Vdd characterization corners
#@         #################################################################################################################################################
#@ 
#@ 
#@ 
#@         ####################
#@         # IO               #
#@         #################################################################################################################################################
#@         # hwcommon/libs/alphawave/tcbn55lp/IO/230602/tphn55lpgv2od3_sl_210a/TSMCHOME/digital/Documentation/release_note/RN_TPHN55LPGV2OD3_SL_210A.pdf
#@         #################################################################################################################################################
#@         #Corner        VDDcore        VDDIO        Temperature        Process        IBIS        Corner
#@         #TC        1.2V        3.3V        25C        TT        TYP        (12_33.IBS) <-------  TYPICAL (TYP) tphn55lpgv2od3_sltc.db
#@         #BC        1.32V        3.6V        0C        FF        -
#@         #WC        1.08V        3.0V        125C        SS        MIN        (12_33.IBS) <-------  SLOW    (WC)  tphn55lpgv2od3_slwc.db
#@         #LT        1.32V        3.6V        -40C        FF        MAX        (12_33.IBS) <-------  FAST    (BC)  tphn55lpgv2od3_sllt.db
#@         #WCL        1.08V        3.0V        -40C        SS        -
#@         #ML        1.32V        3.6V        125C        FF        -
#@         #WCZ        1.08V        3.0V        0C        SS        -
#@         #
#@         #Corner        VDDcore        VDDIO        Temperature        Process        IBIS        Corner
#@         #TC1        1.2V        2.5V        25C        TT        TYP        (12_25.IBS)
#@         #BC1        1.32V        2.75V        0C        FF        -
#@         #WC1        1.08V        2.25V        125C        SS        MIN        (12_25.IBS)
#@         #LT1        1.32V        2.75V        -40C        FF        MAX        (12_25.IBS)
#@         #WCL1        1.08V        2.25V        -40C        SS        -
#@         #ML1        1.32V        2.75V        125C        FF        -
#@         #WCZ1        1.08V        2.25V        0C        SS        -
#@         #
#@         #Corner        VDDcore        VDDIO        Temperature        Process        IBIS        Corner
#@         #TC2        1.0V        3.3V        25C        TT        TYP        (1_33.ibs)
#@         #BC2        1.1V        3.6V        0C        FF        -
#@         #WC2        0.9V        3.0V        125C        SS        MIN        (1_33.ibs)
#@         #LT2        1.1V        3.6V        -40C        FF        MAX        (1_33.ibs)
#@         #WCL2        0.9V        3.0V        -40C        SS        -
#@         #ML2        1.1V        3.6V        125C        FF        -
#@         #WCZ2        0.9V        3.0V        0C        SS        -
#@         #
#@         #Corner        VDDcore        VDDIO        Temperature        Process        IBIS        Corner
#@         #TC3        1.0V        2.5V        25C        TT        TYP        (1_25.ibs)
#@         #BC3        1.1V        2.75V        0C        FF        -
#@         #WC3        0.9V        2.25V        125C        SS        MIN        (1_25.ibs)
#@         #LT3        1.1V        2.75V        -40C        FF        MAX        (1_25.ibs)
#@         #WCL3        0.9V        2.25V        -40C        SS        -
#@         #ML3        1.1V        2.75V        125C        FF        -
#@         #WCZ3        0.9V        2.25V        0C        SS        -
#@         #################################################################################################################################################
#@ 
#@ 
#@         #corners
#@         set slow wc
#@         set typ  tc
#@         set fast lt    
#@ 
#@         set corner $slow
#@      
#@ 
#@         if {[info exists use_lvt_target_lib]} {
#@             puts "Using LVT target lib"
#@             set vt lvt
#@         } elseif {[info exists use_hvt_target_lib]} {
#@             puts "Using HVT target lib"
#@             set vt hvt
#@         } else {
#@             set vt ""
#@         }    
#@ 
#@         set io_technology  tphn55lpgv2od3_sl
#@     
#@ 
#@ 
#@ #        STD_CELL_LIBS/230602/tcbn55lp_200a   /TSMCHOME/digital/Front_End/timing_power_noise/CCS/tcbn55lp_200a
#@ #        STD_CELL_LIBS/230602/tcbn55lphvt_200a/TSMCHOME/digital/Front_End/timing_power_noise/CCS/tcbn55lphvt_200a
#@ #        STD_CELL_LIBS/230602/tcbn55lplvt_200a/TSMCHOME/digital/Front_End/timing_power_noise/CCS/tcbn55lplvt_200a
#@ 
#@ #        STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/${technology}${vt}_${std_rev}/TSMCHOME/digital/Front_End/timing_power_noise/${STD_DELAY_MODEL}/${technology}${vt}_${std_ver}
#@ 
#@ 
#@  
#@ 
#@ #        IO/230602/tphn55lpgv2od3_sl_210a/TSMCHOME/digital/Front_End/timing_power_noise/NLDM/tphn55lpgv2od3_sl_210a
#@ #          IO/${IO_VERSION}/${io_technology}_${io_rev}/TSMCHOME/digital/Front_End/timing_power_noise/${IO_DELAY_MODEL}/${io_technology}_${io_rev}
#@ 
#@ 
#@         set std_libs    STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/${technology}${vt}_${std_rev}/TSMCHOME/digital/Front_End/timing_power_noise/$STD_DELAY_MODEL/${technology}${vt}_${std_rev}
#@         set io_libs     IO/$IO_VERSION/${io_technology}_${io_rev}/TSMCHOME/digital/Front_End/timing_power_noise/$IO_DELAY_MODEL/${io_technology}_${io_rev}
#@ #        TBD: Missing PLL LIBS -- Can we use Onsemi one for now?
#@         set pll_libs    liberty
#@     
#@         set misc_alphawave_ip_roots [list  $library_root/$io_libs                        \
#@                                            $shared_dir/hwcommon/libs/onsemi/onk65/PLL/$PLL_VERSION/$pll_libs                      \
#@                                     ]
#@         set search_path [concat $search_path $library_root/${std_libs} $misc_alphawave_ip_roots ]
#@ 
#@         echo "ALPHAWAVE search_path=$search_path"
#@ 
#@         set library     ${technology}${corner}_[string tolower $STD_DELAY_MODEL]
#@         set io_library  ${io_technology}${corner}
#@ #        TBD: Missing PLL LIBS -- Can we use Onsemi one for now?
#@         set pll_library   onk65_pll1201_tc_1.2v_25c_FUNC 
#@         echo "ALPHAWAVE library=$library"
#@         echo "ALPHAWAVE io_library=$io_library"
#@ 
#@ 
#@ 
#@         set libraries [concat $library $io_library $pll_library]
#@         set target_libraries [list $library]
#@         echo "ALPHAWAVE libraries=$libraries"
#@         echo "ALPHAWAVE target_libraries=$target_libraries"
#@ 
#@ 
#@ #TBD: review the following
#@ #        #################################################################################################################### 
#@ #        #if required to use higher speed vt library
#@ #        global allow_high_speed_library_cells
#@ #        global hs_vt
#@ #        global hs_std_rev
#@ #        if {[info exists allow_high_speed_library_cells] && [info exists hs_vt] && [info exists hs_std_rev] && $allow_high_speed_library_cells } {
#@ #        set std_cell_hs sc${hs_vt}
#@ #        set std_libs_hs onnn065cxo${std_cell_hs}/${hs_std_rev}/liberty/ccs
#@ #        set search_path [concat $search_path $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/${std_libs_hs}]
#@ #            set hs_library  onnn065cxo${std_cell_hs}_${p}${s}_${v}v_${t}c
#@ #        lappend libraries $hs_library
#@ #        lappend target_libraries $hs_library
#@ #            echo "===>Information:allow_high_speed_library_cells is set\n===>SEARCH PATH=${search_path}\n===>TARGET LIBRARIES=${target_libraries}\n===>LINK LIBRARIES=${libraries}"
#@ #    }
#@ #        #################################################################################################################### 
#@ 
#@         
#@         set link_library [concat {*} [split [join $libraries {.db }].db]]
#@         set target_library [split [join $target_libraries {.db }].db]
#@       
#@         set tech_library $library
#@         set tech_library_file $library.db
#@         set tech_file_and_library $tech_library_file:$tech_library
#@         set tech_file_and_libraries [list $tech_file_and_library]
#@ 
#@         set tech_library_dont_use {DF* LH* LN* EDF*}
#@ 
#@ 
#@ #TBD: DOUBLE CHECK THESE WITH VENDOR
#@         set tech_library_tieoff_cells [list [string toupper tiel${vt}] [string toupper tieh${vt}]  ]
#@         set tech_library_x1_drive_cell  [string toupper buffd0${vt}]
#@         regexp {^([^_]+)_} $tech_library_x1_drive_cell dummy tech_library_cell_prefix
#@      
#@ #        #TBD: what is this?
#@         set tech_library_load_of_1pf 1
#@ #
#@ #        #TBD: do we need the observable pin, and how to tie?
#@                 set tech_clock_gating_latch         $tech_library/CKLNQD6${vt}
#@ 
#@ 
#@         set tech_clock_gating_latch_pattern *CKL*
#@         
#@ 
#@         set tech_library_do_use [regsub {^[^/]*/} $tech_clock_gating_latch {}]
#@         
#@         set tech_library_x1_load_cell                INVD2${vt}
#@         set tech_library_x1_input_isolation_buffer   BUFFD0${vt} 
#@         set tech_library_x1_output_isolation_buffer  BUFFD2${vt}
#@ 
#@ 
#@ 
#@ #        #TBD Do we need to get milkyway libraries from ONSEMI? 
#@ #
#@ #        if {$TECH_VERSION  == {170912}} {
#@ #            set mw_dir              milkyway2
#@ #            set mw_suffix           {}
#@ #            set mw_tech_file_suffix _hacked
#@ #        } else {
#@ #            set mw_dir              milkyway
#@ #            set mw_suffix           .mdb
#@ #            set mw_tech_file_suffix _hacked
#@ #        }
#@ #
#@ #
#@ #        set mw_reference_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_sc06t0750v$mw_suffix $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/$mw_dir/tsmc7ff${p}_ck06t0750v$mw_suffix]
#@ #        set ndm_library [list $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_sc06t0750v.ndm $library_root/STD_CELL_LIBS/$STD_CELL_LIBS_VERSION/ndm/tsmc7ff${p}_ck06t0750v.ndm]
#@ #        set mw_tech_file $library_root/TECH/$TECH_VERSION/15M_1x1xa1ya5y2yy2yx2r_R.tf$mw_tech_file_suffix
#@ #        set mw_max_tluplus  [file dirname $mw_tech_file]/15M_1x1xa1ya5y2yy2yx2r_R07518FF_rcworst_CCworst_T.tlup
#@ #        set mw_tech2itf_map [file dirname $mw_tech_file]/15M_1x1xa1ya5y2yy2yx2r_R07518FF_plib_2_itf.map.hacked
#@ #
#@ 
#@ 
#@         global clock_gate_cells
#@         #                            ref name        clock pin name
#@         array set clock_gate_cells " CKLNQD6${vt}     CP
#@                                    "
#@       
#@ 
#@ 
#@ 
#@ ######################################################################################################
#@ 
#@ 
#@ 
#@     } else {
#@         puts Warn\ing: Technology $technology not recognized
#@ 
#@         set link_library [list {*}]
#@         set target_library [list]
#@         set symbol_library [list]
#@     }
#@ 
#@     if {[info exists synopsys_program_name]} {
#@         # Suppress VHDL-87/93 differences warnings
#@         suppress_message VHDL-2285
#@     
#@         # About generics being integers
#@         suppress_message VHDL-2023
#@ 
#@         # Suppress assert and report warnings
#@         suppress_message VHDL-2099
#@     
#@         # Suppress cache warnings caused by NT's path length limitations
#@         suppress_message SYNOPT-1
#@         suppress_message SYNOPT-4
#@     }
#@     if {[string match */genus [info nameofexecutable]]} {
#@         # Suppress assert and report warnings
#@         suppress_messages -quiet VHDL-643
#@         suppress_messages -quiet VHDL-644
#@         suppress_messages -quiet VHDL-645
#@     }
#@ 
#@     if { [info exists synopsys_program_name] && \
#@          ( $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui} ) } {
#@         if { [string match pc* $script_name]        || \
#@              [string match pilm* $script_name]      || \
#@              [string match floorplan* $script_name] || \
#@              [string match *def* $script_name]      || \
#@              [string match *route* $script_name]} {
#@             lappend licenses_required PhysOpt
#@         }
#@ 
#@         # Some cells aren't in the physical library, avoid a complaint
#@         suppress_message PSYN-025
#@         
#@         # Site is in absolute co-ordinates
#@         suppress_message PDIN-5
#@         
#@         # Attributes being treated as user attributes
#@         suppress_message PDIN-6
#@         
#@         set psyn_add_debug_commands true
#@     } else {
#@         # Stop dc shell from complaining about missing physical libraries
#@         lappend suppress_errors PSYN-021
#@     }
#@ 
#@     if {[info exists additional_link_libraries]} {
#@         foreach lib_name $additional_link_libraries {
#@             lappend link_library $lib_name
#@         }
#@     }
#@ 
#@     if {[info exists link_libraries_not_required]} {
#@         foreach link_library_not_required $link_libraries_not_required {
#@             set tmp [lsearch $link_library $link_library_not_required]
#@             if {$tmp >= 0} {
#@                 lappend link_libraries_not_required2 [lrange $link_library $tmp $tmp]
#@                 set link_library [concat [lrange $link_library 0 [expr $tmp-1]] [lrange $link_library [expr $tmp+1] end]]
#@             }
#@         }
#@     }
#@     
#@     if {[info exists additional_physical_libraries]} {
#@         foreach lib_name $additional_physical_libraries {
#@             lappend physical_library $lib_name
#@         }
#@     }
#@     
#@     if {! [info exists synopsys_program_name] || $synopsys_program_name != {lm_shell}} {
#@         proc get_licenses {licenses_required} {
#@             global synopsys_program_name
#@             global suppress_errors
#@             global script_name
#@             global sh_product_version
#@             global tmp_file
#@         
#@             foreach license_name2 $licenses_required {
#@             foreach license_name1 [split $license_name2 " "] {
#@                 if {! [regexp {^(\d+)x(.*)$} $license_name1 dummy quantity license_name]} {
#@                     set quantity 1
#@                     set license_name $license_name1
#@                 }
#@                 if {[regexp {^(.*)_or_(.*)$} $license_name dummy preferred_license_name alt_license_name]} {
#@                     set license_names [list $preferred_license_name $alt_license_name]
#@                 } else {
#@                     set license_names [list $license_name]
#@                 }
#@                 if {! [info exists synopsys_program_name] || ($synopsys_program_name != {pt_shell} && $synopsys_program_name != {psyn_shell} && $synopsys_program_name != {psyn_gui})} {
#@                     if {[info exists suppress_errors]} {
#@                         set previous_suppress_errors $suppress_errors
#@                         lappend suppress_errors UI-32
#@                     }
#@                     remove_license $license_names
#@                     if {[info exists suppress_errors]} {
#@                         set suppress_errors $previous_suppress_errors
#@                     }
#@                 }
#@                 if {[info exists suppress_errors]} {
#@                     set previous_suppress_errors $suppress_errors
#@                     lappend suppress_errors SEC-50 SEC-51
#@                 }
#@                 set index 0
#@                 while {1} {
#@                     set license_name [lindex $license_names $index]
#@                     if {[info exists sh_product_version] && [regexp -inline {20\d\d.\d\d} $sh_product_version] >= 2004.12} {
#@                         if {$quantity > 1} {
#@                             redirect -variable tmp {set status [get_license -quantity $quantity $license_name]}
#@                         } else {
#@                             redirect -variable tmp {set status [get_license $license_name]}
#@                         }
#@                     } else {
#@                         if {$quantity > 1} {
#@                             redirect $tmp_file {set status [get_license -quantity $quantity $license_name]}
#@                         } else {
#@                             redirect $tmp_file {set status [get_license $license_name]}
#@                         }
#@                         set file [open $tmp_file]
#@                         set tmp [read $file]
#@                         close $file
#@                     }
#@                     if {$status} {
#@                         break
#@                     }
#@                     if {[string match {*You already have a*} $tmp]} {
#@                         break
#@                     }
#@                     if {! [string match {*The current users of this feature are*} $tmp]} {
#@                         regsub {^Err.r: } $tmp {} tmp
#@                         echo Information: $tmp
#@                     }
#@                     incr index
#@                     if {$index == [llength $license_names]} {
#@                         set index 0
#@                         echo Polling for license $license_name
#@                         exec sleep 10
#@                     }
#@                 }
#@                 if {[info exists suppress_errors]} {
#@                     set suppress_errors $previous_suppress_errors
#@                 }
#@             }
#@             }
#@ 
#@             return 1
#@         }
#@     }
#@ 
#@     if { [info exists synopsys_program_name] && \
#@          ( $synopsys_program_name != {milkyway} && \
#@            $synopsys_program_name != {lc_shell} && \
#@            $synopsys_program_name != {ca_shell} && \
#@            $synopsys_program_name != {fm_shell} && \
#@            $synopsys_program_name != {icc2_lm_shell} && \
#@            $synopsys_program_name != {lm_shell} ) } {
#@         if {[info exists licenses_not_required]} {
#@             set licenses_required [lminus $licenses_required $licenses_not_required]
#@         }
#@         get_licenses $licenses_required
#@     }
#@ 
#@     puts "[clock format [clock seconds]] $script_name $version $type $technology"
#@     
#@     set xg_mode 0
#@                              
#@     if {[info exists synopsys_program_name] && $synopsys_program_name == {ca_shell}} {
#@         set link_path $link_library
#@     } else {
#@         if {[string match *DesignWare* $licenses_required] || [info exists load_designware_libraries]} {
#@             if {[info exists sh_product_version] && [regexp -inline {20\d\d} $sh_product_version] >= 2010} {
#@                 if {! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}} {
#@                     lappend link_library dw_foundation.sldb
#@                 }
#@                 lappend synthetic_library dw_foundation.sldb
#@             } else {
#@                 if {! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}} {
#@                     lappend link_library dw01.sldb dw02.sldb dw_foundation.sldb
#@                 }
#@                 lappend synthetic_library dw01.sldb dw02.sldb dw_foundation.sldb
#@             }
#@         }
#@     
#@         unset -nocomplain library
#@         foreach lib_file $link_library {
#@             regsub {^.*/} $lib_file {} lib_name
#@             regsub {\.db$} $lib_name {} lib_name
#@             if {[string match TC260* $technology]} {
#@                 regsub {\.db_WCMIL15$} $lib_name {} lib_name
#@                 regsub {\.db_MAX$} $lib_name {} lib_name
#@                 if { $lib_file != {TC260C7_wcmil15.db} && \
#@                      ( [regsub {_WCMIL15} $lib_file {_BCCOM15} min_lib_file] || \
#@                        [regsub {_wcmil15} $lib_file {_bccom15} min_lib_file] || \
#@                        [regsub {_MAX} $lib_file {_MIN} min_lib_file] ) && \
#@                      ( [regsub {_WCMIL15} $lib_file {_NOMIN15} typ_lib_file] || \
#@                        [regsub {_wcmil15} $lib_file {_nomin15} typ_lib_file] || \
#@                        [regsub {_MAX} $lib_file {_TYP} typ_lib_file] ) } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                 }
#@                 if { $lib_name != {TC260C7_wcmil15.db} && \
#@                      ( [regsub {_WCMIL15} $lib_name {_BCCOM15} min_lib_name] || \
#@                        [regsub {_wcmil15} $lib_name {_bccom15} min_lib_name] || \
#@                        [regsub {_MAX} $lib_name {_MIN} min_lib_name] ) && \
#@                      ( [regsub {_WCMIL15} $lib_name {_NOMIN15} typ_lib_name] || \
#@                        [regsub {_wcmil15} $lib_name {_nomin15} typ_lib_name] || \
#@                        [regsub {_MAX} $lib_name {_TYP} typ_lib_name] ) } {
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set typ_lib_name_from_file($lib_file) $typ_lib_name
#@                 }
#@             } elseif {[string match TSMC13* $technology]} {
#@                 regsub {_wc$} $lib_name {} lib_name
#@                 regsub {_[0-9]+$} $lib_name {} lib_name
#@                 if { ( [regsub {_wc\.db$} $lib_file {_bc.db} min_lib_file] || \
#@                        [regsub {_[0-9]+\.db$} $lib_file {ff\0} min_lib_file] ) && \
#@                      ( [regsub {_wc\.db$} $lib_file {_tt.db} typ_lib_file] || \
#@                        [regsub {_[0-9]+\.db$} $lib_file {tt\0} typ_lib_file] ) } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                 }
#@                 if { ( [regsub {_wc$} $lib_name {_bc} min_lib_name] || \
#@                        [regsub {_[0-9]+$} $lib_name {ff\0} min_lib_name] ) && \
#@                      ( [regsub {_wc$} $lib_name {_tt} typ_lib_name] || \
#@                        [regsub {_[0-9]+$} $lib_name {tt\0} typ_lib_name] ) } {
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set typ_lib_name_from_file($lib_file) $typ_lib_name
#@                 }
#@             } elseif {[string match TSMC09* $technology]} {
#@                 regsub {\.ss} $lib_name {} lib_name
#@             } elseif {[string match TSMC65LP* $technology]} {
#@                 regsub {ss} $lib_name {} lib_name
#@                 regsub {_[0-9]$} $lib_name {} lib_name
#@                 regsub {v2003.03_} $lib_name {ss} lib_name
#@                 regsub {v2004.06_} $lib_name {ss} lib_name
#@ 
#@                 # HSTL library file now bears no resemblance to library name
#@                 if {$lib_name == {SS108125_IO297}} {
#@                     set lib_name tsmc65lpiof60_[string tolower $lib_name]
#@                 }
#@ 
#@                 # SPONG: Using WCF 125C for typ to view worst case power
#@                 if { [regsub {ss108125} [regsub {ss/} $lib_file {ff/}] {ff129-40} min_lib_file] && \
#@                      [regsub {ss108125} [regsub {ss/} $lib_file {ff/}] {ff129125} typ_lib_file] && \
#@                      [regsub {ss108125} [regsub {ss/} $lib_file {ff/}] {ff129125} bch_lib_file] && \
#@                      [regsub {ss108125} $lib_file {ss108-40} wcc_lib_file] } {
#@                     regsub io297 $min_lib_file io363 min_lib_file
#@                     regsub io297 $bch_lib_file io363 bch_lib_file
#@                     regsub io297 $typ_lib_file io363 typ_lib_file
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                     set wcc_lib_files($lib_file) $wcc_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 } elseif { [regsub {125_ss\.} $lib_file {-40_ff.} min_lib_file] && \
#@                            [regsub {125_ss\.} $lib_file {125_ff.} bch_lib_file] && \
#@                            [regsub {125_ss\.} $lib_file {-40_ss.} wcc_lib_file]} {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                     set wcc_lib_files($lib_file) $wcc_lib_file
#@                 } elseif { [regsub {bisted_wc\.} $lib_file {bisted_bc.} min_lib_file] && \
#@                            [regsub {bisted_wc\.} $lib_file {bisted_bc.} bch_lib_file]} {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 } elseif { [regsub {MIDLMINDLY_wc\.} $lib_file {MIDLMINDLY_bc.} min_lib_file] && \
#@                            [regsub {MIDLMINDLY_wc\.} $lib_file {MIDLMINDLY_bc.} bch_lib_file]} {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 } elseif { [regsub {_ss\.} $lib_file {_ff.} min_lib_file] && \
#@                            [regsub {_ss\.} $lib_file {_ff.} typ_lib_file] && \
#@                            [regsub {_ss\.} $lib_file {_ff.} bch_lib_file]} {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                 } elseif { [regsub {SS108125} [regsub {SS/} $lib_file {FF/}] {FF129-40} min_lib_file] && \
#@                            [regsub {SS108125} [regsub {SS/} $lib_file {FF/}] {FF129125} typ_lib_file] && \
#@                            [regsub {SS108125} [regsub {SS/} $lib_file {FF/}] {FF129125} bch_lib_file] && \
#@                            [regsub {SS108125}  $lib_file {SS108-40} wcc_lib_file] } {
#@                     # Because broadcom are such bodgers ...
#@                     regsub IO297 $min_lib_file IO363 min_lib_file
#@                     regsub IO297 $bch_lib_file IO363 bch_lib_file
#@                     regsub IO297 $typ_lib_file IO363 typ_lib_file
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                     set wcc_lib_files($lib_file) $wcc_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 }
#@                 
#@                 # Just because broadcom are such bodgers .. min file post porocessing TO BE FIXED SHOULD BE 129-40
#@                 if { [regsub {LPL_TG2_ff129-40} $min_lib_file {LPL_TG2_ff132-40} min_lib_file] && \
#@                      [regsub {LPL_TG2_ff129125} $typ_lib_file {LPL_TG2_ff132-40} typ_lib_file] } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                 }
#@                 if {[info exists wcc_lib_file]} {
#@                     if { [regsub {LPL_TG2_ss108-40} $wcc_lib_file {LPL_TG2_ss108125} wcc_lib_file] } {
#@                         set wcc_lib_files($lib_file) $wcc_lib_file
#@                     }
#@                 }
#@                 if {[info exists bch_lib_file]} {
#@                     if { [regsub {LPL_TG2_ff129125} $bch_lib_file {LPL_TG2_ff132-40} bch_lib_file] } {
#@                         set bch_lib_files($lib_file) $bch_lib_file
#@                     }
#@                 }
#@                 
#@                 if { ( [regsub {_108125}  $lib_name {ff_129-40} min_lib_name] && \
#@                        [regsub {_108125}  $lib_name {_108-40} wcc_lib_name] && \
#@                        [regsub {_108125}  $lib_name {ff_129125} bch_lib_name] && \
#@                        [regsub {_108125}  $lib_name {ff_129125} typ_lib_name] ) || \
#@                      ( [regsub {ss108125_io297} $lib_name {ff129-40_io363} min_lib_name] && \
#@                        [regsub {ss108125_io297} $lib_name {ff129125_io363} typ_lib_name] ) } {
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set typ_lib_name_from_file($lib_file) $typ_lib_name
#@                     set wcc_lib_name_from_file($lib_file) $wcc_lib_name
#@                     set bch_lib_name_from_file($lib_file) $bch_lib_name
#@                 }
#@             } elseif {[string match TSMC40G* $technology]} {
#@                 regsub {v2004.06_} $lib_name {} lib_name
#@ 
#@                 if { ( [regsub {(allG40.*_tsmc40g?_)(ss081125)} [regsub {ss/} $lib_file {ff/}] {\1ff105-40} min_lib_file] && \
#@                        [regsub {(allG40.*_tsmc40g?_)(ss081125)} [regsub {ss/} $lib_file {ff/}] {\1ff105125} typ_lib_file] ) || \
#@                      ( [regsub {(allG40.*_tsmc40g?_)(ss081-40)} [regsub {ss/} $lib_file {ff/}] {\1ff097-40} min_lib_file] && \
#@                        [regsub {(allG40.*_tsmc40g?_)(ss081-40)} [regsub {ss/} $lib_file {ff/}] {\1ff097125} typ_lib_file] ) || \
#@                      ( [regsub (allG40.*_tsmc40g?_)(ss090${max_corner_temp}) [regsub {ss/} $lib_file {ff/}] {\1ff105-40} min_lib_file] && \
#@                        [regsub (allG40.*_tsmc40g?_)(ss090${max_corner_temp}) [regsub {ss/} $lib_file {ff/}] {\1ff105125} bch_lib_file] && \
#@                        [regsub (allG40.*_tsmc40g?_)(ss090${max_corner_temp}) $lib_file {\1ss090-40} wcc_lib_file] && \
#@                        [regsub (allG40.*_tsmc40g?_)(ss090-40) [regsub {ss/} $lib_file {ff/}] {\1ff105125} typ_lib_file] ) || \
#@                      ( [regsub {bcm40gfdr_(ss081125|ss081-40)} $lib_file {bcm40gfdr_ff099-40} min_lib_file] && \
#@                        [regsub {bcm40gfdr_(ss081125|ss081-40)} $lib_file {bcm40gfdr_ff099125} typ_lib_file] ) || \
#@                      ( [regsub {ss081125|ss081-40} $lib_file {ff097-40} min_lib_file] && \
#@                        [regsub {ss081125|ss081-40} $lib_file {ff097125} typ_lib_file] ) || \
#@                      ( [regsub ss090${max_corner_temp} $lib_file {ff105-40} min_lib_file] && \
#@                        [regsub ss090${max_corner_temp} $lib_file {ff105125} bch_lib_file] && \
#@                        [regsub ss090${max_corner_temp} $lib_file {ss090-40} wcc_lib_file] && \
#@                        [regsub ss090${max_corner_temp} $lib_file {ff105125} typ_lib_file] ) || \
#@                      ( [regsub SS090${max_corner_temp} $lib_file {FF105-40} min_lib_file] && \
#@                        [regsub SS090${max_corner_temp} $lib_file {FF105125} bch_lib_file] && \
#@                        [regsub SS090${max_corner_temp} $lib_file {SS090-40} wcc_lib_file] && \
#@                        [regsub SS090${max_corner_temp} $lib_file {FF105125} typ_lib_file] ) || \
#@                      ( [regsub {125_ss} $lib_file {-40_ff} min_lib_file] && \
#@                        [regsub {125_ss} $lib_file {-40_ff} bch_lib_file] && \
#@                        [regsub {125_ss} $lib_file {125_ss} wcc_lib_file] ) || \
#@                      ( [regsub {NP_ss} $lib_file {NP_ff} min_lib_file] && \
#@                        [regsub {NP_ss} $lib_file {NP_ff} bch_lib_file] && \
#@                        [regsub {NP_ss} $lib_file {NP_ff} typ_lib_file] && \
#@                        [regsub {NP_ss} $lib_file {NP_ss} wcc_lib_file] )   || \
#@                      ( [regsub {FC_ss} $lib_file {FC_ff} min_lib_file] && \
#@                        [regsub {FC_ss} $lib_file {FC_ff} bch_lib_file] && \
#@                        [regsub {FC_ss} $lib_file {FC_ff} typ_lib_file] && \
#@                        [regsub {FC_ss} $lib_file {FC_ss} wcc_lib_file] )   || \
#@                      ( [regsub ss090${max_corner_temp} [regsub {ss/} $lib_file {ff/}] {ff105-40} min_lib_file] && \
#@                        [regsub ss090${max_corner_temp} $lib_file {ss090-40} wcc_lib_file] && \
#@                        [regsub ss090${max_corner_temp} [regsub {ss/} $lib_file {ff/}] {ff105125} bch_lib_file] && \
#@                        [regsub ss090${max_corner_temp} [regsub {ss/} $lib_file {ff/}] {ff105125} typ_lib_file] ) || \
#@                      ( [regsub SS090${max_corner_temp} [regsub {ss/} $lib_file {ff/}] {FF105-40} min_lib_file] && \
#@                        [regsub SS090${max_corner_temp} $lib_file {SS090-40} wcc_lib_file] && \
#@                        [regsub SS090${max_corner_temp} [regsub {ss/} $lib_file {ff/}] {FF105125} bch_lib_file] && \
#@                        [regsub SS090${max_corner_temp} [regsub {ss/} $lib_file {ff/}] {FF105125} typ_lib_file] )} {
#@                     regsub io297 $min_lib_file io363 min_lib_file
#@                     regsub io297 $typ_lib_file io363 typ_lib_file
#@                     regsub IO297 $min_lib_file IO363 min_lib_file
#@                     regsub IO297 $typ_lib_file IO363 typ_lib_file
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                     if {[info exists bch_lib_file]} {
#@                         regsub io297 $bch_lib_file io363 bch_lib_file
#@                         regsub IO297 $bch_lib_file IO363 bch_lib_file
#@                         set bch_lib_files($lib_file) $bch_lib_file
#@                     }
#@                     if {[info exists wcc_lib_file]} {
#@                         set wcc_lib_files($lib_file) $wcc_lib_file
#@                     }
#@                 } elseif { ( [regsub (NLDL.*)_${max_corner_oc}\. [regsub {ss/} $lib_file {ff/}] {\1_bc.}      min_lib_file] && \
#@                              [regsub (NLDL.*)_${max_corner_oc}\. $lib_file                      {\1_wc_cold.} wcc_lib_file] && \
#@                              [regsub (NLDL.*)_${max_corner_oc}\. [regsub {ss/} $lib_file {ff/}] {\1_bc_hot.}  bch_lib_file]) } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set wcc_lib_files($lib_file) $wcc_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 } elseif { ( [regsub (NLDL.*)_ss(_cold)?\.               [regsub {ss/} $lib_file {ff/}] {\1_ff.}      min_lib_file] && \
#@                              [regsub (NLDL.*)_ss(_cold)?\.               $lib_file                      {\1_ss_cold.} wcc_lib_file] && \
#@                              [regsub (NLDL.*)_ss(_cold)?\.               [regsub {ss/} $lib_file {ff/}] {\1_ff_hot.}  bch_lib_file]) } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set wcc_lib_files($lib_file) $wcc_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 } elseif { ( [regsub {_ss.db} [regsub {ss/} $lib_file {ff/}] {_ff.db} min_lib_file] && \
#@                              [regsub {_ss.db} [regsub {ss/} $lib_file {ff/}] {_ff.db} bch_lib_file]) } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set bch_lib_files($lib_file) $bch_lib_file
#@                 }
#@                 
#@                 if {[regexp {^(tsmc40giofd[3r]_)(.*)$} $lib_name {} prefix suffix]} {
#@                     set lib_name $prefix[string tolower $suffix]
#@                 }
#@ 
#@                 if { ( [regsub {ss081125|ss081-40} $lib_name {ff097-40} min_lib_name] && \
#@                        [regsub {ss081125|ss081-40} $lib_name {ff097125} typ_lib_name] ) || \
#@                      ( [regsub ss090${max_corner_temp} $lib_name {ff105-40} min_lib_name] && \
#@                        [regsub ss090${max_corner_temp} $lib_name {ss090-40} wcc_lib_name] && \
#@                        [regsub ss090${max_corner_temp} $lib_name {ff105125} bch_lib_name] && \
#@                        [regsub ss090${max_corner_temp} $lib_name {ff105125} typ_lib_name] ) } {
#@                     regsub io297 $min_lib_name io363 min_lib_name
#@                     regsub io297 $typ_lib_name io363 typ_lib_name
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set typ_lib_name_from_file($lib_file) $typ_lib_name
#@                     if {[info exists bch_lib_name]} {
#@                         regsub io297 $bch_lib_name io363 bch_lib_name
#@                         set bch_lib_name_from_file($lib_file) $bch_lib_name
#@                     }
#@                     if {[info exists wcc_lib_name]} {
#@                         set wcc_lib_name_from_file($lib_file) $wcc_lib_name
#@                     }
#@                 } elseif { [regsub {_wc.} $lib_name {_bc.} min_lib_name] && \
#@                            [regsub {_wc.} $lib_name {_bc.} bch_lib_name] } {
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set bch_lib_name_from_file($lib_file) $bch_lib_name
#@                 } elseif { [regsub {_ss.db} $lib_name {_ff.db} min_lib_name] && \
#@                             [regsub {_ss.db} $lib_name {_ff.db} bch_lib_name] } {
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set bch_lib_name_from_file($lib_file) $bch_lib_name
#@                 }
#@                 
#@             } elseif {[string match artisan $technology]} {
#@                 if { [regsub {slow} $lib_file {fast} min_lib_file] && \
#@                      [regsub {slow} $lib_file {typical} typ_lib_file] } {
#@                     set min_lib_files($lib_file) $min_lib_file
#@                     set typ_lib_files($lib_file) $typ_lib_file
#@                 }
#@                 if { [regsub {slow} $lib_name {fast} min_lib_name] && \
#@                      [regsub {slow} $lib_name {typical} typ_lib_name] } {
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                     set typ_lib_name_from_file($lib_file) $typ_lib_name
#@                 }
#@             } elseif {[string match CU08* $technology]} {
#@                 regsub {_V090T125Pwc} $lib_name {} lib_name
#@             } elseif {[string match COR* $technology]} {
#@                 regsub {_Worst} $lib_name {} lib_name
#@             } elseif {[string match SC9WT* $technology]} {
#@                 # The compiled library name doesn't contain the 2003.06-SP1 (that is just in the filename)
#@                 regsub {.2003.06-SP1} $lib_name {} lib_name
#@ 
#@                 if {[regexp {q\d?chip} $chip_name]} {
#@                     # For now, we are always going to use the non-2003.06 libs for min libraries
#@                     regsub {.2003.06-SP1} $lib_file {} min_lib_file
#@                     if { [regsub {SLOW_125_0P9} $min_lib_file {FAST_M40_1P1} min_lib_file] } {
#@                         set min_lib_files($lib_file) $min_lib_file
#@                     }
#@                     if { [regsub {SLOW_125_0P9} $lib_name {FAST_M40_1P1} min_lib_name] } {
#@                         set min_lib_name_from_file($lib_file) $min_lib_name
#@                     }
#@                 }
#@ 
#@                 if {$chip_name == {npchip} && $suffix03_6 == {}} {
#@                     if { [regsub {SLOW_125_0P9} $lib_file {FAST_M40_1P1} min_lib_file] || \
#@                          [regsub {slow_125_0.9} $lib_file {fast_-40_1.1} min_lib_file] } {
#@                         set min_lib_files($lib_file) $min_lib_file
#@                     }
#@                     if { [regsub {SLOW_125_0P9} $lib_name {FAST_M40_1P1} min_lib_name] || \
#@                          [regsub {slow_125_0.9} $lib_name {fast_-40_1.1} min_lib_name] } {
#@                         set min_lib_name_from_file($lib_file) $min_lib_name
#@                     }
#@                 }
#@             } elseif {[string match AV16* $technology]} {
#@                 if {$av16_library_version_number == 0} {
#@                     regsub {_native} $lib_name {} lib_name
#@                     regsub {_slow} $lib_name {_ss} lib_name
#@                 }
#@ 
#@                 if {[regsub -all {_slowg_0c_0p72v} $lib_file {_fast_0c_0p88v} min_lib_file]} {
#@                     # set min_lib_files($lib_file) [regsub {_0p72v} $min_lib_file {_0p88v}]
#@                     set min_lib_files($lib_file) $min_lib_file
#@                 } elseif {[regsub -all {_slow} $lib_file {_fast} min_lib_file]} {
#@                     if {$av16_library_version_number == 2} {
#@                         regsub {svs} $min_lib_file {hod} min_lib_file
#@                     }
#@                     
#@                     regsub {rc_wc} $min_lib_file {rc_bc} min_lib_file
#@                     
#@                     set min_lib_files($lib_file) [regsub {_ss} $min_lib_file {_ff}]
#@                 } elseif {[regsub {_ss} $lib_file {_ff} min_lib_file]} {
#@                     if {$av16_library_version_number == 2} {
#@                         regsub {svs} $min_lib_file {hod} min_lib_file
#@                     }
#@                     set min_lib_files($lib_file) $min_lib_file
#@                 }
#@                 if {[regsub {_slowg_0c_0p72v} $lib_name {_fast_0c_p88v} min_lib_name]} {
#@                     # set min_lib_name_from_file($lib_file) [regsub {_0p72v} $min_lib_name {_0p88v}]
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                 } elseif {[regsub {_ss} $lib_name {_ff} min_lib_name]} {
#@                     if {$av16_library_version_number == 2} {
#@                         regsub {svs} $min_lib_name {hod} min_lib_name
#@                     }
#@                     set min_lib_name_from_file($lib_file) [regsub {_slow} $min_lib_name {_fast}]
#@                 }
#@             } elseif {[string match TSMC7FF* $technology] || [string match TSMC5FF* $technology] || [string match TSMC3FF* $technology]} {
#@                 set verbose [regexp {bc} $type]
#@ 
#@                 # Standard cells - and some IP (Min libs are bc_cold, or the closest we can get to that)
#@                 set min_lib_file   $lib_file
#@                 regsub {_pssg_}    $min_lib_file {_pffg_}    min_lib_file
#@                 regsub {_v0670_}   $min_lib_file {_v0830_}   min_lib_file
#@                 regsub {_t000_}    $min_lib_file {_t-40_}    min_lib_file
#@                 regsub {_xcwccw}   $min_lib_file {_xcbccb}   min_lib_file
#@                 #RAMS and sd07sbus_master_05*
#@                 regsub {_xrcwccwt} $min_lib_file {_xrcbccbt} min_lib_file
#@                 #phy07p_(HBM2e|MAX)*
#@                 regsub {_o1140}    $min_lib_file {_o1260}    min_lib_file 
#@                 #BCM7FFPX22D18APD_*
#@                 regsub {_o1620_}   $min_lib_file {_o1980_}   min_lib_file
#@                 #BCM7FFPXHSTL_PMNH_PVT15_DRV
#@                 regsub {_o1350_}   $min_lib_file {_o1650_}   min_lib_file
#@ 
#@                 if { [regexp {^phy07p_(HBM2e|MAX)} $min_lib_file] } {
#@                     regsub {_xcbccbt_} $min_lib_file {_xcbccb_} min_lib_file
#@                 #RAMS still using bc_hot for bc_cold timing
#@                 } elseif { [regexp {PM7.*X.*VT} $min_lib_file] } {
#@                     regsub {_t\d+_} $min_lib_file {_t125_} min_lib_file
#@                 }
#@                 # fcx2_top cold ram lib sometimes delivered separately by avago
#@                 if { [regexp {PM7SC111HC1024X18R20211VTLUS11LLEBCH20Q} $min_lib_file] } {
#@                     if { [glob -nocomplain {PM7SC111HC1024X18R20211VTLUS11LLEBCH20Q*_pffg_*_t-40_*.db}] != {} } {
#@                         regsub {_t\d+_} $min_lib_file {_t-40_} min_lib_file
#@                     } else {
#@                         puts "Note: Special fcx2_top cold mem model not found for '$min_lib_file'"
#@                     }
#@                 }
#@                 if {[string match TSMC5FF* $technology] && $STD_CELL_LIBS_VERSION <= 210106 && [string match tsmc5ff_* $lib_file]} {
#@                     regsub {_t-40_} $min_lib_file {_t125_} min_lib_file
#@                 }
#@                 if {([string match TSMC5FF* $technology] && $STD_CELL_LIBS_VERSION > 210106) || [string match TSMC3FF* $technology]} {
#@                     regsub {_t-40_} $min_lib_file {_t000_} min_lib_file
#@                 }
#@                 
#@                 if { $verbose } { echo "Best case cold match - $lib_file -> $min_lib_file" }
#@                 set min_lib_files($lib_file) $min_lib_file
#@ 
#@                 # And patch up the library names
#@                 # This is only used for the tech library so far
#@                 if {[regsub {pssg_s(250|300)_v0670_t000_xcwccwt} $lib_name {pffg_s\1_v0830_t-40_xcbccbt} min_lib_name]} {
#@                     if {[string match TSMC5FF* $technology] && $STD_CELL_LIBS_VERSION <= 210106 && [string match tsmc5ff_* $lib_file]} {
#@                         regsub {_t-40_} $min_lib_name {_t125_} min_lib_name
#@                     }
#@                     if {([string match TSMC5FF* $technology] && $STD_CELL_LIBS_VERSION > 210106) || [string match TSMC3FF* $technology]} {
#@                         regsub {_t-40_} $min_lib_name {_t000_} min_lib_name
#@                     }
#@                     set min_lib_name_from_file($lib_file) $min_lib_name
#@                 } elseif { [regsub {_ss} $lib_name {_ff} min_lib_name] } {
#@                   # set min_lib_name_from_file($lib_file) [regsub {_slow} $min_lib_name {_fast}]
#@                 }
#@                 
#@                 ############################
#@                 #
#@                 # BC Hot libraries
#@                 
#@                 regsub {_t-?[\d]+_}    $min_lib_file {_t125_}    bch_lib_file
#@ 
#@                 if { $verbose } { echo "Best case hot match - $lib_file -> $bch_lib_file" }
#@                 set bch_lib_files($lib_file) $bch_lib_file
#@ 
#@                 # And patch up the library names
#@                 # This is only used for the tech library so far
#@                 if {[regsub {pssg_s(250|300)_v0670_t000_xcwccwt} $lib_name {pffg_s\1_v0830_t125_xcbccbt} bch_lib_name]} {
#@                     set bch_lib_name_from_file($lib_file) $bch_lib_name
#@                 } elseif { [regsub {_ss} $lib_name {_ff} bch_lib_name] } {
#@                   # set bch_lib_name_from_file($lib_file) [regsub {_slow} $bch_lib_name {_fast}]
#@                 }
#@                 
#@                 ############################
#@                 #
#@                 # WC Hot libraries
#@ 
#@                 regsub {_t-?[\d]+_}    $lib_file {_t125_}    wch_lib_file
#@                 if {[string match TSMC5FF* $technology] && $STD_CELL_LIBS_VERSION <= 210106 && [string match tsmc5ff_* $lib_file]} {
#@                     regsub {_t125_} $wch_lib_file {_t000_} wch_lib_file
#@                 }
#@ 
#@                 if { $verbose } { echo "Worst case hot match - $lib_file -> $wch_lib_file" }
#@                 set wch_lib_files($lib_file) $wch_lib_file
#@ 
#@                 # And patch up the library names
#@                 if {[regsub {pssg_s(250|300)_v0670_t000_xcwccwt} $lib_name {pssg_s\1_v0670_t125_xcwccwt} wch_lib_name]} {
#@                     if {[string match TSMC5FF* $technology] && $STD_CELL_LIBS_VERSION <= 210106 && [string match tsmc5ff_* $lib_name]} {
#@                         regsub {_t125_} $wch_lib_name {_t000_} wch_lib_name
#@                     }
#@                     set wch_lib_name_from_file($lib_file) $wch_lib_name
#@                 }
#@ 
#@             }
#@             set lib_name_from_file($lib_file) $lib_name
#@             set file_from_lib_name($lib_name) $lib_file
#@             if {! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}} {
#@                 set library($lib_name) $lib_file:$lib_name
#@             } else {
#@                 set library($lib_name) $lib_name
#@             }
#@             set file_and_library($lib_name) $lib_file:$lib_name
#@         }
#@         if {[info exists tech_library] && ! [info exists tech_library_file]} {
#@             set tech_library_file $file_from_lib_name($tech_library)
#@         }
#@         if {[info exists tech_io_library] && ! [info exists tech_io_library_file]} {
#@             set tech_io_library_file $file_from_lib_name($tech_io_library)
#@         }
#@         
#@         if {$technology != "none" && $technology != {}} {
#@             set orig_tech_library $tech_library
#@         }
#@             
#@         foreach oc {min typ wcc bch wch} {
#@             if {[info exists only_use_${oc}_library] && [set only_use_${oc}_library] == {true}} {
#@                 set old_link_library $link_library
#@                 set link_library {}
#@                 foreach lib_file $old_link_library {
#@                     if {[info exists ${oc}_lib_files($lib_file)]} {
#@                         lappend link_library [set ${oc}_lib_files($lib_file)]
#@                         if {! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}} {
#@                             if {[info exists ${oc}_lib_name_from_file($lib_file)]} {
#@                                 set library($lib_name_from_file($lib_file))          [set ${oc}_lib_files($lib_file)]:[set ${oc}_lib_name_from_file($lib_file)]
#@                                 set library([set ${oc}_lib_name_from_file($lib_file)]) [set ${oc}_lib_files($lib_file)]:[set ${oc}_lib_name_from_file($lib_file)]
#@                             } else {
#@                                 set library($lib_name_from_file($lib_file)) [set ${oc}_lib_files($lib_file)]:$lib_name_from_file($lib_file)
#@                             }
#@                         } else {
#@                             if {[info exists ${oc}_lib_name_from_file($lib_file)]} {
#@                                 set library($lib_name_from_file($lib_file))          [set ${oc}_lib_name_from_file($lib_file)]
#@                                 set library([set ${oc}_lib_name_from_file($lib_file)]) [set ${oc}_lib_name_from_file($lib_file)]
#@                             }
#@                         }
#@                         if {[info exists ${oc}_lib_name_from_file($lib_file)]} {
#@                             set file_and_library($lib_name_from_file($lib_file))          [set ${oc}_lib_files($lib_file)]:[set ${oc}_lib_name_from_file($lib_file)]
#@                             set file_and_library([set ${oc}_lib_name_from_file($lib_file)]) [set ${oc}_lib_files($lib_file)]:[set ${oc}_lib_name_from_file($lib_file)]
#@                         } else {
#@                             set file_and_library($lib_name_from_file($lib_file)) [set ${oc}_lib_files($lib_file)]:$lib_name_from_file($lib_file)
#@                         }
#@                     } else {
#@                         lappend link_library $lib_file
#@                     }
#@                 }
#@ 
#@                 if { [info exists ${oc}_lib_name_from_file($tech_library_file)] } {
#@                     set tech_library [set ${oc}_lib_name_from_file($tech_library_file)]
#@                 }
#@                 set tech_library_file [set ${oc}_lib_files($tech_library_file)]
#@                 if {[info exists tech_io_library_file]} {
#@                     set tech_io_library_file [set ${oc}_lib_files($tech_io_library_file)]
#@                 }
#@                 # Also fix the target_library list to allow run_router to work for timing reports -- SS 13.09.06
#@                 set old_target_library $target_library
#@                 set target_library {}
#@                 foreach tlib $old_target_library {
#@                     if { [info exists ${oc}_lib_files($tlib)] } {                
#@                         lappend target_library [set ${oc}_lib_files($tlib)]
#@                     } else {
#@                         puts "Warning: Couldn't find ${oc} version of target_library $tlib"
#@                     }
#@                 }
#@                 # And even fix the tech_file_and_libraries list
#@                 set original_tech_file_and_libraries $tech_file_and_libraries
#@                 set tech_file_and_libraries {}
#@                 foreach fandl $original_tech_file_and_libraries {
#@                     # Non greedy match I hope
#@                     regexp {(.*):(.*)} $fandl match lib_file lib_name
#@                     if { [info exists ${oc}_lib_name_from_file($lib_file)] } {
#@                         set lib_name [set ${oc}_lib_name_from_file($lib_file)]
#@                     }
#@                     set lib_file [set ${oc}_lib_files($lib_file)]
#@                     lappend tech_file_and_libraries $lib_file:$lib_name
#@                 }
#@                 set dont_use_min_library true
#@                 if { $oc == {min} } {
#@                     set dont_use_min_library false
#@                 }
#@                 break
#@             }
#@         }
#@ 
#@         if {[info exists synopsys_program_name] && $synopsys_program_name == {pt_shell}} {
#@             set lib_files [lrange $link_library 1 end]
#@         } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {fm_shell}} {
#@             set lib_files $link_library
#@         } elseif { [info exists synopsys_program_name] && ($synopsys_program_name == {dc_shell} || $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui}) && \
#@                    [info exists sh_product_version] && [regexp -inline {20\d\d} $sh_product_version] >= 2008 } {
#@             set lib_files standard.sldb
#@             set xg_mode 1
#@             set physical_library {}
#@         } elseif { ( ( (! [info exists synopsys_program_name] || $synopsys_program_name == {dc_shell}) && \
#@                        [info exists sh_product_version] && \
#@                        [string match *2004.06-SP2* $sh_product_version] ) || \
#@                      ( (! [info exists synopsys_program_name] || $synopsys_program_name == {dc_shell} || $synopsys_program_name == {psyn_shell} || $synopsys_program_name == {psyn_gui}) && \
#@                        [info exists sh_product_version] && \
#@                        [regexp -inline {20\d\d.\d\d} $sh_product_version] >= 2004.12 ) ) && \
#@                    [shell_is_in_xg_mode] } {
#@             set lib_files standard.sldb
#@             set xg_mode 1
#@             set physical_library {}
#@         } else {
#@             set lib_files [concat gtech.db [lrange $link_library 1 end] standard.sldb]
#@         }
#@         
#@         foreach lib_file $lib_files {
#@             if { ! [info exists synopsys_program_name] || 
#@                  ( [info exists dont_read_link_libraries] && $dont_read_link_libraries) } {
#@             } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {milkyway}} {
#@             } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {lc_shell}} {
#@             } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {fm_shell}} {
#@                 if {[regexp {q\d?chip} $chip_name] && [info exists script_name] && $script_name == {fm_verify}} {
#@                 } elseif {$lib_file != {*}} {
#@                     read_db $lib_file
#@                 }
#@             } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {tmax_tcl}} {
#@             } elseif {[info exists synopsys_program_name] && ($synopsys_program_name == {icc2_lm_shell} || $synopsys_program_name == {lm_shell})} {
#@             } elseif { [info exists min_lib_files($lib_file)] && \
#@                        ( ! [info exists dont_use_min_library] || $dont_use_min_library != {true} ) } {
#@                 if { ! [info exists synopsys_program_name] || \
#@                      $synopsys_program_name != {pt_shell} || \
#@                      ! [string match 2000.11* $sh_product_version]} {
#@                     if { [string match $lib_file $min_lib_files($lib_file)] } {
#@                         # Do nothing if min and max are the same
#@                     } else {
#@                         set cmd "set_min_library $lib_file -min_version $min_lib_files($lib_file)"
#@                         echo "here"
#@                         echo $cmd
#@                         eval $cmd
#@                         lappend set_min_library_commands $cmd
#@                     }
#@                 } else {
#@                     if {[string match TSMC* $technology]} {
#@                         if { [string match {*misc*} $lib_file] || [string match {*io*} $lib_file] } {
#@                             set max_operating_condition WCIND 
#@                             set min_operating_condition BCIND
#@                         } else {
#@                             set max_operating_condition WCIND_WCT 
#@                             set min_operating_condition BCIND
#@                         }
#@                         read_min_max_lib -min $min_lib_files($lib_file) -max $lib_file -name $lib_name_from_file($lib_file) \
#@                                          -min_operating_condition BCIND -use_min $min_operating_condition \
#@                                          -max_operating_condition WCIND_WCT -use_max $max_operating_condition
#@                     } else {
#@                         read_min_max_lib -min $min_lib_files($lib_file) -max $lib_file -name $lib_name_from_file($lib_file)
#@                     }
#@                 }
#@             } else {
#@                 suppress_message DDB-24
#@                 read_file -format db $lib_file
#@                 unsuppress_message DDB-24
#@             }
#@         }
#@ 
#@         if { [info exists synopsys_program_name] && \
#@              ( $synopsys_program_name != {pt_shell} && \
#@                $synopsys_program_name != {milkyway} && \
#@                $synopsys_program_name != {lc_shell} && \
#@                $synopsys_program_name != {fm_shell} && \
#@                $synopsys_program_name != {tmax_tcl} && \
#@                $synopsys_program_name != {icc2_lm_shell} && \
#@                $synopsys_program_name != {lm_shell} ) } {
#@                
#@             set dont_use_implementations {}
#@             
#@             set previous_suppress_errors $suppress_errors
#@             lappend suppress_errors UID-4 UID-109 SEL-003
#@             foreach outer_synthetic_library_name $synthetic_library {
#@                 foreach_in_collection module_name [find module $outer_synthetic_library_name/*] {
#@                     foreach inner_synthetic_library_name $synthetic_library {
#@                         set tmp_list [list rpl ripple rpcs]
#@                         foreach tmp $tmp_list {
#@                             set implementation_name $inner_synthetic_library_name/[get_object_name $module_name]/$tmp
#@                             if {[find implementation $implementation_name] != {}} {
#@                                 if {[remove_from_collection [find implementation $inner_synthetic_library_name/[get_object_name $module_name]/*] \
#@                                         [list [find implementation $inner_synthetic_library_name/[get_object_name $module_name]/sim] \
#@                                               [find implementation $implementation_name]]] != {}} {
#@                                     set_dont_use $implementation_name
#@                                     lappend dont_use_implementations $implementation_name
#@                                 }
#@                             }
#@                         }
#@                     }
#@                 }
#@             }
#@             set suppress_errors $previous_suppress_errors
#@ 
#@             if {$technology == {CB12}} {
#@                 set file [open $library_root/script/MUX_SCAN_TC.scr]
#@                 while {! [eof $file]} {
#@                     if {[regsub _TYP_ [gets $file] _MAX_ tmp]} {
#@                         echo $tmp
#@                         eval $tmp
#@                     }
#@                 }
#@                 close $file
#@             } elseif {[string match TC260* $technology]} {
#@                 set_dont_use [find lib_cell $tech_library_file:$tech_library/CFT*]
#@                 set_dont_use [find lib_cell $tech_library_file:$tech_library/CFD*EX*]
#@             }
#@             
#@             proc apply_tech_library_dont_use {} {
#@                 global tech_file_and_libraries
#@                 global tech_library_dont_use
#@                 global tech_library_do_use
#@                 global tech_library_really_dont_use
#@ 
#@                 if {[info exists tech_file_and_libraries]} {
#@                     foreach tmp $tech_file_and_libraries {
#@                         if {[info exists tech_library_dont_use]} {
#@                             foreach du $tech_library_dont_use {
#@                                 if {[sizeof_collection [get_lib_cells -quiet $tmp/$du]]} {
#@                                     set_dont_use [get_lib_cells $tmp/$du]
#@                                 }
#@                             }
#@                         }
#@                         if {[info exists tech_library_do_use]} {
#@                             foreach du $tech_library_do_use {
#@                                 foreach_in_collection dc [get_lib_cells -quiet $tmp/$du] {
#@                                     remove_attribute $dc dont_use
#@                                 }
#@                             }
#@                         }
#@                         if {[info exists tech_library_really_dont_use]} {
#@                             foreach du $tech_library_really_dont_use {
#@                                 if {[sizeof_collection [get_lib_cells -quiet $tmp/$du]]} {
#@                                     set_dont_use [get_lib_cells $tmp/$du]
#@                                 }
#@                             }
#@                         }
#@                     }
#@                 }
#@             }
#@ 
#@             if { ! [info exists dont_read_link_libraries] || ! $dont_read_link_libraries } {
#@                 apply_tech_library_dont_use
#@             }
#@         }
#@ 
#@         if {$topographical_mode || ([info exists synopsys_program_name] && (($xg_mode && $synopsys_program_name == {psyn_shell}) || $synopsys_program_name == {milkyway}))} {
#@             set mw_design_library $synthesis_dir/milkyway
#@             if {$synopsys_program_name == {milkyway}} {
#@                 if {[info exists mw_reference_library] && [info exists additional_mw_reference_libraries]} {
#@                     set mw_reference_library [concat $mw_reference_library $additional_mw_reference_libraries]
#@                 }
#@             } else {
#@                 if {[string match TSMC65LP* $technology]} {
#@                     if {! [info exists mw_reference_library] || $mw_reference_library == {}} {
#@                         set mw_tech_pdb [search_for_file [lindex $physical_library 0]]
#@                         regsub {\.pdb$} $mw_tech_pdb {.plib} mw_tech_plib
#@                         set mw_reference_library {}
#@                         if {[info exists additional_mw_reference_libraries]} {
#@                             set mw_reference_library [concat $mw_reference_library $additional_mw_reference_libraries]
#@                         }
#@                         if {! [file exists $mw_design_library]} {
#@                             create_mw_design -plib_file $mw_tech_plib -dont_convert_tech_pdb
#@                         }
#@                     } else {
#@                         if {[info exists additional_mw_reference_libraries]} {
#@                             set mw_reference_library [concat $mw_reference_library $additional_mw_reference_libraries]
#@                         }
#@                         if {! [file exists $mw_design_library] && [file exists $mw_max_tluplus]} {
#@                             create_mw_design -tech_file $mw_tech_file -max_tluplus $mw_max_tluplus -tf2itf_map $mw_tech2itf_map
#@                         }
#@                     }
#@                 } else {
#@                     if {$topographical_mode && [file exists $mw_design_library]} {
#@                         open_mw_lib $mw_design_library
#@                     }
#@                     if {[string match TSMC40G* $technology] || [string match AV16* $technology] || [string match TSMC7FF* $technology] || [string match TSMC5FF* $technology] || [string match TSMC3FF* $technology]} {
#@                         if {[file exists $mw_max_tluplus]} {
#@                             if {[info exists mw_tech2itf_map]} {
#@                                 set_tlu_plus_files -max_tluplus $mw_max_tluplus -tech2itf_map $mw_tech2itf_map
#@                             } else {
#@                                 set_tlu_plus_files -max_tluplus $mw_max_tluplus
#@                             }
#@                         }
#@                     }
#@                     if {$nxt_mode} {
#@                         if {[info exists additional_ndm_libraries]} {
#@                             foreach lib_name $additional_ndm_libraries {
#@                                 lappend ndm_library $lib_name
#@                             }
#@                         }
#@                         set tmp {}
#@                         if {! [info exists sh_product_version] || [regexp -inline {20\d\d} $sh_product_version] < 2022} {
#@                             lappend tmp -congestion_use_global_route true
#@                         }
#@                         if {[array get env SYNOPSYS_ICC2] != {}} {
#@                             lappend tmp -icc2_executable $env(SYNOPSYS_ICC2)/bin/icc2_shell
#@                         }
#@                         set previous_suppress_errors $suppress_errors
#@                         lappend suppress_errors DCT-429
#@                         set_icc2_options -ref_libs $ndm_library -technology $mw_tech_file {*}$tmp
#@                         set suppress_errors $previous_suppress_errors
#@                     }
#@                 }
#@             }
#@         }
#@     }
#@     
#@     set running_synopsys [info exists synopsys_program_name]
#@     
#@     set running_primetime 0
#@     set running_design_compiler 0
#@     set running_design_compiler_topographical 0
#@     set running_physical_compiler 0
#@     set running_formality 0
#@     set running_chip_architect 0
#@     if {[info exists synopsys_program_name] && $synopsys_program_name == {pt_shell}} {
#@         set running_primetime 1
#@     } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {dc_shell}} {
#@         set running_design_compiler 1
#@         if {[shell_is_in_topographical_mode]} {
#@             set running_design_compiler_topographical 1
#@         }
#@     } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {psyn_shell}} {
#@         set running_physical_compiler 1
#@     } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {milkyway}} {
#@         set running_milkyway 1
#@     } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {lc_shell}} {
#@         set running_library_compiler 1
#@     } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {fm_shell}} {
#@         set running_formality 1
#@     } elseif {[info exists synopsys_program_name] && $synopsys_program_name == {ca_shell}} {
#@         set running_chip_architect 0
#@     }
#@ 
#@     set running_genus [string match */genus [info nameofexecutable]]
#@     set running_innovus [string match */innovus [info nameofexecutable]]
#@     set running_lec [string match */lec [info nameofexecutable]]
#@     set running_cadence [expr $running_genus || $running_innovus]
#@     
#@     set done_common true
#@ 
#@     if {$running_cadence} {
#@         source2 cadence.tcl
#@     } else {
#@         proc my_find {args} {
#@             return [find {*}$args]
#@         }
#@ 
#@         proc my_get_attribute {args} {
#@             return [get_attribute {*}$args]
#@         }
#@ 
#@         proc my_set_attribute {args} {
#@             return [set_attribute {*}$args]
#@         }
#@ 
#@         proc my_create_design {args} {
#@             return [create_design {*}$args]
#@         }
#@ 
#@         proc my_index_collection {args} {
#@             return [index_collection {*}$args]
#@         }
#@     }
#@ 
#@     if {$running_lec} {
#@         proc set_hdl_option {args} {
#@             eval set_hdl_options {*}$args
#@         }
#@ 
#@         rename exit orig_exit
#@         
#@         proc exit {{exit_code 0}} {
#@             if {$exit_code == {-f}} {
#@                 orig_exit
#@             } else {
#@                 orig_exit $exit_code
#@             }
#@         }
#@     }
#@ }
#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/tm.tcl

#@ # -*- tcl -*-
#@ #
#@ # Searching for Tcl Modules. Defines a procedure, declares it as the primary
#@ # command for finding packages, however also uses the former 'package unknown'
#@ # command as a fallback.
#@ #
#@ # Locates all possible packages in a directory via a less restricted glob. The
#@ # targeted directory is derived from the name of the requested package, i.e.
#@ # the TM scan will look only at directories which can contain the requested
#@ # package. It will register all packages it found in the directory so that
#@ # future requests have a higher chance of being fulfilled by the ifneeded
#@ # database without having to come to us again.
#@ #
#@ # We do not remember where we have been and simply rescan targeted directories
#@ # when invoked again. The reasoning is this:
#@ #
#@ # - The only way we get back to the same directory is if someone is trying to
#@ #   [package require] something that wasn't there on the first scan.
#@ #
#@ #   Either
#@ #   1) It is there now:  If we rescan, you get it; if not you don't.
#@ #
#@ #      This covers the possibility that the application asked for a package
#@ #      late, and the package was actually added to the installation after the
#@ #      application was started. It shoukld still be able to find it.
#@ #
#@ #   2) It still is not there: Either way, you don't get it, but the rescan
#@ #      takes time. This is however an error case and we dont't care that much
#@ #      about it
#@ #
#@ #   3) It was there the first time; but for some reason a "package forget" has
#@ #      been run, and "package" doesn't know about it anymore.
#@ #
#@ #      This can be an indication that the application wishes to reload some
#@ #      functionality. And should work as well.
#@ #
#@ # Note that this also strikes a balance between doing a glob targeting a
#@ # single package, and thus most likely requiring multiple globs of the same
#@ # directory when the application is asking for many packages, and trying to
#@ # glob for _everything_ in all subdirectories when looking for a package,
#@ # which comes with a heavy startup cost.
#@ #
#@ # We scan for regular packages only if no satisfying module was found.
#@ 
#@ namespace eval ::tcl::tm {
#@     # Default paths. None yet.
#@ 
#@     variable paths {}
#@ 
#@     # The regex pattern a file name has to match to make it a Tcl Module.
#@ 
#@     set pkgpattern {^([_[:alpha:]][:_[:alnum:]]*)-([[:digit:]].*)[.]tm$}
#@ 
#@     # Export the public API
#@ 
#@     namespace export path
#@     namespace ensemble create -command path -subcommands {add remove list}
#@ }
#@ 
#@ # ::tcl::tm::path implementations --
#@ #
#@ #	Public API to the module path. See specification.
#@ #
#@ # Arguments
#@ #	cmd -	The subcommand to execute
#@ #	args -	The paths to add/remove. Must not appear querying the
#@ #		path with 'list'.
#@ #
#@ # Results
#@ #	No result for subcommands 'add' and 'remove'. A list of paths for
#@ #	'list'.
#@ #
#@ # Sideeffects
#@ #	The subcommands 'add' and 'remove' manipulate the list of paths to
#@ #	search for Tcl Modules. The subcommand 'list' has no sideeffects.
#@ 
#@ proc ::tcl::tm::add {args} {
#@     # PART OF THE ::tcl::tm::path ENSEMBLE
#@     #
#@     # The path is added at the head to the list of module paths.
#@     #
#@     # The command enforces the restriction that no path may be an ancestor
#@     # directory of any other path on the list. If the new path violates this
#@     # restriction an error wil be raised.
#@     #
#@     # If the path is already present as is no error will be raised and no
#@     # action will be taken.
#@ 
#@     variable paths
#@ 
#@     # We use a copy of the path as source during validation, and extend it as
#@     # well. Because we not only have to detect if the new paths are bogus with
#@     # respect to the existing paths, but also between themselves. Otherwise we
#@     # can still add bogus paths, by specifying them in a single call. This
#@     # makes the use of the new paths simpler as well, a trivial assignment of
#@     # the collected paths to the official state var.
#@ 
#@     set newpaths $paths
#@     foreach p $args {
#@ 	if {$p in $newpaths} {
#@ 	    # Ignore a path already on the list.
#@ 	    continue
#@ 	}
#@ 
#@ 	# Search for paths which are subdirectories of the new one. If there
#@ 	# are any then the new path violates the restriction about ancestors.
#@ 
#@ 	set pos [lsearch -glob $newpaths ${p}/*]
#@ 	# Cannot use "in", we need the position for the message.
#@ 	if {$pos >= 0} {
#@ 	    return -code error \
#@ 		"$p is ancestor of existing module path [lindex $newpaths $pos]."
#@ 	}
#@ 
#@ 	# Now look for existing paths which are ancestors of the new one. This
#@ 	# reverse question forces us to loop over the existing paths, as each
#@ 	# element is the pattern, not the new path :(
#@ 
#@ 	foreach ep $newpaths {
#@ 	    if {[string match ${ep}/* $p]} {
#@ 		return -code error \
#@ 		    "$p is subdirectory of existing module path $ep."
#@ 	    }
#@ 	}
#@ 
#@ 	set newpaths [linsert $newpaths 0 $p]
#@     }
#@ 
#@     # The validation of the input is complete and successful, and everything
#@     # in newpaths is either an old path, or added. We can now extend the
#@     # official list of paths, a simple assignment is sufficient.
#@ 
#@     set paths $newpaths
#@     return
#@ }
#@ 
#@ proc ::tcl::tm::remove {args} {
#@     # PART OF THE ::tcl::tm::path ENSEMBLE
#@     #
#@     # Removes the path from the list of module paths. The command is silently
#@     # ignored if the path is not on the list.
#@ 
#@     variable paths
#@ 
#@     foreach p $args {
#@ 	set pos [lsearch -exact $paths $p]
#@ 	if {$pos >= 0} {
#@ 	    set paths [lreplace $paths $pos $pos]
#@ 	}
#@     }
#@ }
#@ 
#@ proc ::tcl::tm::list {} {
#@     # PART OF THE ::tcl::tm::path ENSEMBLE
#@ 
#@     variable paths
#@     return  $paths
#@ }
#@ 
#@ # ::tcl::tm::UnknownHandler --
#@ #
#@ #	Unknown handler for Tcl Modules, i.e. packages in module form.
#@ #
#@ # Arguments
#@ #	original	- Original [package unknown] procedure.
#@ #	name		- Name of desired package.
#@ #	version		- Version of desired package. Can be the
#@ #			  empty string.
#@ #	exact		- Either -exact or ommitted.
#@ #
#@ #	Name, version, and exact are used to determine satisfaction. The
#@ #	original is called iff no satisfaction was achieved. The name is also
#@ #	used to compute the directory to target in the search.
#@ #
#@ # Results
#@ #	None.
#@ #
#@ # Sideeffects
#@ #	May populate the package ifneeded database with additional provide
#@ #	scripts.
#@ 
#@ proc ::tcl::tm::UnknownHandler {original name args} {
#@     # Import the list of paths to search for packages in module form.
#@     # Import the pattern used to check package names in detail.
#@ 
#@     variable paths
#@     variable pkgpattern
#@ 
#@     # Without paths to search we can do nothing. (Except falling back to the
#@     # regular search).
#@ 
#@     if {[llength $paths]} {
#@ 	set pkgpath [string map {:: /} $name]
#@ 	set pkgroot [file dirname $pkgpath]
#@ 	if {$pkgroot eq "."} {
#@ 	    set pkgroot ""
#@ 	}
#@ 
#@ 	# We don't remember a copy of the paths while looping. Tcl Modules are
#@ 	# unable to change the list while we are searching for them. This also
#@ 	# simplifies the loop, as we cannot get additional directories while
#@ 	# iterating over the list. A simple foreach is sufficient.
#@ 
#@ 	set satisfied 0
#@ 	foreach path $paths {
#@ 	    if {![interp issafe] && ![file exists $path]} {
#@ 		continue
#@ 	    }
#@ 	    set currentsearchpath [file join $path $pkgroot]
#@ 	    if {![interp issafe] && ![file exists $currentsearchpath]} {
#@ 		continue
#@ 	    }
#@ 	    set strip [llength [file split $path]]
#@ 
#@ 	    # Get the module files out of the subdirectories.
#@ 	    # - Safe Base interpreters have a restricted "glob" command that
#@ 	    #   works in this case.
#@ 	    # - The "catch" was essential when there was no safe glob and every
#@ 	    #   call in a safe interp failed; it is retained only for corner
#@ 	    #   cases in which the eventual call to glob returns an error.
#@ 
#@ 	    catch {
#@ 		# We always look for _all_ possible modules in the current
#@ 		# path, to get the max result out of the glob.
#@ 
#@ 		foreach file [glob -nocomplain -directory $currentsearchpath *.tm] {
#@ 		    set pkgfilename [join [lrange [file split $file] $strip end] ::]
#@ 
#@ 		    if {![regexp -- $pkgpattern $pkgfilename --> pkgname pkgversion]} {
#@ 			# Ignore everything not matching our pattern for
#@ 			# package names.
#@ 			continue
#@ 		    }
#@ 		    try {
#@ 			package vcompare $pkgversion 0
#@ 		    } on error {} {
#@ 			# Ignore everything where the version part is not
#@ 			# acceptable to "package vcompare".
#@ 			continue
#@ 		    }
#@ 
#@ 		    if {([package ifneeded $pkgname $pkgversion] ne {})
#@ 			    && (![interp issafe])
#@ 		    } {
#@ 			# There's already a provide script registered for
#@ 			# this version of this package.  Since all units of
#@ 			# code claiming to be the same version of the same
#@ 			# package ought to be identical, just stick with
#@ 			# the one we already have.
#@ 			# This does not apply to Safe Base interpreters because
#@ 			# the token-to-directory mapping may have changed.
#@ 			continue
#@ 		    }
#@ 
#@ 		    # We have found a candidate, generate a "provide script"
#@ 		    # for it, and remember it.  Note that we are using ::list
#@ 		    # to do this; locally [list] means something else without
#@ 		    # the namespace specifier.
#@ 
#@ 		    # NOTE. When making changes to the format of the provide
#@ 		    # command generated below CHECK that the 'LOCATE'
#@ 		    # procedure in core file 'platform/shell.tcl' still
#@ 		    # understands it, or, if not, update its implementation
#@ 		    # appropriately.
#@ 		    #
#@ 		    # Right now LOCATE's implementation assumes that the path
#@ 		    # of the package file is the last element in the list.
#@ 
#@ 		    package ifneeded $pkgname $pkgversion \
#@ 			"[::list package provide $pkgname $pkgversion];[::list source -encoding utf-8 $file]"
#@ 
#@ 		    # We abort in this unknown handler only if we got a
#@ 		    # satisfying candidate for the requested package.
#@ 		    # Otherwise we still have to fallback to the regular
#@ 		    # package search to complete the processing.
#@ 
#@ 		    if {($pkgname eq $name)
#@ 			    && [package vsatisfies $pkgversion {*}$args]} {
#@ 			set satisfied 1
#@ 
#@ 			# We do not abort the loop, and keep adding provide
#@ 			# scripts for every candidate in the directory, just
#@ 			# remember to not fall back to the regular search
#@ 			# anymore.
#@ 		    }
#@ 		}
#@ 	    }
#@ 	}
#@ 
#@ 	if {$satisfied} {
#@ 	    return
#@ 	}
#@     }
#@ 
#@     # Fallback to previous command, if existing.  See comment above about
#@     # ::list...
#@ 
#@     if {[llength $original]} {
#@ 	uplevel 1 $original [::linsert $args 0 $name]
#@     }
#@ }
#@ 
#@ # ::tcl::tm::Defaults --
#@ #
#@ #	Determines the default search paths.
#@ #
#@ # Arguments
#@ #	None
#@ #
#@ # Results
#@ #	None.
#@ #
#@ # Sideeffects
#@ #	May add paths to the list of defaults.
#@ 
#@ proc ::tcl::tm::Defaults {} {
#@     global env tcl_platform
#@ 
#@     regexp {^(\d+)\.(\d+)} [package provide Tcl] - major minor
#@     set exe [file normalize [info nameofexecutable]]
#@ 
#@     # Note that we're using [::list], not [list] because [list] means
#@     # something other than [::list] in this namespace.
#@     roots [::list \
#@ 	    [file dirname [info library]] \
#@ 	    [file join [file dirname [file dirname $exe]] lib] \
#@ 	    ]
#@ 
#@     if {$tcl_platform(platform) eq "windows"} {
#@ 	set sep ";"
#@     } else {
#@ 	set sep ":"
#@     }
#@     for {set n $minor} {$n >= 0} {incr n -1} {
#@ 	foreach ev [::list \
#@ 			TCL${major}.${n}_TM_PATH \
#@ 			TCL${major}_${n}_TM_PATH \
#@         ] {
#@ 	    if {![info exists env($ev)]} continue
#@ 	    foreach p [split $env($ev) $sep] {
#@ 		path add $p
#@ 	    }
#@ 	}
#@     }
#@     return
#@ }
#@ 
#@ # ::tcl::tm::roots --
#@ #
#@ #	Public API to the module path. See specification.
#@ #
#@ # Arguments
#@ #	paths -	List of 'root' paths to derive search paths from.
#@ #
#@ # Results
#@ #	No result.
#@ #
#@ # Sideeffects
#@ #	Calls 'path add' to paths to the list of module search paths.
#@ 
#@ proc ::tcl::tm::roots {paths} {
#@     regexp {^(\d+)\.(\d+)} [package provide Tcl] - major minor
#@     foreach pa $paths {
#@ 	set p [file join $pa tcl$major]
#@ 	for {set n $minor} {$n >= 0} {incr n -1} {
#@ 	    set px [file join $p ${major}.${n}]
#@ 	    if {![interp issafe]} {set px [file normalize $px]}
#@ 	    path add $px
#@ 	}
#@ 	set px [file join $p site-tcl]
#@ 	if {![interp issafe]} {set px [file normalize $px]}
#@ 	path add $px
#@     }
#@     return
#@ }
#@ 
#@ # Initialization. Set up the default paths, then insert the new handler into
#@ # the chain.
#@ 
#@ if {![interp issafe]} {::tcl::tm::Defaults}
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/tm.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/package.tcl

#@ # package.tcl --
#@ #
#@ # utility procs formerly in init.tcl which can be loaded on demand
#@ # for package management.
#@ #
#@ # Copyright (c) 1991-1993 The Regents of the University of California.
#@ # Copyright (c) 1994-1998 Sun Microsystems, Inc.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ namespace eval tcl::Pkg {}
#@ 
#@ # ::tcl::Pkg::CompareExtension --
#@ #
#@ # Used internally by pkg_mkIndex to compare the extension of a file to a given
#@ # extension. On Windows, it uses a case-insensitive comparison because the
#@ # file system can be file insensitive.
#@ #
#@ # Arguments:
#@ #  fileName	name of a file whose extension is compared
#@ #  ext		(optional) The extension to compare against; you must
#@ #		provide the starting dot.
#@ #		Defaults to [info sharedlibextension]
#@ #
#@ # Results:
#@ #  Returns 1 if the extension matches, 0 otherwise
#@ 
#@ proc tcl::Pkg::CompareExtension {fileName {ext {}}} {
#@     global tcl_platform
#@     if {$ext eq ""} {set ext [info sharedlibextension]}
#@     if {$tcl_platform(platform) eq "windows"} {
#@         return [string equal -nocase [file extension $fileName] $ext]
#@     } else {
#@         # Some unices add trailing numbers after the .so, so
#@         # we could have something like '.so.1.2'.
#@         set root $fileName
#@         while {1} {
#@             set currExt [file extension $root]
#@             if {$currExt eq $ext} {
#@                 return 1
#@             }
#@ 
#@ 	    # The current extension does not match; if it is not a numeric
#@ 	    # value, quit, as we are only looking to ignore version number
#@ 	    # extensions.  Otherwise we might return 1 in this case:
#@ 	    #		tcl::Pkg::CompareExtension foo.so.bar .so
#@ 	    # which should not match.
#@ 
#@ 	    if {![string is integer -strict [string range $currExt 1 end]]} {
#@ 		return 0
#@ 	    }
#@             set root [file rootname $root]
#@ 	}
#@     }
#@ }
#@ 
#@ # pkg_mkIndex --
#@ # This procedure creates a package index in a given directory.  The package
#@ # index consists of a "pkgIndex.tcl" file whose contents are a Tcl script that
#@ # sets up package information with "package require" commands.  The commands
#@ # describe all of the packages defined by the files given as arguments.
#@ #
#@ # Arguments:
#@ # -direct		(optional) If this flag is present, the generated
#@ #			code in pkgMkIndex.tcl will cause the package to be
#@ #			loaded when "package require" is executed, rather
#@ #			than lazily when the first reference to an exported
#@ #			procedure in the package is made.
#@ # -verbose		(optional) Verbose output; the name of each file that
#@ #			was successfully rocessed is printed out. Additionally,
#@ #			if processing of a file failed a message is printed.
#@ # -load pat		(optional) Preload any packages whose names match
#@ #			the pattern.  Used to handle DLLs that depend on
#@ #			other packages during their Init procedure.
#@ # dir -			Name of the directory in which to create the index.
#@ # args -		Any number of additional arguments, each giving
#@ #			a glob pattern that matches the names of one or
#@ #			more shared libraries or Tcl script files in
#@ #			dir.
#@ 
#@ proc pkg_mkIndex {args} {
#@     set usage {"pkg_mkIndex ?-direct? ?-lazy? ?-load pattern? ?-verbose? ?--? dir ?pattern ...?"}
#@ 
#@     set argCount [llength $args]
#@     if {$argCount < 1} {
#@ 	return -code error "wrong # args: should be\n$usage"
#@     }
#@ 
#@     set more ""
#@     set direct 1
#@     set doVerbose 0
#@     set loadPat ""
#@     for {set idx 0} {$idx < $argCount} {incr idx} {
#@ 	set flag [lindex $args $idx]
#@ 	switch -glob -- $flag {
#@ 	    -- {
#@ 		# done with the flags
#@ 		incr idx
#@ 		break
#@ 	    }
#@ 	    -verbose {
#@ 		set doVerbose 1
#@ 	    }
#@ 	    -lazy {
#@ 		set direct 0
#@ 		append more " -lazy"
#@ 	    }
#@ 	    -direct {
#@ 		append more " -direct"
#@ 	    }
#@ 	    -load {
#@ 		incr idx
#@ 		set loadPat [lindex $args $idx]
#@ 		append more " -load $loadPat"
#@ 	    }
#@ 	    -* {
#@ 		return -code error "unknown flag $flag: should be\n$usage"
#@ 	    }
#@ 	    default {
#@ 		# done with the flags
#@ 		break
#@ 	    }
#@ 	}
#@     }
#@ 
#@     set dir [lindex $args $idx]
#@     set patternList [lrange $args [expr {$idx + 1}] end]
#@     if {![llength $patternList]} {
#@ 	set patternList [list "*.tcl" "*[info sharedlibextension]"]
#@     }
#@ 
#@     try {
#@ 	set fileList [glob -directory $dir -tails -types {r f} -- \
#@ 		{*}$patternList]
#@     } on error {msg opt} {
#@ 	return -options $opt $msg
#@     }
#@     foreach file $fileList {
#@ 	# For each file, figure out what commands and packages it provides.
#@ 	# To do this, create a child interpreter, load the file into the
#@ 	# interpreter, and get a list of the new commands and packages that
#@ 	# are defined.
#@ 
#@ 	if {$file eq "pkgIndex.tcl"} {
#@ 	    continue
#@ 	}
#@ 
#@ 	set c [interp create]
#@ 
#@ 	# Load into the child any packages currently loaded in the parent
#@ 	# interpreter that match the -load pattern.
#@ 
#@ 	if {$loadPat ne ""} {
#@ 	    if {$doVerbose} {
#@ 		tclLog "currently loaded packages: '[info loaded]'"
#@ 		tclLog "trying to load all packages matching $loadPat"
#@ 	    }
#@ 	    if {![llength [info loaded]]} {
#@ 		tclLog "warning: no packages are currently loaded, nothing"
#@ 		tclLog "can possibly match '$loadPat'"
#@ 	    }
#@ 	}
#@ 	foreach pkg [info loaded] {
#@ 	    if {![string match -nocase $loadPat [lindex $pkg 1]]} {
#@ 		continue
#@ 	    }
#@ 	    if {$doVerbose} {
#@ 		tclLog "package [lindex $pkg 1] matches '$loadPat'"
#@ 	    }
#@ 	    try {
#@ 		load [lindex $pkg 0] [lindex $pkg 1] $c
#@ 	    } on error err {
#@ 		if {$doVerbose} {
#@ 		    tclLog "warning: load [lindex $pkg 0]\
#@ 			    [lindex $pkg 1]\nfailed with: $err"
#@ 		}
#@ 	    } on ok {} {
#@ 		if {$doVerbose} {
#@ 		    tclLog "loaded [lindex $pkg 0] [lindex $pkg 1]"
#@ 		}
#@ 	    }
#@ 	    if {[lindex $pkg 1] eq "Tk"} {
#@ 		# Withdraw . if Tk was loaded, to avoid showing a window.
#@ 		$c eval [list wm withdraw .]
#@ 	    }
#@ 	}
#@ 
#@ 	$c eval {
#@ 	    # Stub out the package command so packages can require other
#@ 	    # packages.
#@ 
#@ 	    rename package __package_orig
#@ 	    proc package {what args} {
#@ 		switch -- $what {
#@ 		    require {
#@ 			return;		# Ignore transitive requires
#@ 		    }
#@ 		    default {
#@ 			__package_orig $what {*}$args
#@ 		    }
#@ 		}
#@ 	    }
#@ 	    proc tclPkgUnknown args {}
#@ 	    package unknown tclPkgUnknown
#@ 
#@ 	    # Stub out the unknown command so package can call into each other
#@ 	    # during their initialilzation.
#@ 
#@ 	    proc unknown {args} {}
#@ 
#@ 	    # Stub out the auto_import mechanism
#@ 
#@ 	    proc auto_import {args} {}
#@ 
#@ 	    # reserve the ::tcl namespace for support procs and temporary
#@ 	    # variables.  This might make it awkward to generate a
#@ 	    # pkgIndex.tcl file for the ::tcl namespace.
#@ 
#@ 	    namespace eval ::tcl {
#@ 		variable dir		;# Current directory being processed
#@ 		variable file		;# Current file being processed
#@ 		variable direct		;# -direct flag value
#@ 		variable x		;# Loop variable
#@ 		variable debug		;# For debugging
#@ 		variable type		;# "load" or "source", for -direct
#@ 		variable namespaces	;# Existing namespaces (e.g., ::tcl)
#@ 		variable packages	;# Existing packages (e.g., Tcl)
#@ 		variable origCmds	;# Existing commands
#@ 		variable newCmds	;# Newly created commands
#@ 		variable newPkgs {}	;# Newly created packages
#@ 	    }
#@ 	}
#@ 
#@ 	$c eval [list set ::tcl::dir $dir]
#@ 	$c eval [list set ::tcl::file $file]
#@ 	$c eval [list set ::tcl::direct $direct]
#@ 
#@ 	# Download needed procedures into the child because we've just deleted
#@ 	# the unknown procedure.  This doesn't handle procedures with default
#@ 	# arguments.
#@ 
#@ 	foreach p {::tcl::Pkg::CompareExtension} {
#@ 	    $c eval [list namespace eval [namespace qualifiers $p] {}]
#@ 	    $c eval [list proc $p [info args $p] [info body $p]]
#@ 	}
#@ 
#@ 	try {
#@ 	    $c eval {
#@ 		set ::tcl::debug "loading or sourcing"
#@ 
#@ 		# we need to track command defined by each package even in the
#@ 		# -direct case, because they are needed internally by the
#@ 		# "partial pkgIndex.tcl" step above.
#@ 
#@ 		proc ::tcl::GetAllNamespaces {{root ::}} {
#@ 		    set list $root
#@ 		    foreach ns [namespace children $root] {
#@ 			lappend list {*}[::tcl::GetAllNamespaces $ns]
#@ 		    }
#@ 		    return $list
#@ 		}
#@ 
#@ 		# init the list of existing namespaces, packages, commands
#@ 
#@ 		foreach ::tcl::x [::tcl::GetAllNamespaces] {
#@ 		    set ::tcl::namespaces($::tcl::x) 1
#@ 		}
#@ 		foreach ::tcl::x [package names] {
#@ 		    if {[package provide $::tcl::x] ne ""} {
#@ 			set ::tcl::packages($::tcl::x) 1
#@ 		    }
#@ 		}
#@ 		set ::tcl::origCmds [info commands]
#@ 
#@ 		# Try to load the file if it has the shared library extension,
#@ 		# otherwise source it.  It's important not to try to load
#@ 		# files that aren't shared libraries, because on some systems
#@ 		# (like SunOS) the loader will abort the whole application
#@ 		# when it gets an error.
#@ 
#@ 		if {[::tcl::Pkg::CompareExtension $::tcl::file [info sharedlibextension]]} {
#@ 		    # The "file join ." command below is necessary.  Without
#@ 		    # it, if the file name has no \'s and we're on UNIX, the
#@ 		    # load command will invoke the LD_LIBRARY_PATH search
#@ 		    # mechanism, which could cause the wrong file to be used.
#@ 
#@ 		    set ::tcl::debug loading
#@ 		    load [file join $::tcl::dir $::tcl::file]
#@ 		    set ::tcl::type load
#@ 		} else {
#@ 		    set ::tcl::debug sourcing
#@ 		    source [file join $::tcl::dir $::tcl::file]
#@ 		    set ::tcl::type source
#@ 		}
#@ 
#@ 		# As a performance optimization, if we are creating direct
#@ 		# load packages, don't bother figuring out the set of commands
#@ 		# created by the new packages.  We only need that list for
#@ 		# setting up the autoloading used in the non-direct case.
#@ 		if {!$::tcl::direct} {
#@ 		    # See what new namespaces appeared, and import commands
#@ 		    # from them.  Only exported commands go into the index.
#@ 
#@ 		    foreach ::tcl::x [::tcl::GetAllNamespaces] {
#@ 			if {![info exists ::tcl::namespaces($::tcl::x)]} {
#@ 			    namespace import -force ${::tcl::x}::*
#@ 			}
#@ 
#@ 			# Figure out what commands appeared
#@ 
#@ 			foreach ::tcl::x [info commands] {
#@ 			    set ::tcl::newCmds($::tcl::x) 1
#@ 			}
#@ 			foreach ::tcl::x $::tcl::origCmds {
#@ 			    unset -nocomplain ::tcl::newCmds($::tcl::x)
#@ 			}
#@ 			foreach ::tcl::x [array names ::tcl::newCmds] {
#@ 			    # determine which namespace a command comes from
#@ 
#@ 			    set ::tcl::abs [namespace origin $::tcl::x]
#@ 
#@ 			    # special case so that global names have no
#@ 			    # leading ::, this is required by the unknown
#@ 			    # command
#@ 
#@ 			    set ::tcl::abs \
#@ 				    [lindex [auto_qualify $::tcl::abs ::] 0]
#@ 
#@ 			    if {$::tcl::x ne $::tcl::abs} {
#@ 				# Name changed during qualification
#@ 
#@ 				set ::tcl::newCmds($::tcl::abs) 1
#@ 				unset ::tcl::newCmds($::tcl::x)
#@ 			    }
#@ 			}
#@ 		    }
#@ 		}
#@ 
#@ 		# Look through the packages that appeared, and if there is a
#@ 		# version provided, then record it
#@ 
#@ 		foreach ::tcl::x [package names] {
#@ 		    if {[package provide $::tcl::x] ne ""
#@ 			    && ![info exists ::tcl::packages($::tcl::x)]} {
#@ 			lappend ::tcl::newPkgs \
#@ 			    [list $::tcl::x [package provide $::tcl::x]]
#@ 		    }
#@ 		}
#@ 	    }
#@ 	} on error msg {
#@ 	    set what [$c eval set ::tcl::debug]
#@ 	    if {$doVerbose} {
#@ 		tclLog "warning: error while $what $file: $msg"
#@ 	    }
#@ 	} on ok {} {
#@ 	    set what [$c eval set ::tcl::debug]
#@ 	    if {$doVerbose} {
#@ 		tclLog "successful $what of $file"
#@ 	    }
#@ 	    set type [$c eval set ::tcl::type]
#@ 	    set cmds [lsort [$c eval array names ::tcl::newCmds]]
#@ 	    set pkgs [$c eval set ::tcl::newPkgs]
#@ 	    if {$doVerbose} {
#@ 		if {!$direct} {
#@ 		    tclLog "commands provided were $cmds"
#@ 		}
#@ 		tclLog "packages provided were $pkgs"
#@ 	    }
#@ 	    if {[llength $pkgs] > 1} {
#@ 		tclLog "warning: \"$file\" provides more than one package ($pkgs)"
#@ 	    }
#@ 	    foreach pkg $pkgs {
#@ 		# cmds is empty/not used in the direct case
#@ 		lappend files($pkg) [list $file $type $cmds]
#@ 	    }
#@ 
#@ 	    if {$doVerbose} {
#@ 		tclLog "processed $file"
#@ 	    }
#@ 	}
#@ 	interp delete $c
#@     }
#@ 
#@     append index "# Tcl package index file, version 1.1\n"
#@     append index "# This file is generated by the \"pkg_mkIndex$more\" command\n"
#@     append index "# and sourced either when an application starts up or\n"
#@     append index "# by a \"package unknown\" script.  It invokes the\n"
#@     append index "# \"package ifneeded\" command to set up package-related\n"
#@     append index "# information so that packages will be loaded automatically\n"
#@     append index "# in response to \"package require\" commands.  When this\n"
#@     append index "# script is sourced, the variable \$dir must contain the\n"
#@     append index "# full path name of this file's directory.\n"
#@ 
#@     foreach pkg [lsort [array names files]] {
#@ 	set cmd {}
#@ 	lassign $pkg name version
#@ 	lappend cmd ::tcl::Pkg::Create -name $name -version $version
#@ 	foreach spec [lsort -index 0 $files($pkg)] {
#@ 	    foreach {file type procs} $spec {
#@ 		if {$direct} {
#@ 		    set procs {}
#@ 		}
#@ 		lappend cmd "-$type" [list $file $procs]
#@ 	    }
#@ 	}
#@ 	append index "\n[eval $cmd]"
#@     }
#@ 
#@     set f [open [file join $dir pkgIndex.tcl] w]
#@     puts $f $index
#@     close $f
#@ }
#@ 
#@ # tclPkgSetup --
#@ # This is a utility procedure use by pkgIndex.tcl files.  It is invoked as
#@ # part of a "package ifneeded" script.  It calls "package provide" to indicate
#@ # that a package is available, then sets entries in the auto_index array so
#@ # that the package's files will be auto-loaded when the commands are used.
#@ #
#@ # Arguments:
#@ # dir -			Directory containing all the files for this package.
#@ # pkg -			Name of the package (no version number).
#@ # version -		Version number for the package, such as 2.1.3.
#@ # files -		List of files that constitute the package.  Each
#@ #			element is a sub-list with three elements.  The first
#@ #			is the name of a file relative to $dir, the second is
#@ #			"load" or "source", indicating whether the file is a
#@ #			loadable binary or a script to source, and the third
#@ #			is a list of commands defined by this file.
#@ 
#@ proc tclPkgSetup {dir pkg version files} {
#@     global auto_index
#@ 
#@     package provide $pkg $version
#@     foreach fileInfo $files {
#@ 	set f [lindex $fileInfo 0]
#@ 	set type [lindex $fileInfo 1]
#@ 	foreach cmd [lindex $fileInfo 2] {
#@ 	    if {$type eq "load"} {
#@ 		set auto_index($cmd) [list load [file join $dir $f] $pkg]
#@ 	    } else {
#@ 		set auto_index($cmd) [list source [file join $dir $f]]
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ # tclPkgUnknown --
#@ # This procedure provides the default for the "package unknown" function.  It
#@ # is invoked when a package that's needed can't be found.  It scans the
#@ # auto_path directories and their immediate children looking for pkgIndex.tcl
#@ # files and sources any such files that are found to setup the package
#@ # database. As it searches, it will recognize changes to the auto_path and
#@ # scan any new directories.
#@ #
#@ # Arguments:
#@ # name -		Name of desired package.  Not used.
#@ # version -		Version of desired package.  Not used.
#@ # exact -		Either "-exact" or omitted.  Not used.
#@ 
#@ proc tclPkgUnknown {name args} {
#@     global auto_path env
#@ 
#@     if {![info exists auto_path]} {
#@ 	return
#@     }
#@     # Cache the auto_path, because it may change while we run through the
#@     # first set of pkgIndex.tcl files
#@     set old_path [set use_path $auto_path]
#@     while {[llength $use_path]} {
#@ 	set dir [lindex $use_path end]
#@ 
#@ 	# Make sure we only scan each directory one time.
#@ 	if {[info exists tclSeenPath($dir)]} {
#@ 	    set use_path [lrange $use_path 0 end-1]
#@ 	    continue
#@ 	}
#@ 	set tclSeenPath($dir) 1
#@ 
#@ 	# Get the pkgIndex.tcl files in subdirectories of auto_path directories.
#@ 	# - Safe Base interpreters have a restricted "glob" command that
#@ 	#   works in this case.
#@ 	# - The "catch" was essential when there was no safe glob and every
#@ 	#   call in a safe interp failed; it is retained only for corner
#@ 	#   cases in which the eventual call to glob returns an error.
#@ 	catch {
#@ 	    foreach file [glob -directory $dir -join -nocomplain \
#@ 		    * pkgIndex.tcl] {
#@ 		set dir [file dirname $file]
#@ 		if {![info exists procdDirs($dir)]} {
#@ 		    try {
#@ 			source $file
#@ 		    } trap {POSIX EACCES} {} {
#@ 			# $file was not readable; silently ignore
#@ 			continue
#@ 		    } on error msg {
#@ 			tclLog "error reading package index file $file: $msg"
#@ 		    } on ok {} {
#@ 			set procdDirs($dir) 1
#@ 		    }
#@ 		}
#@ 	    }
#@ 	}
#@ 	set dir [lindex $use_path end]
#@ 	if {![info exists procdDirs($dir)]} {
#@ 	    set file [file join $dir pkgIndex.tcl]
#@ 	    # safe interps usually don't have "file exists",
#@ 	    if {([interp issafe] || [file exists $file])} {
#@ 		try {
#@ 		    source $file
#@ 		} trap {POSIX EACCES} {} {
#@ 		    # $file was not readable; silently ignore
#@ 		    continue
#@ 		} on error msg {
#@ 		    tclLog "error reading package index file $file: $msg"
#@ 		} on ok {} {
#@ 		    set procdDirs($dir) 1
#@ 		}
#@ 	    }
#@ 	}
#@ 
#@ 	set use_path [lrange $use_path 0 end-1]
#@ 
#@ 	# Check whether any of the index scripts we [source]d above set a new
#@ 	# value for $::auto_path.  If so, then find any new directories on the
#@ 	# $::auto_path, and lappend them to the $use_path we are working from.
#@ 	# This gives index scripts the (arguably unwise) power to expand the
#@ 	# index script search path while the search is in progress.
#@ 	set index 0
#@ 	if {[llength $old_path] == [llength $auto_path]} {
#@ 	    foreach dir $auto_path old $old_path {
#@ 		if {$dir ne $old} {
#@ 		    # This entry in $::auto_path has changed.
#@ 		    break
#@ 		}
#@ 		incr index
#@ 	    }
#@ 	}
#@ 
#@ 	# $index now points to the first element of $auto_path that has
#@ 	# changed, or the beginning if $auto_path has changed length Scan the
#@ 	# new elements of $auto_path for directories to add to $use_path.
#@ 	# Don't add directories we've already seen, or ones already on the
#@ 	# $use_path.
#@ 	foreach dir [lrange $auto_path $index end] {
#@ 	    if {![info exists tclSeenPath($dir)] && ($dir ni $use_path)} {
#@ 		lappend use_path $dir
#@ 	    }
#@ 	}
#@ 	set old_path $auto_path
#@     }
#@ }
#@ 
#@ # tcl::MacOSXPkgUnknown --
#@ # This procedure extends the "package unknown" function for MacOSX.  It scans
#@ # the Resources/Scripts directories of the immediate children of the auto_path
#@ # directories for pkgIndex files.
#@ #
#@ # Arguments:
#@ # original -		original [package unknown] procedure
#@ # name -		Name of desired package.  Not used.
#@ # version -		Version of desired package.  Not used.
#@ # exact -		Either "-exact" or omitted.  Not used.
#@ 
#@ proc tcl::MacOSXPkgUnknown {original name args} {
#@     #  First do the cross-platform default search
#@     uplevel 1 $original [linsert $args 0 $name]
#@ 
#@     # Now do MacOSX specific searching
#@     global auto_path
#@ 
#@     if {![info exists auto_path]} {
#@ 	return
#@     }
#@     # Cache the auto_path, because it may change while we run through the
#@     # first set of pkgIndex.tcl files
#@     set old_path [set use_path $auto_path]
#@     while {[llength $use_path]} {
#@ 	set dir [lindex $use_path end]
#@ 
#@ 	# Make sure we only scan each directory one time.
#@ 	if {[info exists tclSeenPath($dir)]} {
#@ 	    set use_path [lrange $use_path 0 end-1]
#@ 	    continue
#@ 	}
#@ 	set tclSeenPath($dir) 1
#@ 
#@ 	# get the pkgIndex files out of the subdirectories
#@ 	# Safe interpreters do not use tcl::MacOSXPkgUnknown - see init.tcl.
#@ 	foreach file [glob -directory $dir -join -nocomplain \
#@ 		* Resources Scripts pkgIndex.tcl] {
#@ 	    set dir [file dirname $file]
#@ 	    if {![info exists procdDirs($dir)]} {
#@ 		try {
#@ 		    source $file
#@ 		} trap {POSIX EACCES} {} {
#@ 		    # $file was not readable; silently ignore
#@ 		    continue
#@ 		} on error msg {
#@ 		    tclLog "error reading package index file $file: $msg"
#@ 		} on ok {} {
#@ 		    set procdDirs($dir) 1
#@ 		}
#@ 	    }
#@ 	}
#@ 	set use_path [lrange $use_path 0 end-1]
#@ 
#@ 	# Check whether any of the index scripts we [source]d above set a new
#@ 	# value for $::auto_path.  If so, then find any new directories on the
#@ 	# $::auto_path, and lappend them to the $use_path we are working from.
#@ 	# This gives index scripts the (arguably unwise) power to expand the
#@ 	# index script search path while the search is in progress.
#@ 	set index 0
#@ 	if {[llength $old_path] == [llength $auto_path]} {
#@ 	    foreach dir $auto_path old $old_path {
#@ 		if {$dir ne $old} {
#@ 		    # This entry in $::auto_path has changed.
#@ 		    break
#@ 		}
#@ 		incr index
#@ 	    }
#@ 	}
#@ 
#@ 	# $index now points to the first element of $auto_path that has
#@ 	# changed, or the beginning if $auto_path has changed length Scan the
#@ 	# new elements of $auto_path for directories to add to $use_path.
#@ 	# Don't add directories we've already seen, or ones already on the
#@ 	# $use_path.
#@ 	foreach dir [lrange $auto_path $index end] {
#@ 	    if {![info exists tclSeenPath($dir)] && ($dir ni $use_path)} {
#@ 		lappend use_path $dir
#@ 	    }
#@ 	}
#@ 	set old_path $auto_path
#@     }
#@ }
#@ 
#@ # ::tcl::Pkg::Create --
#@ #
#@ #	Given a package specification generate a "package ifneeded" statement
#@ #	for the package, suitable for inclusion in a pkgIndex.tcl file.
#@ #
#@ # Arguments:
#@ #	args		arguments used by the Create function:
#@ #			-name		packageName
#@ #			-version	packageVersion
#@ #			-load		{filename ?{procs}?}
#@ #			...
#@ #			-source		{filename ?{procs}?}
#@ #			...
#@ #
#@ #			Any number of -load and -source parameters may be
#@ #			specified, so long as there is at least one -load or
#@ #			-source parameter.  If the procs component of a module
#@ #			specifier is left off, that module will be set up for
#@ #			direct loading; otherwise, it will be set up for lazy
#@ #			loading.  If both -source and -load are specified, the
#@ #			-load'ed files will be loaded first, followed by the
#@ #			-source'd files.
#@ #
#@ # Results:
#@ #	An appropriate "package ifneeded" statement for the package.
#@ 
#@ proc ::tcl::Pkg::Create {args} {
#@     append err(usage) "[lindex [info level 0] 0] "
#@     append err(usage) "-name packageName -version packageVersion"
#@     append err(usage) "?-load {filename ?{procs}?}? ... "
#@     append err(usage) "?-source {filename ?{procs}?}? ..."
#@ 
#@     set err(wrongNumArgs) "wrong # args: should be \"$err(usage)\""
#@     set err(valueMissing) "value for \"%s\" missing: should be \"$err(usage)\""
#@     set err(unknownOpt)   "unknown option \"%s\": should be \"$err(usage)\""
#@     set err(noLoadOrSource) "at least one of -load and -source must be given"
#@ 
#@     # process arguments
#@     set len [llength $args]
#@     if {$len < 6} {
#@ 	error $err(wrongNumArgs)
#@     }
#@ 
#@     # Initialize parameters
#@     array set opts {-name {} -version {} -source {} -load {}}
#@ 
#@     # process parameters
#@     for {set i 0} {$i < $len} {incr i} {
#@ 	set flag [lindex $args $i]
#@ 	incr i
#@ 	switch -glob -- $flag {
#@ 	    "-name"		-
#@ 	    "-version"		{
#@ 		if {$i >= $len} {
#@ 		    error [format $err(valueMissing) $flag]
#@ 		}
#@ 		set opts($flag) [lindex $args $i]
#@ 	    }
#@ 	    "-source"		-
#@ 	    "-load"		{
#@ 		if {$i >= $len} {
#@ 		    error [format $err(valueMissing) $flag]
#@ 		}
#@ 		lappend opts($flag) [lindex $args $i]
#@ 	    }
#@ 	    default {
#@ 		error [format $err(unknownOpt) [lindex $args $i]]
#@ 	    }
#@ 	}
#@     }
#@ 
#@     # Validate the parameters
#@     if {![llength $opts(-name)]} {
#@ 	error [format $err(valueMissing) "-name"]
#@     }
#@     if {![llength $opts(-version)]} {
#@ 	error [format $err(valueMissing) "-version"]
#@     }
#@ 
#@     if {!([llength $opts(-source)] || [llength $opts(-load)])} {
#@ 	error $err(noLoadOrSource)
#@     }
#@ 
#@     # OK, now everything is good.  Generate the package ifneeded statment.
#@     set cmdline "package ifneeded $opts(-name) $opts(-version) "
#@ 
#@     set cmdList {}
#@     set lazyFileList {}
#@ 
#@     # Handle -load and -source specs
#@     foreach key {load source} {
#@ 	foreach filespec $opts(-$key) {
#@ 	    lassign $filespec filename proclist
#@ 
#@ 	    if { [llength $proclist] == 0 } {
#@ 		set cmd "\[list $key \[file join \$dir [list $filename]\]\]"
#@ 		lappend cmdList $cmd
#@ 	    } else {
#@ 		lappend lazyFileList [list $filename $key $proclist]
#@ 	    }
#@ 	}
#@     }
#@ 
#@     if {[llength $lazyFileList]} {
#@ 	lappend cmdList "\[list tclPkgSetup \$dir $opts(-name)\
#@ 		$opts(-version) [list $lazyFileList]\]"
#@     }
#@     append cmdline [join $cmdList "\\n"]
#@     return $cmdline
#@ }
#@ 
#@ interp alias {} ::pkg::create {} ::tcl::Pkg::Create
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/package.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/itcl4.2.1/pkgIndex.tcl

#@ # Tcl package index file, version 1.0
#@ #
#@ # Do NOT try this command
#@ #
#@ #   if {![package vsatisfies [package provide Tcl] 8.6-]} {return}
#@ #
#@ # as a way to accept working with all of Tcl 8.6, Tcl 8.X, X>6, and
#@ # Tcl Y, for Y > 8.
#@ # Itcl is a binary package, added to an interp with [load].
#@ # There is no libitcl.so that will [load] into both Tcl 8 and Tcl 9.
#@ # The indexed libitcl.so was built to [load] into one or the other.
#@ # Thus the pkgIndex.tcl should only accept the version of Tcl for which
#@ # the indexed libitcl4.2.1.a was built.
#@ #
#@ # More work replacing the literal "8.6" below with the proper value substituted
#@ # by configure is the right way forward.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.6]} {return}
#@ 
#@ package ifneeded itcl 4.2.1 [list load "libitcl-O.so" Itcl]
#@ package ifneeded Itcl 4.2.1 [list load "libitcl-O.so" Itcl]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/itcl4.2.1/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTclPro 1.0 [list source [file join $dir			snpsTclPro.tcl]]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/snps_tcl/pkgIndex.tcl

#@ package ifneeded Itcl 3.4 {load {} Itcl}
#@ package ifneeded tbcload 1.7 {load {} tbcload}
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/snps_tcl/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/dde/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/dde/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/http/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.6-]} {return}
#@ package ifneeded http 2.9.5 [list tclPkgSetup $dir http 2.9.5 {{http.tcl source {::http::config ::http::formatQuery ::http::geturl ::http::reset ::http::wait ::http::register ::http::unregister ::http::mapReply}}}]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/http/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/http1.0/pkgIndex.tcl

#@ # Tcl package index file, version 1.0
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded http 1.0 [list tclPkgSetup $dir http 1.0 {{http.tcl source {httpCopyDone httpCopyStart httpEof httpEvent httpFinish httpMapReply httpProxyRequired http_code http_config http_data http_formatQuery http_get http_reset http_size http_status http_wait}}}]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/http1.0/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/msgcat/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5-]} {return}
#@ package ifneeded msgcat 1.6.1 [list source [file join $dir msgcat.tcl]]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/msgcat/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/opt/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5-]} {return}
#@ package ifneeded opt 0.4.8 [list source [file join $dir optparse.tcl]]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/opt/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/platform/pkgIndex.tcl

#@ package ifneeded platform        1.0.15 [list source [file join $dir platform.tcl]]
#@ package ifneeded platform::shell 1.1.4 [list source [file join $dir shell.tcl]]
#@ 
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/platform/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/reg/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/reg/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/tcltest/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5-]} {return}
#@ package ifneeded tcltest 2.5.3 [list source [file join $dir tcltest.tcl]]
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/tcltest/pkgIndex.tcl

#@ # -- Starting source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/msgcat/msgcat.tcl

#@ # msgcat.tcl --
#@ #
#@ #	This file defines various procedures which implement a
#@ #	message catalog facility for Tcl programs.  It should be
#@ #	loaded with the command "package require msgcat".
#@ #
#@ # Copyright (c) 2010-2015 Harald Oehlmann.
#@ # Copyright (c) 1998-2000 Ajuba Solutions.
#@ # Copyright (c) 1998 Mark Harrison.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ package require Tcl 8.5-
#@ # When the version number changes, be sure to update the pkgIndex.tcl file,
#@ # and the installation directory in the Makefiles.
#@ package provide msgcat 1.6.1
#@ 
#@ namespace eval msgcat {
#@     namespace export mc mcexists mcload mclocale mcmax mcmset mcpreferences mcset\
#@             mcunknown mcflset mcflmset mcloadedlocales mcforgetpackage\
#@ 	    mcpackageconfig mcpackagelocale
#@ 
#@     # Records the list of locales to search
#@     variable Loclist {}
#@ 
#@     # List of currently loaded locales
#@     variable LoadedLocales {}
#@ 
#@     # Records the locale of the currently sourced message catalogue file
#@     variable FileLocale
#@ 
#@     # Configuration values per Package (e.g. client namespace).
#@     # The dict key is of the form "<option> <namespace>" and the value is the
#@     # configuration option. A nonexisting key is an unset option.
#@     variable PackageConfig [dict create mcfolder {} loadcmd {} changecmd {}\
#@ 	    unknowncmd {} loadedlocales {} loclist {}]
#@ 
#@     # Records the mapping between source strings and translated strings.  The
#@     # dict key is of the form "<namespace> <locale> <src>", where locale and
#@     # namespace should be themselves dict values and the value is
#@     # the translated string.
#@     variable Msgs [dict create]
#@ 
#@     # Map of language codes used in Windows registry to those of ISO-639
#@     if {[info sharedlibextension] eq ".dll"} {
#@ 	variable WinRegToISO639 [dict create  {*}{
#@ 	    01 ar 0401 ar_SA 0801 ar_IQ 0c01 ar_EG 1001 ar_LY 1401 ar_DZ
#@ 		  1801 ar_MA 1c01 ar_TN 2001 ar_OM 2401 ar_YE 2801 ar_SY
#@ 		  2c01 ar_JO 3001 ar_LB 3401 ar_KW 3801 ar_AE 3c01 ar_BH
#@ 		  4001 ar_QA
#@ 	    02 bg 0402 bg_BG
#@ 	    03 ca 0403 ca_ES
#@ 	    04 zh 0404 zh_TW 0804 zh_CN 0c04 zh_HK 1004 zh_SG 1404 zh_MO
#@ 	    05 cs 0405 cs_CZ
#@ 	    06 da 0406 da_DK
#@ 	    07 de 0407 de_DE 0807 de_CH 0c07 de_AT 1007 de_LU 1407 de_LI
#@ 	    08 el 0408 el_GR
#@ 	    09 en 0409 en_US 0809 en_GB 0c09 en_AU 1009 en_CA 1409 en_NZ
#@ 		  1809 en_IE 1c09 en_ZA 2009 en_JM 2409 en_GD 2809 en_BZ
#@ 		  2c09 en_TT 3009 en_ZW 3409 en_PH
#@ 	    0a es 040a es_ES 080a es_MX 0c0a es_ES@modern 100a es_GT 140a es_CR
#@ 		  180a es_PA 1c0a es_DO 200a es_VE 240a es_CO 280a es_PE
#@ 		  2c0a es_AR 300a es_EC 340a es_CL 380a es_UY 3c0a es_PY
#@ 		  400a es_BO 440a es_SV 480a es_HN 4c0a es_NI 500a es_PR
#@ 	    0b fi 040b fi_FI
#@ 	    0c fr 040c fr_FR 080c fr_BE 0c0c fr_CA 100c fr_CH 140c fr_LU
#@ 		  180c fr_MC
#@ 	    0d he 040d he_IL
#@ 	    0e hu 040e hu_HU
#@ 	    0f is 040f is_IS
#@ 	    10 it 0410 it_IT 0810 it_CH
#@ 	    11 ja 0411 ja_JP
#@ 	    12 ko 0412 ko_KR
#@ 	    13 nl 0413 nl_NL 0813 nl_BE
#@ 	    14 no 0414 no_NO 0814 nn_NO
#@ 	    15 pl 0415 pl_PL
#@ 	    16 pt 0416 pt_BR 0816 pt_PT
#@ 	    17 rm 0417 rm_CH
#@ 	    18 ro 0418 ro_RO 0818 ro_MO
#@ 	    19 ru 0819 ru_MO
#@ 	    1a hr 041a hr_HR 081a sr_YU 0c1a sr_YU@cyrillic
#@ 	    1b sk 041b sk_SK
#@ 	    1c sq 041c sq_AL
#@ 	    1d sv 041d sv_SE 081d sv_FI
#@ 	    1e th 041e th_TH
#@ 	    1f tr 041f tr_TR
#@ 	    20 ur 0420 ur_PK 0820 ur_IN
#@ 	    21 id 0421 id_ID
#@ 	    22 uk 0422 uk_UA
#@ 	    23 be 0423 be_BY
#@ 	    24 sl 0424 sl_SI
#@ 	    25 et 0425 et_EE
#@ 	    26 lv 0426 lv_LV
#@ 	    27 lt 0427 lt_LT
#@ 	    28 tg 0428 tg_TJ
#@ 	    29 fa 0429 fa_IR
#@ 	    2a vi 042a vi_VN
#@ 	    2b hy 042b hy_AM
#@ 	    2c az 042c az_AZ@latin 082c az_AZ@cyrillic
#@ 	    2d eu
#@ 	    2e wen 042e wen_DE
#@ 	    2f mk 042f mk_MK
#@ 	    30 bnt 0430 bnt_TZ
#@ 	    31 ts 0431 ts_ZA
#@ 	    32 tn
#@ 	    33 ven 0433 ven_ZA
#@ 	    34 xh 0434 xh_ZA
#@ 	    35 zu 0435 zu_ZA
#@ 	    36 af 0436 af_ZA
#@ 	    37 ka 0437 ka_GE
#@ 	    38 fo 0438 fo_FO
#@ 	    39 hi 0439 hi_IN
#@ 	    3a mt 043a mt_MT
#@ 	    3b se 043b se_NO
#@ 	    043c gd_UK 083c ga_IE
#@ 	    3d yi 043d yi_IL
#@ 	    3e ms 043e ms_MY 083e ms_BN
#@ 	    3f kk 043f kk_KZ
#@ 	    40 ky 0440 ky_KG
#@ 	    41 sw 0441 sw_KE
#@ 	    42 tk 0442 tk_TM
#@ 	    43 uz 0443 uz_UZ@latin 0843 uz_UZ@cyrillic
#@ 	    44 tt 0444 tt_RU
#@ 	    45 bn 0445 bn_IN
#@ 	    46 pa 0446 pa_IN
#@ 	    47 gu 0447 gu_IN
#@ 	    48 or 0448 or_IN
#@ 	    49 ta
#@ 	    4a te 044a te_IN
#@ 	    4b kn 044b kn_IN
#@ 	    4c ml 044c ml_IN
#@ 	    4d as 044d as_IN
#@ 	    4e mr 044e mr_IN
#@ 	    4f sa 044f sa_IN
#@ 	    50 mn
#@ 	    51 bo 0451 bo_CN
#@ 	    52 cy 0452 cy_GB
#@ 	    53 km 0453 km_KH
#@ 	    54 lo 0454 lo_LA
#@ 	    55 my 0455 my_MM
#@ 	    56 gl 0456 gl_ES
#@ 	    57 kok 0457 kok_IN
#@ 	    58 mni 0458 mni_IN
#@ 	    59 sd
#@ 	    5a syr 045a syr_TR
#@ 	    5b si 045b si_LK
#@ 	    5c chr 045c chr_US
#@ 	    5d iu 045d iu_CA
#@ 	    5e am 045e am_ET
#@ 	    5f ber 045f ber_MA
#@ 	    60 ks 0460 ks_PK 0860 ks_IN
#@ 	    61 ne 0461 ne_NP 0861 ne_IN
#@ 	    62 fy 0462 fy_NL
#@ 	    63 ps
#@ 	    64 tl 0464 tl_PH
#@ 	    65 div 0465 div_MV
#@ 	    66 bin 0466 bin_NG
#@ 	    67 ful 0467 ful_NG
#@ 	    68 ha 0468 ha_NG
#@ 	    69 nic 0469 nic_NG
#@ 	    6a yo 046a yo_NG
#@ 	    70 ibo 0470 ibo_NG
#@ 	    71 kau 0471 kau_NG
#@ 	    72 om 0472 om_ET
#@ 	    73 ti 0473 ti_ET
#@ 	    74 gn 0474 gn_PY
#@ 	    75 cpe 0475 cpe_US
#@ 	    76 la 0476 la_VA
#@ 	    77 so 0477 so_SO
#@ 	    78 sit 0478 sit_CN
#@ 	    79 pap 0479 pap_AN
#@ 	}]
#@     }
#@ }
#@ 
#@ # msgcat::mc --
#@ #
#@ #	Find the translation for the given string based on the current
#@ #	locale setting. Check the local namespace first, then look in each
#@ #	parent namespace until the source is found.  If additional args are
#@ #	specified, use the format command to work them into the traslated
#@ #	string.
#@ #	If no catalog item is found, mcunknown is called in the caller frame
#@ #	and its result is returned.
#@ #
#@ # Arguments:
#@ #	src	The string to translate.
#@ #	args	Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated string.  Propagates errors thrown by the
#@ #	format command.
#@ 
#@ proc msgcat::mc {src args} {
#@     # this may be replaced by:
#@     # return [mcget -namespace [uplevel 1 [list ::namespace current]] --\
#@     #	    $src {*}$args]
#@ 
#@     # Check for the src in each namespace starting from the local and
#@     # ending in the global.
#@ 
#@     variable Msgs
#@     variable Loclist
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@     set loclist [PackagePreferences $ns]
#@ 
#@     set nscur $ns
#@     while {$nscur != ""} {
#@ 	foreach loc $loclist {
#@ 	    if {[dict exists $Msgs $nscur $loc $src]} {
#@ 		return [DefaultUnknown "" [dict get $Msgs $nscur $loc $src]\
#@ 			{*}$args]
#@ 	    }
#@ 	}
#@ 	set nscur [namespace parent $nscur]
#@     }
#@     # call package local or default unknown command
#@     set args [linsert $args 0 [lindex $loclist 0] $src]
#@     switch -exact -- [Invoke unknowncmd $args $ns result 1] {
#@ 	0 { return [uplevel 1 [linsert $args 0 [namespace origin mcunknown]]] }
#@ 	1 { return [DefaultUnknown {*}$args] }
#@ 	default { return $result }
#@     }
#@ }
#@ 
#@ # msgcat::mcexists --
#@ #
#@ #	Check if a catalog item is set or if mc would invoke mcunknown.
#@ #
#@ # Arguments:
#@ #	-exactnamespace		Only check the exact namespace and no
#@ #				parent namespaces
#@ #	-exactlocale		Only check the exact locale and not all members
#@ #				of the preferences list
#@ #	src			Message catalog key
#@ #
#@ # Results:
#@ #	true if an adequate catalog key was found
#@ 
#@ proc msgcat::mcexists {args} {
#@ 
#@     variable Msgs
#@     variable Loclist
#@     variable PackageConfig
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@     set loclist [PackagePreferences $ns]
#@ 
#@     while {[llength $args] != 1} {
#@ 	set args [lassign $args option]
#@ 	switch -glob -- $option {
#@ 	    -exactnamespace { set exactnamespace 1 }
#@ 	    -exactlocale { set loclist [lrange $loclist 0 0] }
#@ 	    -* { return -code error "unknown option \"$option\"" }
#@ 	    default {
#@ 		return -code error "wrong # args: should be\
#@ 			\"[lindex [info level 0] 0] ?-exactnamespace?\
#@ 			?-exactlocale? src\""
#@ 	    }
#@ 	}
#@     }
#@     set src [lindex $args 0]
#@ 
#@     while {$ns ne ""} {
#@ 	foreach loc $loclist {
#@ 	    if {[dict exists $Msgs $ns $loc $src]} {
#@ 		return 1
#@ 	    }
#@ 	}
#@ 	if {[info exists exactnamespace]} {return 0}
#@ 	set ns [namespace parent $ns]
#@     }
#@     return 0
#@ }
#@ 
#@ # msgcat::mclocale --
#@ #
#@ #	Query or set the current locale.
#@ #
#@ # Arguments:
#@ #	newLocale	(Optional) The new locale string. Locale strings
#@ #			should be composed of one or more sublocale parts
#@ #			separated by underscores (e.g. en_US).
#@ #
#@ # Results:
#@ #	Returns the normalized set locale.
#@ 
#@ proc msgcat::mclocale {args} {
#@     variable Loclist
#@     variable LoadedLocales
#@     set len [llength $args]
#@ 
#@     if {$len > 1} {
#@ 	return -code error "wrong # args: should be\
#@ 		\"[lindex [info level 0] 0] ?newLocale?\""
#@     }
#@ 
#@     if {$len == 1} {
#@ 	set newLocale [string tolower [lindex $args 0]]
#@ 	if {$newLocale ne [file tail $newLocale]} {
#@ 	    return -code error "invalid newLocale value \"$newLocale\":\
#@ 		    could be path to unsafe code."
#@ 	}
#@ 	if {[lindex $Loclist 0] ne $newLocale} {
#@ 	    set Loclist [GetPreferences $newLocale]
#@ 
#@ 	    # locale not loaded jet
#@ 	    LoadAll $Loclist
#@ 	    # Invoke callback
#@ 	    Invoke changecmd $Loclist
#@ 	}
#@     }
#@     return [lindex $Loclist 0]
#@ }
#@ 
#@ # msgcat::GetPreferences --
#@ #
#@ #	Get list of locales from a locale.
#@ #	The first element is always the lowercase locale.
#@ #	Other elements have one component separated by "_" less.
#@ #	Multiple "_" are seen as one separator: de__ch_spec de__ch de {}
#@ #
#@ # Arguments:
#@ #	Locale.
#@ #
#@ # Results:
#@ #	Locale list
#@ 
#@ proc msgcat::GetPreferences {locale} {
#@     set locale [string tolower $locale]
#@     set loclist [list $locale]
#@     while {-1 !=[set pos [string last "_" $locale]]} {
#@ 	set locale [string range $locale 0 $pos-1]
#@ 	if { "_" ne [string index $locale end] } {
#@ 	    lappend loclist $locale
#@ 	}
#@     }
#@     if {"" ne [lindex $loclist end]} {
#@ 	lappend loclist {}
#@     }
#@     return $loclist
#@ }
#@ 
#@ # msgcat::mcpreferences --
#@ #
#@ #	Fetch the list of locales used to look up strings, ordered from
#@ #	most preferred to least preferred.
#@ #
#@ # Arguments:
#@ #	None.
#@ #
#@ # Results:
#@ #	Returns an ordered list of the locales preferred by the user.
#@ 
#@ proc msgcat::mcpreferences {} {
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::mcloadedlocales --
#@ #
#@ #	Get or change the list of currently loaded default locales
#@ #
#@ #	The following subcommands are available:
#@ #	loaded
#@ #	    Get the current list of loaded locales
#@ #	clear
#@ #	    Remove all loaded locales not present in mcpreferences.
#@ #
#@ # Arguments:
#@ #	subcommand		One of loaded or clear
#@ #
#@ # Results:
#@ #	Empty string, if not stated differently for the subcommand
#@ 
#@ proc msgcat::mcloadedlocales {subcommand} {
#@     variable Loclist
#@     variable LoadedLocales
#@     variable Msgs
#@     variable PackageConfig
#@     switch -exact -- $subcommand {
#@ 	clear {
#@ 	    # Remove all locales not contained in Loclist
#@ 	    # skip any packages with package locale
#@ 	    set LoadedLocales $Loclist
#@ 	    foreach ns [dict keys $Msgs] {
#@ 		if {![dict exists $PackageConfig loclist $ns]} {
#@ 		    foreach locale [dict keys [dict get $Msgs $ns]] {
#@ 			if {$locale ni $Loclist} {
#@ 			    dict unset Msgs $ns $locale
#@ 			}
#@ 		    }
#@ 		}
#@ 	    }
#@ 	}
#@ 	loaded { return $LoadedLocales }
#@ 	default {
#@ 	    return -code error "unknown subcommand \"$subcommand\": must be\
#@ 		    clear, or loaded"
#@ 	}
#@     }
#@     return
#@ }
#@ 
#@ # msgcat::mcpackagelocale --
#@ #
#@ #	Get or change the package locale of the calling package.
#@ #
#@ #	The following subcommands are available:
#@ #	set
#@ #	    Set a package locale.
#@ #	    This may load message catalog files and may clear message catalog
#@ #	    items, if the former locale was the default locale.
#@ #	    Returns the normalized set locale.
#@ #	    The default locale is taken, if locale is not given.
#@ #	get
#@ #	    Get the locale valid for this package.
#@ #	isset
#@ #	    Returns true, if a package locale is set
#@ #	unset
#@ #	    Unset the package locale and activate the default locale.
#@ #	    This loads message catalog file which where missing in the package
#@ #	    locale.
#@ #	preferences
#@ #	    Return locale preference list valid for the package.
#@ #	loaded
#@ #	    Return loaded locale list valid for the current package.
#@ #	clear
#@ #	    If the current package has a package locale, remove all package
#@ #	    locales not containes in package mcpreferences.
#@ #	    It is an error to call this without a package locale set.
#@ #
#@ #	The subcommands get, preferences and loaded return the corresponding
#@ #	default data, if no package locale is set.
#@ #
#@ # Arguments:
#@ #	subcommand		see list above
#@ #	locale			package locale (only set subcommand)
#@ #
#@ # Results:
#@ #	Empty string, if not stated differently for the subcommand
#@ 
#@ proc msgcat::mcpackagelocale {subcommand {locale ""}} {
#@     # todo: implement using an ensemble
#@     variable Loclist
#@     variable LoadedLocales
#@     variable Msgs
#@     variable PackageConfig
#@     # Check option
#@     # check if required item is exactly provided
#@     if {[llength [info level 0]] == 2} {
#@ 	# locale not given
#@ 	unset locale
#@     } else {
#@ 	# locale given
#@ 	if {$subcommand in
#@ 		{"get" "isset" "unset" "preferences" "loaded" "clear"} } {
#@ 	    return -code error "wrong # args: should be\
#@ 		    \"[lrange [info level 0] 0 1]\""
#@ 	}
#@         set locale [string tolower $locale]
#@     }
#@     set ns [uplevel 1 {::namespace current}]
#@ 
#@     switch -exact -- $subcommand {
#@ 	get { return [lindex [PackagePreferences $ns] 0] }
#@ 	preferences { return [PackagePreferences $ns] }
#@ 	loaded { return [PackageLocales $ns] }
#@ 	present { return [expr {$locale in [PackageLocales $ns]} ]}
#@ 	isset { return [dict exists $PackageConfig loclist $ns] }
#@ 	set { # set a package locale or add a package locale
#@ 
#@ 	    # Copy the default locale if no package locale set so far
#@ 	    if {![dict exists $PackageConfig loclist $ns]} {
#@ 		dict set PackageConfig loclist $ns $Loclist
#@ 		dict set PackageConfig loadedlocales $ns $LoadedLocales
#@ 	    }
#@ 
#@ 	    # Check if changed
#@ 	    set loclist [dict get $PackageConfig loclist $ns]
#@ 	    if {! [info exists locale] || $locale eq [lindex $loclist 0] } {
#@ 		return [lindex $loclist 0]
#@ 	    }
#@ 
#@ 	    # Change loclist
#@ 	    set loclist [GetPreferences $locale]
#@ 	    set locale [lindex $loclist 0]
#@ 	    dict set PackageConfig loclist $ns $loclist
#@ 
#@ 	    # load eventual missing locales
#@ 	    set loadedLocales [dict get $PackageConfig loadedlocales $ns]
#@ 	    if {$locale in $loadedLocales} { return $locale }
#@ 	    set loadLocales [ListComplement $loadedLocales $loclist]
#@ 	    dict set PackageConfig loadedlocales $ns\
#@ 		    [concat $loadedLocales $loadLocales]
#@ 	    Load $ns $loadLocales
#@ 	    return $locale
#@ 	}
#@ 	clear { # Remove all locales not contained in Loclist
#@ 	    if {![dict exists $PackageConfig loclist $ns]} {
#@ 		return -code error "clear only when package locale set"
#@ 	    }
#@ 	    set loclist [dict get $PackageConfig loclist $ns]
#@ 	    dict set PackageConfig loadedlocales $ns $loclist
#@ 	    if {[dict exists $Msgs $ns]} {
#@ 		foreach locale [dict keys [dict get $Msgs $ns]] {
#@ 		    if {$locale ni $loclist} {
#@ 			dict unset Msgs $ns $locale
#@ 		    }
#@ 		}
#@ 	    }
#@ 	}
#@ 	unset {	# unset package locale and restore default locales
#@ 
#@ 	    if { ![dict exists $PackageConfig loclist $ns] } { return }
#@ 
#@ 	    # unset package locale
#@ 	    set loadLocales [ListComplement\
#@ 		    [dict get $PackageConfig loadedlocales $ns] $LoadedLocales]
#@ 	    dict unset PackageConfig loadedlocales $ns
#@ 	    dict unset PackageConfig loclist $ns
#@ 
#@ 	    # unset keys not in global loaded locales
#@ 	    if {[dict exists $Msgs $ns]} {
#@ 		foreach locale [dict keys [dict get $Msgs $ns]] {
#@ 		    if {$locale ni $LoadedLocales} {
#@ 			dict unset Msgs $ns $locale
#@ 		    }
#@ 		}
#@ 	    }
#@ 
#@ 	    # Add missing locales
#@ 	    Load $ns $loadLocales
#@ 	}
#@ 	default {
#@ 	    return -code error "unknown subcommand \"$subcommand\": must be\
#@ 		    clear, get, isset, loaded, present, set, or unset"
#@ 	}
#@     }
#@     return
#@ }
#@ 
#@ # msgcat::mcforgetpackage --
#@ #
#@ #	Remove any data of the calling package from msgcat
#@ #
#@ 
#@ proc msgcat::mcforgetpackage {} {
#@     # todo: this may be implemented using an ensemble
#@     variable PackageConfig
#@     variable Msgs
#@     set ns [uplevel 1 {::namespace current}]
#@     # Remove MC items
#@     dict unset Msgs $ns
#@     # Remove config items
#@     foreach key [dict keys $PackageConfig] {
#@ 	dict unset PackageConfig $key $ns
#@     }
#@     return
#@ }
#@ 
#@ # msgcat::mcpackageconfig --
#@ #
#@ #	Get or modify the per caller namespace (e.g. packages) config options.
#@ #
#@ #	Available subcommands are:
#@ #
#@ #	    get		get the current value or an error if not set.
#@ #	    isset	return true, if the option is set
#@ #	    set		set the value (see also distinct option).
#@ #			Returns the number of loaded message files.
#@ #	    unset	Clear option. return "".
#@ #
#@ #	Available options are:
#@ #
#@ #	mcfolder
#@ #	    The message catalog folder of the package.
#@ #	    This is automatically set by mcload.
#@ #	    If the value is changed using the set subcommand, an evntual
#@ #	    loadcmd is invoked and all message files of the package locale are
#@ #	    loaded.
#@ #
#@ #	loadcmd
#@ #	    The command gets executed before a message file would be
#@ #	    sourced for this module.
#@ #	    The command is invoked with the expanded locale list to load.
#@ #	    The command is not invoked if the registering package namespace
#@ #	    is not present.
#@ #	    This callback might also be used as an alternative to message
#@ #	    files.
#@ #	    If the value is changed using the set subcommand, the callback is
#@ #	    directly invoked with the current file locale list. No file load is
#@ #	    executed.
#@ #
#@ #	changecmd
#@ #	    The command is invoked, after an executed locale change.
#@ #	    Appended argument is expanded mcpreferences.
#@ #
#@ #	unknowncmd
#@ #	    Use a package locale mcunknown procedure instead the global one.
#@ #	    The appended arguments are identical to mcunknown.
#@ #	    A default unknown handler is used if set to the empty string.
#@ #	    This consists in returning the key if no arguments are given.
#@ #	    With given arguments, format is used to process the arguments.
#@ #
#@ # Arguments:
#@ #	subcommand		Operation on the package
#@ #	option			The package option to get or set.
#@ #	?value?			Eventual value for the subcommand
#@ #
#@ # Results:
#@ #	Depends on the subcommand and option and is described there
#@ 
#@ proc msgcat::mcpackageconfig {subcommand option {value ""}} {
#@     variable PackageConfig
#@     # get namespace
#@     set ns [uplevel 1 {::namespace current}]
#@ 
#@     if {$option ni {"mcfolder" "loadcmd" "changecmd" "unknowncmd"}} {
#@ 	return -code error "bad option \"$option\": must be mcfolder, loadcmd,\
#@ 		changecmd, or unknowncmd"
#@     }
#@ 
#@     # check if value argument is exactly provided
#@     if {[llength [info level 0]] == 4 } {
#@ 	# value provided
#@ 	if {$subcommand in {"get" "isset" "unset"}} {
#@ 	    return -code error "wrong # args: should be\
#@ 		    \"[lrange [info level 0] 0 2] value\""
#@ 	}
#@     } elseif {$subcommand eq "set"} {
#@         return -code error\
#@ 		"wrong # args: should be \"[lrange [info level 0] 0 2]\""
#@     }
#@ 
#@     # Execute subcommands
#@     switch -exact -- $subcommand {
#@ 	get {	# Operation get return current value
#@ 	    if {![dict exists $PackageConfig $option $ns]} {
#@ 		return -code error "package option \"$option\" not set"
#@ 	    }
#@ 	    return [dict get $PackageConfig $option $ns]
#@ 	}
#@ 	isset {	return [dict exists $PackageConfig $option $ns] }
#@ 	unset {	dict unset PackageConfig $option $ns }
#@ 	set {	# Set option
#@ 
#@ 	    if {$option eq "mcfolder"} {
#@ 		set value [file normalize $value]
#@ 	    }
#@ 	    # Check if changed
#@ 	    if { [dict exists $PackageConfig $option $ns]
#@ 		    && $value eq [dict get $PackageConfig $option $ns] } {
#@ 		return 0
#@ 	    }
#@ 
#@ 	    # set new value
#@ 	    dict set PackageConfig $option $ns $value
#@ 
#@ 	    # Reload pending message catalogs
#@ 	    switch -exact -- $option {
#@ 		mcfolder { return [Load $ns [PackageLocales $ns]] }
#@ 		loadcmd { return [Load $ns [PackageLocales $ns] 1] }
#@ 	    }
#@ 	    return 0
#@ 	}
#@ 	default {
#@ 	    return -code error "unknown subcommand \"$subcommand\":\
#@ 		    must be get, isset, set, or unset"
#@ 	}
#@     }
#@     return
#@ }
#@ 
#@ # msgcat::PackagePreferences --
#@ #
#@ #	Return eventual present package preferences or the default list if not
#@ #	present.
#@ #
#@ # Arguments:
#@ #	ns		Package namespace
#@ #
#@ # Results:
#@ #	locale list
#@ 
#@ proc msgcat::PackagePreferences {ns} {
#@     variable PackageConfig
#@     if {[dict exists $PackageConfig loclist $ns]} {
#@ 	return [dict get $PackageConfig loclist $ns]
#@     }
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::PackageLocales --
#@ #
#@ #	Return eventual present package locales or the default list if not
#@ #	present.
#@ #
#@ # Arguments:
#@ #	ns		Package namespace
#@ #
#@ # Results:
#@ #	locale list
#@ 
#@ proc msgcat::PackageLocales {ns} {
#@     variable PackageConfig
#@     if {[dict exists $PackageConfig loadedlocales $ns]} {
#@ 	return [dict get $PackageConfig loadedlocales $ns]
#@     }
#@     variable LoadedLocales
#@     return $LoadedLocales
#@ }
#@ 
#@ # msgcat::ListComplement --
#@ #
#@ #	Build the complement of two lists.
#@ #	Return a list with all elements in list2 but not in list1.
#@ #	Optionally return the intersection.
#@ #
#@ # Arguments:
#@ #	list1		excluded list
#@ #	list2		included list
#@ #	inlistname	If not "", write in this variable the intersection list
#@ #
#@ # Results:
#@ #	list with all elements in list2 but not in list1
#@ 
#@ proc msgcat::ListComplement {list1 list2 {inlistname ""}} {
#@     if {"" ne $inlistname} {
#@ 	upvar 1 $inlistname inlist
#@     }
#@     set inlist {}
#@     set outlist {}
#@     foreach item $list2 {
#@ 	if {$item in $list1} {
#@ 	    lappend inlist $item
#@ 	} else {
#@ 	    lappend outlist $item
#@ 	}
#@     }
#@     return $outlist
#@ }
#@ 
#@ # msgcat::mcload --
#@ #
#@ #	Attempt to load message catalogs for each locale in the
#@ #	preference list from the specified directory.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::mcload {langdir} {
#@     return [uplevel 1 [list\
#@ 	    [namespace origin mcpackageconfig] set mcfolder $langdir]]
#@ }
#@ 
#@ # msgcat::LoadAll --
#@ #
#@ #	Load a list of locales for all packages not having a package locale
#@ #	list.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::LoadAll {locales} {
#@     variable PackageConfig
#@     variable LoadedLocales
#@     if {0 == [llength $locales]} { return {} }
#@     # filter jet unloaded locales
#@     set locales [ListComplement $LoadedLocales $locales]
#@     if {0 == [llength $locales]} { return {} }
#@     lappend LoadedLocales {*}$locales
#@ 
#@     set packages [lsort -unique [concat\
#@ 	    [dict keys [dict get $PackageConfig loadcmd]]\
#@ 	    [dict keys [dict get $PackageConfig mcfolder]]]]
#@     foreach ns $packages {
#@ 	if {! [dict exists $PackageConfig loclist $ns] } {
#@ 	    Load $ns $locales
#@ 	}
#@     }
#@     return $locales
#@ }
#@ 
#@ # msgcat::Load --
#@ #
#@ #	Invoke message load callback and load message catalog files.
#@ #
#@ # Arguments:
#@ #	ns		Namespace (equal package) to load the message catalog.
#@ #	locales		List of locales to load.
#@ #	callbackonly	true if only callback should be invoked
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::Load {ns locales {callbackonly 0}} {
#@     variable FileLocale
#@     variable PackageConfig
#@     variable LoadedLocals
#@ 
#@     if {0 == [llength $locales]} { return 0 }
#@ 
#@     # Invoke callback
#@     Invoke loadcmd $locales $ns
#@ 
#@     if {$callbackonly || ![dict exists $PackageConfig mcfolder $ns]} {
#@ 	return 0
#@     }
#@ 
#@     # Invoke file load
#@     set langdir [dict get $PackageConfig mcfolder $ns]
#@ 
#@     # Save the file locale if we are recursively called
#@     if {[info exists FileLocale]} {
#@ 	set nestedFileLocale $FileLocale
#@     }
#@     set x 0
#@     foreach p $locales {
#@ 	if {$p eq {}} {
#@ 	    set p ROOT
#@ 	}
#@ 	set langfile [file join $langdir $p.msg]
#@ 	if {[file exists $langfile]} {
#@ 	    incr x
#@ 	    set FileLocale [string tolower\
#@ 		    [file tail [file rootname $langfile]]]
#@ 	    if {"root" eq $FileLocale} {
#@ 		set FileLocale ""
#@ 	    }
#@ 	    namespace inscope $ns [list ::source -encoding utf-8 $langfile]
#@ 	    unset FileLocale
#@ 	}
#@     }
#@     if {[info exists nestedFileLocale]} {
#@ 	set FileLocale $nestedFileLocale
#@     }
#@     return $x
#@ }
#@ 
#@ # msgcat::Invoke --
#@ #
#@ #	Invoke a set of registered callbacks.
#@ #	The callback is only invoked, if its registered namespace exists.
#@ #
#@ # Arguments:
#@ #	index		Index into PackageConfig to get callback command
#@ #	arglist		parameters to the callback invocation
#@ #	ns		(Optional) package to call.
#@ #			If not given or empty, check all registered packages.
#@ #	resultname	Variable to save the callback result of the last called
#@ #			callback to. May be set to "" to discard the result.
#@ #	failerror (0)	Fail on error if true. Otherwise call bgerror.
#@ #
#@ # Results:
#@ #	Possible values:
#@ #	- 0: no valid command registered
#@ #	- 1: registered command was the empty string
#@ #	- 2: registered command called, resultname is set
#@ #	- 3: registered command failed
#@ #	If multiple commands are called, the maximum of all results is returned.
#@ 
#@ proc msgcat::Invoke {index arglist {ns ""} {resultname ""} {failerror 0}} {
#@     variable PackageConfig
#@     variable Config
#@     if {"" ne $resultname} {
#@ 	upvar 1 $resultname result
#@     }
#@     if {"" eq $ns} {
#@ 	set packageList [dict keys [dict get $PackageConfig $index]]
#@     } else {
#@ 	set packageList [list $ns]
#@     }
#@     set ret 0
#@     foreach ns $packageList {
#@ 	if {[dict exists $PackageConfig $index $ns] && [namespace exists $ns]} {
#@ 	    set cmd [dict get $PackageConfig $index $ns]
#@ 	    if {"" eq $cmd} {
#@ 		if {$ret == 0} {set ret 1}
#@ 	    } else {
#@ 		if {$failerror} {
#@ 		    set result [namespace inscope $ns $cmd {*}$arglist]
#@ 		    set ret 2
#@ 		} elseif {1 == [catch {
#@ 		    set result [namespace inscope $ns $cmd {*}$arglist]
#@ 		    if {$ret < 2} {set ret 2}
#@ 		} err derr]} {
#@ 		    after idle [concat [::interp bgerror ""]\
#@ 			    [list $err $derr]]
#@ 		    set ret 3
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@     return $ret
#@ }
#@ 
#@ # msgcat::mcset --
#@ #
#@ #	Set the translation for a given string in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcset {locale src {dest ""}} {
#@     variable Msgs
#@     if {[llength [info level 0]] == 3} { ;# dest not specified
#@ 	set dest $src
#@     }
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     set locale [string tolower $locale]
#@ 
#@     dict set Msgs $ns $locale $src $dest
#@     return $dest
#@ }
#@ 
#@ # msgcat::mcflset --
#@ #
#@ #	Set the translation for a given string in the current file locale.
#@ #
#@ # Arguments:
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcflset {src {dest ""}} {
#@     variable FileLocale
#@     variable Msgs
#@ 
#@     if {![info exists FileLocale]} {
#@ 	return -code error "must only be used inside a message catalog loaded\
#@ 		with ::msgcat::mcload"
#@     }
#@     return [uplevel 1 [list [namespace origin mcset] $FileLocale $src $dest]]
#@ }
#@ 
#@ # msgcat::mcmset --
#@ #
#@ #	Set the translation for multiple strings in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcmset {locale pairs} {
#@     variable Msgs
#@ 
#@     set length [llength $pairs]
#@     if {$length % 2} {
#@ 	return -code error "bad translation list:\
#@ 		should be \"[lindex [info level 0] 0] locale {src dest ...}\""
#@     }
#@ 
#@     set locale [string tolower $locale]
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     foreach {src dest} $pairs {
#@ 	dict set Msgs $ns $locale $src $dest
#@     }
#@ 
#@     return [expr {$length / 2}]
#@ }
#@ 
#@ # msgcat::mcflmset --
#@ #
#@ #	Set the translation for multiple strings in the mc file locale.
#@ #
#@ # Arguments:
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcflmset {pairs} {
#@     variable FileLocale
#@     variable Msgs
#@ 
#@     if {![info exists FileLocale]} {
#@ 	return -code error "must only be used inside a message catalog loaded\
#@ 		with ::msgcat::mcload"
#@     }
#@     return [uplevel 1 [list [namespace origin mcmset] $FileLocale $pairs]]
#@ }
#@ 
#@ # msgcat::mcunknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string and no unknowncmd is set for the current
#@ #	package. This routine is intended to be replaced
#@ #	by an application specific routine for error reporting
#@ #	purposes.  The default behavior is to return the source string.
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::mcunknown {args} {
#@     return [uplevel 1 [list [namespace origin DefaultUnknown] {*}$args]]
#@ }
#@ 
#@ # msgcat::DefaultUnknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string in the following circumstances:
#@ #	- Default global handler, if mcunknown is not redefined.
#@ #	- Per package handler, if the package sets unknowncmd to the empty
#@ #	  string.
#@ #	It returna the source string if the argument list is empty.
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		(unused) The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::DefaultUnknown {locale src args} {
#@     if {[llength $args]} {
#@ 	return [format $src {*}$args]
#@     } else {
#@ 	return $src
#@     }
#@ }
#@ 
#@ # msgcat::mcmax --
#@ #
#@ #	Calculates the maximum length of the translated strings of the given
#@ #	list.
#@ #
#@ # Arguments:
#@ #	args	strings to translate.
#@ #
#@ # Results:
#@ #	Returns the length of the longest translated string.
#@ 
#@ proc msgcat::mcmax {args} {
#@     set max 0
#@     foreach string $args {
#@ 	set translated [uplevel 1 [list [namespace origin mc] $string]]
#@ 	set len [string length $translated]
#@ 	if {$len>$max} {
#@ 	    set max $len
#@ 	}
#@     }
#@     return $max
#@ }
#@ 
#@ # Convert the locale values stored in environment variables to a form
#@ # suitable for passing to [mclocale]
#@ proc msgcat::ConvertLocale {value} {
#@     # Assume $value is of form: $language[_$territory][.$codeset][@modifier]
#@     # Convert to form: $language[_$territory][_$modifier]
#@     #
#@     # Comment out expanded RE version -- bugs alleged
#@     # regexp -expanded {
#@     #	^		# Match all the way to the beginning
#@     #	([^_.@]*)	# Match "lanugage"; ends with _, ., or @
#@     #	(_([^.@]*))?	# Match (optional) "territory"; starts with _
#@     #	([.]([^@]*))?	# Match (optional) "codeset"; starts with .
#@     #	(@(.*))?	# Match (optional) "modifier"; starts with @
#@     #	$		# Match all the way to the end
#@     # } $value -> language _ territory _ codeset _ modifier
#@     if {![regexp {^([^_.@]+)(_([^.@]*))?([.]([^@]*))?(@(.*))?$} $value \
#@ 	    -> language _ territory _ codeset _ modifier]} {
#@ 	return -code error "invalid locale '$value': empty language part"
#@     }
#@     set ret $language
#@     if {[string length $territory]} {
#@ 	append ret _$territory
#@     }
#@     if {[string length $modifier]} {
#@ 	append ret _$modifier
#@     }
#@     return $ret
#@ }
#@ 
#@ # Initialize the default locale
#@ proc msgcat::Init {} {
#@     global env
#@ 
#@     #
#@     # set default locale, try to get from environment
#@     #
#@     foreach varName {LC_ALL LC_MESSAGES LANG} {
#@ 	if {[info exists env($varName)] && ("" ne $env($varName))} {
#@ 	    if {![catch {
#@ 		mclocale [ConvertLocale $env($varName)]
#@ 	    }]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@     #
#@     # On Darwin, fallback to current CFLocale identifier if available.
#@     #
#@     if {[info exists ::tcl::mac::locale] && $::tcl::mac::locale ne ""} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $::tcl::mac::locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@     #
#@     # The rest of this routine is special processing for Windows or
#@     # Cygwin. All other platforms, get out now.
#@     #
#@     if {([info sharedlibextension] ne ".dll")
#@ 	    || [catch {package require registry}]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # On Windows or Cygwin, try to set locale depending on registry
#@     # settings, or fall back on locale of "C".
#@     #
#@ 
#@     # On Vista and later:
#@     # HCU/Control Panel/Desktop : PreferredUILanguages is for language packs,
#@     # HCU/Control Pannel/International : localName is the default locale.
#@     #
#@     # They contain the local string as RFC5646, composed of:
#@     # [a-z]{2,3} : language
#@     # -[a-z]{4}  : script (optional, translated by table Latn->latin)
#@     # -[a-z]{2}|[0-9]{3} : territory (optional, numerical region codes not used)
#@     # (-.*)* : variant, extension, private use (optional, not used)
#@     # Those are translated to local strings.
#@     # Examples: de-CH -> de_ch, sr-Latn-CS -> sr_cs@latin, es-419 -> es
#@     #
#@     foreach key {{HKEY_CURRENT_USER\Control Panel\Desktop} {HKEY_CURRENT_USER\Control Panel\International}}\
#@ 	    value {PreferredUILanguages localeName} {
#@ 	if {![catch {registry get $key $value} localeName]
#@ 		&& [regexp {^([a-z]{2,3})(?:-([a-z]{4}))?(?:-([a-z]{2}))?(?:-.+)?$}\
#@ 		    [string tolower $localeName] match locale script territory]} {
#@ 	    if {"" ne $territory} {
#@ 		append locale _ $territory
#@ 	    }
#@ 	    set modifierDict [dict create latn latin cyrl cyrillic]
#@ 	    if {[dict exists $modifierDict $script]} {
#@ 		append locale @ [dict get $modifierDict $script]
#@ 	    }
#@ 	    if {![catch {mclocale [ConvertLocale $locale]}]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@ 
#@     # then check value locale which contains a numerical language ID
#@     if {[catch {
#@ 	set locale [registry get $key "locale"]
#@     }]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # Keep trying to match against smaller and smaller suffixes
#@     # of the registry value, since the latter hexadigits appear
#@     # to determine general language and earlier hexadigits determine
#@     # more precise information, such as territory.  For example,
#@     #     0409 - English - United States
#@     #     0809 - English - United Kingdom
#@     # Add more translations to the WinRegToISO639 array above.
#@     #
#@     variable WinRegToISO639
#@     set locale [string tolower $locale]
#@     while {[string length $locale]} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale [dict get $WinRegToISO639 $locale]]
#@ 	}]} {
#@ 	    return
#@ 	}
#@ 	set locale [string range $locale 1 end]
#@     }
#@     #
#@     # No translation known.  Fall back on "C" locale
#@     #
#@     mclocale C
#@ }
#@ msgcat::Init
#@ # -- End source /shared/hwmisc/apps/synopsys/fm/2022.12/auxx/tcllib/lib/tcl8.6/msgcat/msgcat.tcl

#@ 
#@ # -- End source /work/aigbe/syn/q6chip/syn/runs1/brcm3_test_240725/common/common.tcl

#@ 
#@ if {[info exists sh_product_version] && [string match *2003.* $sh_product_version]} {
#@     set physical_library {}
#@ }
#@ 
#@ echo type = $type
#@ 
#@ set compile_log_format "%elap_time %trials %area %wns(.3) %tns %drc %endpoint"
#@ 
#@ # This takes PT & DC back to old DC behaviour (no default clock inferred on input ports)
#@ set timing_input_port_default_clock false
#@ # Just for PT
#@ set timing_report_unconstrained_paths true
#@ 
#@ # Then run some scripts
#@ source2 useful.tcl
#@ # -- Starting source useful.tcl

#@ 
#@ proc echoed {cmd} {
#@     puts $cmd
#@     uplevel $cmd 
#@ }
#@ 
#@ proc suppressed { errs cmd {verbose 0} } {
#@     # verbose: 0 = just suppress, 1 = print info if count>0, 2 = print warning if count>0, 3 = more info maybe .. last few messages ? 
#@     global suppress_errors
#@     foreach err $errs {
#@         suppress_message -force $err
#@         if { $verbose } { set before($err) [get_message_info -suppressed $err] }
#@     }
#@     set val [uplevel $cmd]
#@     foreach err $errs {
#@         unsuppress_message $err
#@         if { $verbose } { 
#@             array set info [get_message_info -id $err]
#@             set count [ expr $info(suppressed) - $before($err) ]
#@             if { $count > 0 } {
#@                 foreach l [split $cmd "\n"] {
#@                     regsub {^\s+} $l {} l
#@                     if { $l != {} } break
#@                 }
#@                 switch $verbose {
#@                 0 {}
#@                 1 { puts "Information: '$l...' suppressed $count warnings of $err ('$info(message)')" }
#@                 2 { puts "Warning: '$l...' suppressed $count warnings of $err ('$info(message)')" }
#@                 }
#@             }
#@         }
#@     }
#@     return $val
#@ }
#@ 
#@ proc quotemeta {str} {
#@     regsub -all -- {\W} $str {\\&} str
#@     return $str
#@ }
#@ 
#@ proc grep_collection {varname collection block} {
#@     set new {}
#@     upvar $varname $varname
#@     foreach_in_collection $varname $collection {
#@         if { [uplevel $block ] } {
#@             set new [add_to_collection $new [set $varname]]
#@         }
#@     }
#@     return $new
#@ }
#@ 
#@ proc map_collection {varname collection block} {
#@     set new {}
#@     upvar $varname $varname
#@     foreach_in_collection $varname $collection {
#@         lappend new [uplevel $block]
#@     }
#@     return $new
#@ }
#@ 
#@ proc simple_clock_waveform { period } {
#@     return [list 0.0 [expr $period / 2.0]]
#@ }
#@ 
#@ proc set_clock_latencies {clk_name tree_offsets {source {}} } {
#@     global analysis_type
#@ 
#@     set wc_offset  [lindex $tree_offsets 0]
#@     set bc_offset  [lindex $tree_offsets end]
#@     if { [llength $tree_offsets] == 3 } {
#@         set nom_offset [lindex $tree_offsets 1]
#@     } else {
#@         set nom_offset [expr $bc_offset + (($wc_offset - $bc_offset) / 3)]
#@     }
#@ 
#@     if { (![info exists analysis_type]) || ($analysis_type == {bc_wc}) } {
#@         eval "set_clock_latency -max $source $wc_offset $clk_name"
#@         eval "set_clock_latency -min $source $bc_offset $clk_name"
#@     } elseif { [string match *bc $analysis_type] } {
#@         eval "set_clock_latency $source $bc_offset $clk_name"
#@     } elseif { [string match *nom $analysis_type] } {
#@         eval "set_clock_latency $source $nom_offset $clk_name"
#@     } else {
#@         eval "set_clock_latency $source $wc_offset $clk_name"
#@     }
#@ }
#@ 
#@ proc get_internal_pins args {
#@     global access_internal_pins
#@     if { [ exists_and_false access_internal_pins] } {
#@ 
#@         set prev $access_internal_pins
#@         set access_internal_pins TRUE
#@ 
#@         set coll [get_pins {*}$args]
#@ 
#@         set access_internal_pins $prev
#@ 
#@         return $coll
#@     } else {
#@         return [get_pins {*}$args]
#@     } 
#@ }
#@ 
#@ proc get_hierarchical_subdesigns {} {
#@     set refs [get_attribute [get_cells * -filter "@is_hierarchical==true"] ref_name]
#@     return [find design $refs]
#@ }
#@ 
#@ proc get_all_hierarchical_subdesigns {} {
#@     set refs [get_attribute [get_cells * -hier -filter "@is_hierarchical==true"] ref_name]
#@     return [find design $refs]
#@ }
#@ 
#@ proc ungroup_things {design_pattern { arg1 arg1 } { arg2 arg2 }} {
#@ 
#@     global sh_dev_null
#@     redirect $sh_dev_null {set orig_design [current_design]}
#@     
#@     if {$arg1 != "arg1" && $arg1 != "no_flatten" && $arg1 != "no_name_change" &&
#@         $arg2 != "arg2" && $arg2 != "no_flatten" && $arg2 != "no_name_change"  } {
#@         echo "Err\or : Invalid arguments to ungroup_things procedure"
#@         echo "Syntax: ungroup_things design_name {no_flatten} {no_name_change}"
#@         return
#@     }  
#@ 
#@     set all_hier_cells [get_cells * -filter "@is_hierarchical == true"]
#@     
#@     set do_flatten 1
#@     if {$arg1 == "no_flatten" || $arg2 == "no_flatten"} {
#@       set do_flatten 0
#@     }
#@     
#@     set match_cells ""
#@     set match_designs ""
#@     set nonmatch_cells ""
#@     set nonmatch_designs ""
#@ 
#@     foreach_in_collection this_cell $all_hier_cells {
#@       set this_design [get_designs [get_attribute -quiet $this_cell ref_name]]
#@       if { [string match $design_pattern [get_object_name $this_design]] } {
#@         set match_cells [add_to_collection $match_cells $this_cell]
#@         set match_designs [add_to_collection -unique $match_designs $this_design]
#@       } else {
#@         set nonmatch_cells [add_to_collection $nonmatch_cells $this_cell]
#@         set nonmatch_designs [add_to_collection -unique $nonmatch_designs $this_design]
#@       }
#@     }
#@ 
#@     # first, go into any non-matching designs (or all designs if we are not flattening)
#@     
#@     if { ! $do_flatten } {
#@       set nonmatch_designs [ add_to_collection $nonmatch_designs $match_designs ]
#@     }
#@     
#@     foreach_in_collection this_design $nonmatch_designs {
#@       redirect $sh_dev_null { current_design $this_design }
#@       ungroup_things $design_pattern $arg1 $arg2
#@     }
#@     
#@     redirect $sh_dev_null {current_design $orig_design}
#@ 
#@     # now ungroup what we need to at this level
#@     
#@     if {$match_cells != ""} {
#@       foreach_in_collection individual_cell $match_cells {
#@         echo "Ungrouping cell [get_object_name $individual_cell]/[get_attribute $individual_cell ref_name] in [get_object_name $orig_design]..."
#@       }
#@       if { $do_flatten } {
#@           ungroup -flatten -simple_names $match_cells
#@       } else {
#@           foreach cell_name [get_object_name $match_cells] {
#@               ungroup -prefix ${cell_name}_ [get_cells $cell_name]
#@           }
#@       }
#@     }
#@ }
#@ 
#@ proc link_current_design {} {
#@     if { [ get_attribute [current_design] linked] == "false" } {
#@         link
#@     }
#@ }
#@ 
#@ # And some totally general tcl routines
#@ 
#@ proc lfirst {list} {
#@     return [lindex $list 0]
#@ }
#@ 
#@ proc lsecond { list } {
#@     return [lindex $list 1]
#@ }
#@ 
#@ proc llast {list} {
#@     return [lindex $list end]
#@ }
#@ 
#@ proc dirname {thing} {
#@     # Use with great care - has different semantics from [file dirname thing]
#@     # in particular when $thing is of the form '/filename' or 'filename'
#@         
#@     # probably better
#@     if { [regexp {(.*)\/([^\/]+)$} $thing dummy dirname filename] } {
#@         return $dirname
#@     } else {
#@         return {}
#@     }
#@    
#@ }
#@ 
#@ proc filename {thing} {
#@     if { [regexp {(.*)\/([^\/]+)$} $thing dummy dirname filename] } {
#@         return $filename
#@     } else {
#@         return $thing
#@     }
#@ }
#@ 
#@ proc show {__name} {
#@     upvar $__name $__name
#@     set __list {}
#@     if { [array exists $__name] } {
#@         foreach thing [array names $__name] {
#@             set __list "${__list}set ${__name}($thing) \{[set ${__name}($thing)]\}\n"
#@         }
#@         # delete the last \n ? can't be bothered
#@     } elseif { [info exists $__name] } {
#@         set __list "set $__name \{[set $__name]\}"
#@     }
#@     return $__list
#@ }
#@ 
#@ # Note - rcrp is a variable in 2002.03
#@ proc derate {} {
#@     global analysis_type
#@     global ocv_derate_factor
#@     global timing_remove_clock_reconvergence_pessimism
#@     if {  [string match *ocv* $analysis_type] } {
#@        echo Doing timing_derate -min $ocv_derate_factor
#@        set_timing_derate -min $ocv_derate_factor -max 1.00
#@        set timing_remove_clock_reconvergence_pessimism true
#@        set timing_crpr_threshold_ps 10
#@        set timing_reconvergence_pessimism normal
#@     } else {
#@         # This includes tcv
#@         set_timing_derate -min 1.00 -max 1.00
#@         set timing_remove_clock_reconvergence_pessimism false
#@     }
#@ }
#@ 
#@ proc no_derate {} {
#@     global rcrp
#@     set_timing_derate -min 1.00 -max 1.00
#@ }
#@ 
#@ 
#@ # This is copied from rdverilog.tcl as it is generally useful.
#@ # It is still in rdverilog.tcl - can we be sure this useful.tcl has always been run?
#@ proc set_current_design_from_prefixed_filename str {
#@     # filenames typically have prefixes e.g. prefloorplan_q2chip
#@     # this routine strips off prefixes one at a time looking for a design name match
#@     set str [file rootname [file tail $str]]
#@     while { $str != {} } {
#@         if { [suppressed UID-109 {find design $str}] != {} } {
#@             puts "Found module matching filename '$str'"
#@             current_design $str
#@             return
#@         } else {
#@             puts "No design called '$str'"
#@         }
#@         if { [regexp {^[^_]*_(.*)} $str {} str] == 0 } {
#@             break;
#@         }
#@     }
#@ }
#@ 
#@ proc load_the_netlist { {design_name {}} } {
#@ 
#@     global input_file_base
#@     global input_file
#@     global top
#@     global svr_keep_unconnected_nets
#@ 
#@     # Verilog netlist is preferred source
#@     if {[file exists ${input_file_base}.v]} {
#@         echo Reading Verilog netlist
#@         set svr_keep_unconnected_nets true
#@         read_verilog ${input_file_base}.v
#@     } elseif {[file exists $input_file]} {
#@         echo Reading db netlist
#@         read_db -netlist_only $input_file
#@     } else {
#@         echo Err\or: Cannot find input file $input_file
#@         exit
#@     }
#@     if { [llength $design_name] == 0 } {
#@         set_current_design_from_prefixed_filename $input_file_base
#@     } else {
#@         current_design $design_name
#@     }
#@     link
#@     set top [get_object_name [current_design]]
#@ }
#@ 
#@ # For reference, this is what proc read_some_sdf used to do...
#@ #
#@ # proc read_some_sdf {fname analysis_type} {
#@ #     if { $analysis_type == {ocv_bc} } {
#@ #         read_sdf -analysis_type on_chip_variation $fname -min_type sdf_min -max_type sdf_min
#@ #     } elseif { $analysis_type == {ocv_wc} } {
#@ #         read_sdf -analysis_type on_chip_variation $fname -min_type sdf_max -max_type sdf_max
#@ #     } elseif { $analysis_type == {ocv_nom} } {
#@ #         read_sdf -analysis_type on_chip_variation $fname -min_type sdf_typ -max_type sdf_typ
#@ #     } elseif { ($analysis_type == {bc}) || ($analysis_type == {tcv_bc}) } {
#@ #         read_sdf -analysis_type single -type sdf_min $fname
#@ #     } elseif { ($analysis_type == {wc}) || ($analysis_type == {tcv_wc}) } {
#@ #         read_sdf -analysis_type single -type sdf_max $fname 
#@ #     } elseif { ($analysis_type == {nom}) } {
#@ #          read_sdf -analysis_type single -type sdf_typ $fname 
#@ #     } elseif { ($analysis_type == {bc_wc}) } {
#@ #         # Defaults to sdf_min, sdf_max
#@ #         read_sdf -analysis_type bc_wc $fname
#@ #     } else {
#@ #         echo "Err\or: Unknown analysis_type $analysis_type"
#@ #     }
#@ # }
#@ 
#@ proc read_some_sdf {fname mode} {
#@ 
#@     set fname [maybe_gzipped $fname]
#@ 
#@     if { [lfirst $mode] == {ocv} } {
#@         read_sdf -analysis_type on_chip_variation $fname -min_type sdf_[lindex $mode 1] -max_type sdf_[lindex $mode 2]
#@     } elseif { [lfirst $mode] == {single} } {
#@         read_sdf -analysis_type  single -type sdf_[lindex $mode 1] $fname
#@     } elseif { [lfirst $mode] == {bc_wc} } {
#@         # By default reads 'sdf_min' for min_type & 'sdf_max' for max_type
#@         if { ([llength $fname] == 1) } {
#@             read_sdf -analysis_type bc_wc $fname
#@         } else {
#@             # This works fine with one SDF file BUT reads the file twice
#@             read_sdf -analysis_type bc_wc -min_file [lfirst $fname] -max_file [llast $fname]
#@         }
#@     } else {
#@         echo "Err\or: read_some_sdf unknown sdf mode $mode"
#@     }
#@ }
#@ 
#@ proc analysis_type_to_sdf_mode_for_bc_wc_sdf {analysis_type} {
#@     if { $analysis_type == {ocv_bc} } {
#@         return {ocv min min}
#@     } elseif { $analysis_type == {ocv_wc} } {
#@         return {ocv max max}
#@     } elseif { $analysis_type == {ocv_nom} } {
#@         return {ocv typ typ}
#@     } elseif { ($analysis_type == {bc}) || ($analysis_type == {tcv_bc}) } {
#@         return {single min}
#@     } elseif { ($analysis_type == {wc}) || ($analysis_type == {tcv_wc}) } {
#@         return {single max}
#@     } elseif { $analysis_type == {nom} } {
#@         return {single typ}
#@     } elseif { $analysis_type == {bc_wc} } {
#@         return {bc_wc}
#@     } else {
#@         echo "Err\or: Unknown analysis_type $analysis_type"
#@     }
#@ }
#@ 
#@ proc analysis_type_to_sdf_mode {analysis_type} {
#@     if { [string match ocv* $analysis_type] } {
#@         return {ocv min max}
#@     } elseif { ($analysis_type == {bc}) || ($analysis_type == {tcv_bc}) } {
#@         return {single min}
#@     } elseif { ($analysis_type == {wc}) || ($analysis_type == {tcv_wc}) } {
#@         return {single max}
#@     } elseif { $analysis_type == {nom} } {
#@         return {single typ}
#@     } elseif { $analysis_type == {bc_wc} } {
#@         return {bc_wc}
#@     } else {
#@         echo "Err\or: Unknown analysis_type $analysis_type"
#@     }
#@ }
#@ 
#@ proc setup_type_early {} {
#@     global type
#@     global env
#@     global default_type
#@ 
#@     if {[info exists type]} {
#@         regsub -all HYPHEN $type - type
#@     } elseif {[array get env SYNOPSYS_SCRIPT_TYPE] != {}} {
#@         set type [getenv SYNOPSYS_SCRIPT_TYPE]
#@     } else {
#@         if {[info exists default_type]} {
#@             set type $default_type
#@         } else {
#@             set type {}
#@         }
#@     }
#@     return $type
#@ }
#@ 
#@ # Need this in useful (rather than quseful) so old scripts work
#@ proc setup_analysis { raw_type {lib_opt {}} } {
#@     global input_file_base
#@     global force_ocv_derate_factor
#@     # Sets these:
#@     global analysis_type
#@     global ocv_derate_factor
#@     global trep_ext
#@     # And possibly these:
#@     global only_use_min_library
#@     global only_use_typ_library
#@     global dont_use_min_library
#@ 
#@     if {[regexp {(ocv_|tcv_|bc_)?(bc|nom|wc)_?(0\.\d*)?} $raw_type full a b c]} {
#@ #        echo a,b,c $a $b $c
#@         set analysis_type ${a}${b}
#@         echo Setting analysis_type $analysis_type
#@ 
#@         set trep_ext -${analysis_type}
#@ 
#@         if { [info exists force_ocv_derate_factor] } {
#@             set ocv_derate_factor $force_ocv_derate_factor
#@             echo ocv_derate_factor has been forced to $ocv_derate_factor
#@             set trep_ext ${trep_ext}_${ocv_derate_factor}
#@         } else {
#@             if { $a == {ocv_} || $a == {tcv_} } {
#@                 if { $c != {} } {
#@                     set ocv_derate_factor $c
#@                 } else {
#@                     set ocv_derate_factor 1.0
#@                 }
#@                 echo Setting ocv_derate_factor $ocv_derate_factor
#@                 set trep_ext ${trep_ext}_${ocv_derate_factor}
#@             }
#@         }
#@     } else {
#@         echo "Err\or: Don't understand (raw) analysis type $raw_type"
#@         return {}
#@     } 
#@     echo Timing report file extension: $trep_ext
#@ 
#@     if { [llength $lib_opt] != 0 && [string match exact* $lib_opt] } {
#@ 
#@         if { [string match bc_wc $analysis_type] } {
#@             echo Loading max & min libraries
#@         } elseif { [string match *bc $analysis_type] } {
#@             # bc, ocv_bc
#@             echo Loading min library only
#@             set only_use_min_library true
#@         } elseif { [string match *nom $analysis_type] } {
#@             # nom, ocv_nom
#@             echo Loading typ library only
#@             set only_use_typ_library true
#@         } elseif { [string match *wc $analysis_type] } {
#@             # wc, ocv_wc
#@             echo Loading max library only
#@             set dont_use_min_library true
#@         } else {
#@             echo "Err\or: Don't understand (new) analysis type $analysis_type"
#@         }
#@     }
#@ 
#@ }
#@ 
#@ # Add to collection stuff
#@ 
#@ # Usage:
#@ #
#@ # set grp {}
#@ # set grp [add_to_collection_group $grp $collection1]
#@ # set grp [add_to_collection_group $grp $collection2]
#@ # set collection3 [resolve_collection_group $grp]
#@ ##
#@ # resolved collection group is always unique
#@ 
#@ 
#@ proc add_to_collection_group { grp col } {
#@     set grp [ linsert $grp 0 [list 1 $col] ]
#@     while {   ( [ llength $grp ] > 1 )
#@            && ( [lfirst [lfirst $grp]] == [lfirst [lsecond $grp]] ) } {
#@         set grp [lreplace $grp 0 1 [list [ expr [lfirst [lfirst $grp]] * 2] \
#@                 [add_to_collection [lsecond [lfirst $grp]] [lsecond [lsecond $grp]] -unique]]]
#@     }
#@     return $grp
#@ }
#@ 
#@ proc resolve_collection_group { grp } {
#@     set col {}
#@     foreach g $grp {
#@         set col [add_to_collection $col [lsecond $g] -unique]
#@     }
#@     return $col
#@ }
#@ 
#@ ####
#@ 
#@ proc pin_arrival_time { path pin } {
#@     if { [sizeof_collection $path] == 1 } {
#@         foreach_in_collection point [get_attribute $path points] {
#@             # arrival
#@             # object
#@             # object_class
#@             # rise_fall
#@             # slack
#@             set object [get_attribute $point object]
#@             if {    ([get_attribute $object object_class] == {pin}) \
#@                  && ([get_object_name $object] == [get_object_name $pin]) } {
#@ #                echo Found Pin [get_object_name $object] [get_attribute $point rise_fall] edge
#@ #                echo "  arrival time [get_attribute $point arrival]"
#@                 return [get_attribute $point arrival]
#@             }
#@         }
#@         echo "Err\or: proc 'pin_arrival_time' did not find [get_object_name $pin] in path"
#@         return {999}
#@     } else {
#@         echo "Err\or: proc 'pin_arrival_time' [sizeof_collection $path] paths is not exactly 1"
#@         return {990}
#@     }
#@ }
#@ 
#@ ####
#@ 
#@ proc maybe_gzipped { fname } {
#@     if { (! [file readable $fname]) && [file readable $fname.gz] } {
#@         set fname $fname.gz
#@         echo Found compressed file: $fname
#@     }
#@     return $fname
#@ }
#@ 
#@ proc recurse_references {des} {
#@     upvar designs_done designs_done
#@     current_design $des
#@     if { [get_object_name [current_design]] != $des } {
#@         echo "recurse_referenses err\or: unable to change design to '$des'"
#@         return
#@     }
#@     report_reference -nosplit
#@     foreach ref [map_collection c [get_cells * -filter @is_hierarchical] {get_attribute $c ref_name} ] {
#@         if { [lsearch -exact $designs_done $ref] == -1 } {
#@             recurse_references $ref
#@             lappend designs_done $ref
#@         }
#@     }
#@     current_design $des
#@ }
#@ 
#@ proc rep_area {fname} {
#@     set designs_done {}
#@     redirect $fname {
#@         report_area
#@         recurse_references [get_object_name [current_design]]
#@     }
#@ }
#@ 
#@ # # e.g. for virage memories...
#@ # # set_case_analysis_on_fixed_pins_old [list */AWT */SWT] {^VLOX} {^VHIX} 1
#@ # 
#@ # proc set_case_analysis_on_fixed_pins_old { patt {logic0 {^$}} {logic1 {^$}} {verbose 0} } {
#@ #     foreach_in_collection pin [get_pins -hierarchical $patt] {
#@ #         set net [all_connected $pin]
#@ #         foreach_in_collection pin2 [all_connected $net] {
#@ #             if {[get_attribute $pin2 pin_direction] == {out}} {
#@ #                 set cell [get_cells_of_objects $pin2]
#@ #                 set ref [get_attribute $cell ref_name]
#@ #                 if { [string match *logic_1* $ref] || [regexp $logic1 $ref] } {
#@ #                     if { $verbose } {
#@ #                         puts "set_case_analysis 1 [get_object_name $pin] attached to $ref"
#@ #                     }
#@ #                     set_case_analysis 1 $pin
#@ #                 } elseif { [string match *logic_0* $ref] || [regexp $logic0 $ref] } {
#@ #                     if { $verbose } {
#@ #                         puts "set_case_analysis 0 [get_object_name $pin] attached to $ref"
#@ #                     }
#@ #                     set_case_analysis 0 $pin
#@ #                 }
#@ #             }
#@ #         }
#@ #     }
#@ # }
#@ 
#@ proc driving_cell_type {net} {
#@ 
#@     # all_fanin causes a partial compile (allocating_blocks etc.) on unmapped logic
#@     #
#@     # set driving_cell [dirname [get_object_name [all_fanin -to $net]]]
#@     # return [suppressed SEL-005 {get_attribute -quiet $driving_cell ref_name}]
#@ 
#@     # so use this instead ...
#@     foreach_in_collection pin [all_connected $net] {
#@         if {[get_attribute $pin pin_direction] == {out}} {
#@             set cell [get_cells_of_objects $pin]
#@             return [get_attribute $cell ref_name]
#@         }
#@     }
#@     return {}
#@ }
#@ 
#@ proc is_tied_off {net {hilo {}}} {
#@     global tech_library_tieoff_cells
#@     if {[sizeof_collection [get_nets $net]] == 0} {
#@         return 0
#@     }
#@     set ref [driving_cell_type $net]
#@     set tieoff_cells {}
#@     if { $hilo != "high" } {
#@         lappend tieoff_cells {*logic_0*}
#@         if { [info exists tech_library_tieoff_cells] } {
#@             lappend tieoff_cells [lfirst $tech_library_tieoff_cells]
#@         }
#@     }
#@     if { $hilo != "low" } {
#@         lappend tieoff_cells {*logic_1*}
#@         if { [info exists tech_library_tieoff_cells] } {
#@             lappend tieoff_cells [lsecond $tech_library_tieoff_cells]
#@         }
#@     }
#@     foreach tieoff_cell $tieoff_cells {
#@         if { [string match $tieoff_cell $ref] } {
#@             return 1
#@         }
#@     }
#@     return 0
#@ }
#@ 
#@ # e.g. for virage memories...
#@ # set_case_analysis_on_fixed_pins [list */AWT */SWT] 1
#@ 
#@ proc set_case_analysis_on_fixed_pins { patt {verbose 0} {filter {}}} {
#@     if { $filter == {} || $filter == {is_hierarchical==false} } {
#@         set pins [suppressed {UID-95 SEL-004 SEL-005 } {get_pins -hierarchical $patt}]
#@     } else {
#@         set pins [suppressed {UID-95 SEL-004 SEL-005 } {get_pins -hierarchical $patt -filter $filter}]
#@     }
#@     foreach_in_collection pin $pins {
#@         if {$filter == {is_hierarchical==false} && [is_true [get_attribute [get_cells -of_objects $pin] is_hierarchical]]} {
#@             continue
#@         }
#@         set net [all_connected $pin]
#@         if { [is_tied_off $net high] } {
#@             if { $verbose } {
#@                 puts "set_case_analysis 1 [get_object_name $pin] attached to [driving_cell_type $net]"
#@             }
#@             set_case_analysis 1 $pin
#@         } elseif { [is_tied_off $net low] } {
#@             if { $verbose } {
#@                 puts "set_case_analysis 0 [get_object_name $pin] attached to [driving_cell_type $net]"
#@             }
#@             set_case_analysis 0 $pin
#@         } elseif { $verbose } {
#@             echo [get_object_name $pin] not connected to a tieoff cell, attached to net [get_object_name $net] and driven by [driving_cell_type $net]
#@         }
#@     }
#@ }
#@ 
#@ proc rep_high_fanout { {verbose false} } {
#@ 
#@     global high_fanout_net_threshold
#@     global high_fanout_net_pin_capacitance
#@     global report_file_base
#@ 
#@     set nets [all_high_fanout -net]
#@     set fname ${report_file_base}.rep_high_fanout
#@     
#@     if { [sizeof_collection $nets] != 0 } {            # stops report_net_fanout errors in small designs
#@     
#@         redirect $fname { 
#@             report_net_fanout -nosplit $nets
#@         }
#@         array unset tmp
#@         array set tmp {}
#@         foreach l [split [read [open $fname]] \n] {
#@             puts $l
#@             set tmp([lfirst [split $l]]) $l
#@         }
#@         if { $verbose } {
#@             puts "High fanout net threshold       = $high_fanout_net_threshold"
#@             puts "High fanout net pin capacitance = $high_fanout_net_pin_capacitance"
#@             puts ""
#@             foreach_in_collection net $nets {
#@                 set n [get_object_name $net]
#@                 if { ! [info exists tmp($n)] } {
#@                     puts "Err\or: $n not found in report (rep_high_fanout)"
#@                     continue
#@                 }
#@                 set l $tmp($n)
#@                 # Net                 Fanout   Attributes   Capacitance   Driver
#@                 # I/core_clock         88638   dr, d, I, h      0.00      I/D/TC/CORE/COREPLL/ROOTX1/U/Z
#@                 if { ! [regexp {([^ ]+) +(\d+) +(([a-zA-Z]+(, )?)*) +(\d+(\.\d+)?) +([^ ]+)} $l \
#@                       dummy netname fanout attributes dummy2 dummy3 capacitance dummy4 driving_pin_name] } {
#@                     puts "Err\or: '$l' in high fanout report unparsable (rep_high_fanout)"
#@                     continue
#@                 }
#@                 regsub -all { } $attributes {} attributes
#@                 if { [lsearch -regexp [split $attributes {,}] {^(i|I)$} ] != -1 } {
#@                     puts "Information: $n, fanout $fanout, is an ideal net (rep_high_fanout)"
#@                     continue
#@                 }
#@                 global clock_gate_cells
#@                 set driving_cell [get_cells -of_objects $driving_pin_name]
#@                 set driving_cell_ref_name [get_attribute $driving_cell ref_name]
#@                 regsub {_a(\d)+} $driving_cell_ref_name "" driving_cell_ref_name
#@                 if { [info exists clock_gate_cells($driving_cell_ref_name)] } {
#@                     set clock_pin [get_pins [get_object_name $driving_cell]/$clock_gate_cells($driving_cell_ref_name)]
#@                     if { [get_attribute [get_nets -of_objects $clock_pin] ideal_net] == {true} } {
#@                         puts "Information: $n, fanout $fanout, is the output of a clock gate (rep_high_fanout)"
#@                         continue
#@                     }
#@                 }
#@ 
#@                 if { $driving_pin_name == "multi-driver" } {
#@                     puts "Warning: $n, fanout $fanout, driven by '$driving_pin_name' (unknown driving cell) (rep_high_fanout)"
#@                 } else {
#@                     set root_net [all_connected [find pin $driving_pin_name]]
#@                     if { [is_tied_off $root_net] } {
#@                         puts "Information: $n, fanout $fanout, is tied off to a [driving_cell_type $net] (rep_high_fanout)"
#@                         continue
#@                     }
#@                     puts "Warning: $n, fanout $fanout, driven by '$driving_pin_name' ([driving_cell_type $root_net]) (rep_high_fanout)"
#@                 }
#@ 
#@             }
#@         }
#@     }
#@ }
#@ 
#@ # From q2useful.tcl
#@ 
#@ proc additional_ocv_derate {sh derate} {
#@ 
#@     global ocv_derate_factors
#@     global analysis_type
#@ 
#@     array unset factors
#@     array set   factors $ocv_derate_factors($analysis_type)
#@     lappend factors($sh) $derate
#@     set ocv_derate_factors($analysis_type) [array get factors]
#@ }
#@ 
#@ proc ocv_derate { setuphold } {
#@ 
#@     # Input parameters
#@     global analysis_type
#@     global ocv_derate_factors
#@     
#@     # Synopsus vars
#@     global timing_remove_clock_reconvergence_pessimism
#@     global timing_clock_reconvergence_pessimism
#@     global timing_crpr_threshold_ps
#@ 
#@     # Clear all exisiting deration
#@     reset_timing_derate
#@     
#@     if { [string match *ocv* $analysis_type] } {
#@     
#@         puts "Doing OCV derate for $setuphold timing"
#@         
#@         array set tmp $ocv_derate_factors($analysis_type)
#@         foreach l $tmp($setuphold) {
#@              echoed "set_timing_derate $l"
#@         }
#@          
#@         set timing_remove_clock_reconvergence_pessimism true
#@         # Alternative for this is 'same_transition':         
#@         set timing_clock_reconvergence_pessimism normal
#@         # Recommended this is set to half clock tree stage delay (gate + net). Default value is 20 ps
#@         # Technology dependant - put somewhere else appropriate?
#@         # Warn\ing: Setting this variable to a lower value can cause a significant performance degradation during a timing update. (PTE-067)
#@         if {! [info exists timing_crpr_threshold_ps] || $timing_crpr_threshold_ps > 10} {
#@             suppressed PTE-067 {set timing_crpr_threshold_ps 10}
#@         }
#@         
#@     } else {
#@          set timing_remove_clock_reconvergence_pessimism false
#@          
#@          echo "Err\or: ALL DERATE REMOVED - SPECIFIED ANALYSIS TYPE IS NON OCV"
#@     }
#@     
#@     # Report on the OCV variables
#@     
#@     global running_design_compiler
#@     if { ! $running_design_compiler } {
#@         report_timing_derate
#@     } else {
#@         # In DC we don't want to do this report on unmapped logic (as it causes mapping)
#@         set is_mapped [suppressed {ATTR-1} {get_attribute [current_design] is_mapped} ]
#@         if { "$is_mapped" == "true" } {
#@             report_timing_derate
#@         }
#@     }
#@     puts "timing_remove_clock_reconvergence_pessimism:  $timing_remove_clock_reconvergence_pessimism"
#@     puts "timing_clock_reconvergence_pessimism:         $timing_clock_reconvergence_pessimism"
#@     puts "timing_crpr_threshold_ps:                     $timing_crpr_threshold_ps"
#@ 
#@ }
#@ 
#@ # These routines below need to be duplicated in whatever chip's personal useful file. They are here
#@ # for reference only
#@ 
#@ # proc create_ref_clock { clk_name period {waveform {}} {tree_offset_wc 0.0} {tree_offset_bc 0.0}} {
#@ #     if { [llength $waveform] == 0 } {
#@ #         set waveform [simple_clock_waveform $period]
#@ #     }
#@ #     create_clock -name ref_$clk_name -period $period -waveform $waveform
#@ #     set_clock_latencies ref_$clk_name [list $tree_offset_wc $tree_offset_bc]
#@ # }
#@ # 
#@ # proc create_clock_from_root { clk_name root_name period tree_delay {waveform {}} } {
#@ #     global setup_uncertainty
#@ #     global hold_uncertainty
#@ #     global clock_transition
#@ #     
#@ #     if { [llength $waveform] == 0 } {
#@ #         set waveform [simple_clock_waveform $period]
#@ #     }
#@ # 
#@ #     if { ! [info exists clock_transition] } {
#@ #         set clock_transition 0.5
#@ #     }
#@ # 
#@ #     # W.....g: Creating a clock on internal pin '...'. (UITE-130)
#@ #     suppressed UITE-130 {create_clock $root_name -name $clk_name -period $period -waveform $waveform}
#@ #     
#@ #     find clock $clk_name
#@ #     
#@ #     set_clock_uncertainty -setup $setup_uncertainty $clk_name
#@ #     set_clock_uncertainty -hold  $hold_uncertainty  $clk_name
#@ #     
#@ #     set_clock_latencies $clk_name $tree_delay
#@ # 
#@ #     set_clock_transition $clock_transition $clk_name
#@ #     set_dont_touch_network $clk_name
#@ # }
#@ # 
#@ # proc create_real_clock_from_root { clk_name root_name period tree_offsets {waveform {}} } {
#@ #     
#@ #     global running_primetime
#@ #     global analysis_type
#@ #     if { ! [info exists analysis_type] } {
#@ #         # assume its bc_wc
#@ #         set analysis_type bc_wc
#@ #     }
#@ #     
#@ #     if { [llength $waveform] == 0 } {
#@ #         set waveform [simple_clock_waveform $period]
#@ #     }
#@ #     
#@ #     # Horrible hack to get PT-SI up and running (on Q)
#@ #     if { $running_primetime && ($clk_name == {clock_x2}) } {
#@ #         create_clock $root_name -name $clk_name -period $period -waveform $waveform -domain C1
#@ #     } else {
#@ #         create_clock $root_name -name $clk_name -period $period -waveform $waveform
#@ #     }
#@ # 
#@ #     find clock $clk_name
#@ # 
#@ #     set_propagated_clock $clk_name
#@ # 
#@ #     set_clock_latencies $clk_name $tree_offsets -source
#@ # 
#@ #     set_dont_touch_network $clk_name
#@ # }
#@ # 
#@ # proc create_named_clock_from_port { clock_name port_name period {waveform {}} } {
#@ #     global setup_uncertainty
#@ #     global hold_uncertainty
#@ #     global clock_transition
#@ #     global running_primetime
#@ #     
#@ #     if { [llength $waveform] == 0 } {
#@ #         set waveform [simple_clock_waveform $period]
#@ #     }
#@ # 
#@ #     if { ! [info exists clock_transition] } {
#@ #         set clock_transition 0.5
#@ #     }
#@ # 
#@ #     create_clock [find port $port_name] -name $clock_name -period $period -waveform $waveform
#@ #     set clock [find clock $clock_name]
#@ #     set_clock_uncertainty -setup $setup_uncertainty $clock
#@ #     set_clock_uncertainty -hold  $hold_uncertainty $clock
#@ #     set_clock_transition $clock_transition $clock
#@ #     set_drive 0 [find port $port_name]
#@ #     
#@ #     if {! $running_primetime} {
#@ #         suppressed SEL-005 {
#@ #             set_ideal_net [get_net [all_connected [get_port $port_name]]]
#@ #         }
#@ #     }
#@ #     
#@ #     # allow -ve flops
#@ #     set_dont_touch_network $clock
#@ #     # set_dont_touch_network [find port $port_name]
#@ # }
#@ # 
#@ # proc create_clock_from_port { port_name period {waveform {}} } {
#@ #     create_named_clock_from_port $port_name $port_name $period $waveform
#@ # }
#@ # 
#@ 
#@ proc all_all_connected {col} {
#@     set result {}
#@     foreach_in_collection ele $col {
#@         set result [add_to_collection $result [all_connected $ele]]
#@     }
#@     return $result
#@ }
#@ 
#@ proc bye {} {
#@     puts ""
#@     puts "Thank you..."
#@     exit
#@ }
#@ 
#@ proc num_cpus {} {
#@     if {[exec uname -i] == {x86_64}} {
#@         set num_cpus 2
#@     } else {
#@         set num_cpus 1
#@     }
#@     return $num_cpus
#@ }
#@ 
#@ proc is_a_collection { c } {
#@     set c_len [suppressed SEL-001 {sizeof_collection $c}]
#@     return [expr { [string length $c_len] != 0 }]
#@ }
#@ 
#@ proc exists_and_true { var_name } {
#@     upvar $var_name var 
#@     if { [info exists var] } {
#@         return [expr {$var == "true"} || {$var == 1}]
#@     } else {
#@         return 0
#@     }   
#@     return 
#@ }
#@ 
#@ proc exists_and_false { var_name } {
#@     upvar $var_name var 
#@     if { [info exists var] } {
#@         return [expr ! ( {$var == "true"} || {$var == 1} )]
#@     } else {
#@         return 0
#@     }   
#@     return 
#@ }
#@ 
#@ proc reverse_collection { c } {
#@     set d {}
#@     for {set x [expr [sizeof_collection $c] - 1]} {$x >= 0} {incr x -1} {
#@         set d [add_to_collection $d [index_collection $c $x]]
#@     }
#@     return $d
#@ }
#@ 
#@ proc cappend {args} {
#@     upvar [lindex $args 0] col
#@ 
#@     if {! [info exists col]} {
#@         set col {}
#@     }
#@ 
#@     foreach arg [lrange $args 1 end] {
#@         set col [add_to_collection $col $arg]
#@     }
#@ }
#@ 
#@ proc crange {col first last} {
#@     if {$first == {end}} {
#@         set first [expr [sizeof_collection $col]-1]
#@     }
#@     if {$last == {end}} {
#@         set last [expr [sizeof_collection $col]-1]
#@     }
#@     if {[string match end-* $first]} {
#@         set first [expr [sizeof_collection $col]-1 - [string range $first 4 end]]
#@     }
#@     if {[string match end-* $last]} {
#@         set last [expr [sizeof_collection $col]-1 - [string range $last 4 end]]
#@     }
#@     if {$first == {mid}} {
#@         set first [expr ([sizeof_collection $col]+1)/2]
#@     }
#@     if {$last == {mid}} {
#@         set last [expr ([sizeof_collection $col]+1)/2]
#@     }
#@     if {[string match mid-* $first]} {
#@         set first [expr ([sizeof_collection $col]+1)/2 - [string range $first 4 end]]
#@     }
#@     if {[string match mid-* $last]} {
#@         set last [expr ([sizeof_collection $col]+1)/2 - [string range $last 4 end]]
#@     }
#@     if {[string match mid+* $first]} {
#@         set first [expr ([sizeof_collection $col]+1)/2 + [string range $first 4 end]]
#@     }
#@     if {[string match mid+* $last]} {
#@         set last [expr ([sizeof_collection $col]+1)/2 + [string range $last 4 end]]
#@     }
#@ 
#@     set result {}
#@     for {set i $first} {$i <= $last} {incr i} {
#@         append_to_collection result [index_collection $col $i]
#@     }
#@     return $result
#@ }
#@ 
#@ proc interleave_lists { args } {
#@     set largest 0
#@     for {set arg 0} {$arg < [llength $args]} {incr arg} {
#@         if {[llength [lindex $args $arg]] != [llength [lindex $args 0]]} {
#@             echo Warn\ing: Size of lists mismatch [llength [lindex $args $arg]] vs [llength [lindex $args 0]]
#@         }
#@         if {[llength [lindex $args $arg]] > [llength [lindex $args $largest]]} {
#@             set largest $arg
#@         }
#@     }
#@     set d {}
#@     for {set i 0} {$i < [llength [lindex $args $largest]]} {incr i} {
#@         foreach arg $args {
#@             if {$i < [llength $arg]} {
#@                 lappend d [lindex $arg $i]
#@             }
#@         }
#@     }
#@     return $d
#@ }
#@ 
#@ proc interleave_collections { args } {
#@     # flatten any argument that is a list into the list of arguments
#@     set args [eval concat $args]
#@     
#@     set largest 0
#@     for {set arg 0} {$arg < [llength $args]} {incr arg} {
#@         if {[sizeof_collection [lindex $args $arg]] != [sizeof_collection [lindex $args 0]]} {
#@             echo Warn\ing: Size of collections mismatch [sizeof_collection [lindex $args $arg]] vs [sizeof_collection [lindex $args 0]]
#@         }
#@         if {[sizeof_collection [lindex $args $arg]] > [sizeof_collection [lindex $args $largest]]} {
#@             set largest $arg
#@         }
#@     }
#@     set d {}
#@     for {set i 0} {$i < [sizeof_collection [lindex $args $largest]]} {incr i} {
#@         foreach arg $args {
#@             if {$i < [sizeof_collection $arg]} {
#@                 set d [add_to_collection $d [index_collection $arg $i]]
#@             }
#@         }
#@     }
#@     return $d
#@ }
#@ 
#@ proc interleave_ios {col} {
#@     set ins  [filter_collection $col port_direction==in]
#@     set outs [filter_collection $col port_direction==out]
#@ 
#@     if {[sizeof_collection $ins] == [sizeof_collection $outs]} {
#@         return [interleave_collections $ins $outs]
#@     } elseif {[sizeof_collection $ins] > [sizeof_collection $outs]} {
#@         return [add_to_collection [interleave_collections [crange $ins 0 [expr [sizeof_collection $outs] - 1]] $outs] [crange $ins [sizeof_collection $outs] end]]
#@     } else {
#@         return [add_to_collection [interleave_collections $ins [crange $outs 0 [expr [sizeof_collection $ins] - 1]]] [crange $outs [sizeof_collection $ins] end]]
#@     }
#@ }
#@ 
#@ ####
#@ 
#@ # refp   are 'reference' pins/ports
#@ # datap  are constrained pins/ports
#@ 
#@ # Clock/data wildcard/list arguments are expanded with getports
#@ # Alternatively you can pass in a collection of ports or pins
#@ 
#@ # arg skew can be {skew} or {skew_early skew_late}
#@ 
#@ proc constrain_output_skew { args } {
#@ 
#@     global running_primetime
#@ 
#@     if { ! $running_primetime } {
#@         puts "Did not run proc constrain_output_skew (PT only)"
#@         return 0
#@     }
#@ 
#@     array set args2 { -ref_edge {both} -data_edge {both} -fudge 0.0 -verbose 0}
#@ 
#@     parse_proc_arguments -args $args args2    
#@     array unset args
#@    
#@     if { $args2(-verbose) } {
#@         foreach argname [array names args2] {
#@            echo "  $argname = $args2($argname)"
#@         }
#@     }
#@ 
#@     puts "constrain_output_skew, skew $args2(skew), ref $args2(-ref_edge) edge, data $args2(-data_edge) edge"
#@ 
#@     # Yes, 'setups' we pass to set_data_check must be -ve for data to arrive AFTER reference
#@     set skewvals(early) [expr 0.0 - [lfirst $args2(skew)] - $args2(-fudge)]
#@     set skewvals(late)  [expr 0.0 - [llast  $args2(skew)] - $args2(-fudge)]
#@ 
#@     array set edgemap { rise {rise_} fall {fall_} both {} } 
#@     set edges(ref)  $edgemap($args2(-ref_edge))
#@     set edges(data) $edgemap($args2(-data_edge))
#@ 
#@     set refp $args2(refp)    
#@     if { ! [is_a_collection $refp] } {
#@         set refp [get_ports $refp] 
#@     }
#@     puts "  [sizeof_collection $refp]  ref pins"
#@     
#@     set datap $args2(datap)
#@     if { ! [is_a_collection $datap] } {
#@         set datap [get_ports $datap]
#@     }
#@     puts "  [sizeof_collection $datap] data pins"
#@ 
#@     foreach_in_collection ref $refp {
#@ 
#@         set ref_name [get_object_name $ref]
#@         puts "Using ref pin  $ref_name"
#@ 
#@         if {  [get_attribute $ref object_class] == "port" } {
#@             remove_output_delay $ref
#@         }
#@ 
#@         foreach_in_collection data $datap {
#@ 
#@             set data_name [get_object_name $data]
#@             if { $data_name == $ref_name  } {
#@                 # puts "Note: ref and data ($data_name) are the same - no constraint set"
#@                 continue
#@             }
#@             # puts "Constraining data pin $data_name"
#@             # Can we check and warn if output delay has been set and must be removed?
#@             # Only do this if it is a port!
#@             
#@             if {  [get_attribute $data object_class] == "port" } {
#@                 remove_output_delay $data
#@             }
#@             remove_data_check -from $ref -to   $data
#@             remove_data_check -to   $ref -from $data
#@ 
#@             set cmd1 "set_data_check -${edges(ref)}from $ref -${edges(data)}to   $data -setup  $skewvals(late)"
#@             set cmd2 "set_data_check -${edges(ref)}to   $ref -${edges(data)}from $data -setup  $skewvals(early)"
#@ 
#@             if { $args2(-verbose) } {
#@                 echoed $cmd1
#@                 echoed $cmd2
#@             } else {
#@                 eval $cmd1
#@                 eval $cmd2
#@             }       
#@         }
#@ 
#@     }
#@     # Flag for success?
#@     return 1
#@ }
#@ 
#@ define_proc_attributes constrain_output_skew                             \
#@     -info {Uses set_data_check to constrain skew between data pins/ports} \
#@     -define_args {
#@         { refp          {reference ports/pins}                    {"object_list"} list required }
#@         { datap         {data ports/pins}                         {"object_list"} list required }
#@         { skew          {early,late skew of data wrt reference}   {{0.12 0.11}}   list required } 
#@         
#@         {-ref_edge      {reference edge(s)}                    {both} one_of_string {optional value_help {values {rise fall both}}}}
#@         {-data_edge     {data edge(s)}                         {both} one_of_string {optional value_help {values {rise fall both}}}}
#@         {-fudge         {relaxes constraints by this much}     {0.440} list optional }
#@         
#@         { -verbose      {show what is going on}                {}      boolean optional }                
#@     }
#@ 
#@ 
#@ # few useful procs for interractive debugging
#@ proc lrefcell { refname } {
#@     # list cells with matching refname (show hierarchical cell name and reference)
#@     set refcells [get_cells  * -hier -filter "@ref_name=~${refname}"]
#@     foreach_in_collection cell $refcells {
#@         echo [get_object_name $cell] "    " [get_attribute $cell ref_name]
#@     }
#@ }
#@ proc lhiercell { hiername } {
#@     # list cells with matching hierarchical name (show hierarchical cell name and reference)
#@     set refcells [get_cells  * -hier -filter "@full_name=~${hiername}"]
#@     foreach_in_collection cell $refcells {
#@         echo [get_object_name $cell] "    " [get_attribute $cell ref_name]
#@     }
#@ }
#@ 
#@ proc get_object_names {objects} {
#@     set result {}
#@     foreach_in_collection object $objects {
#@         lappend result [get_object_name $object]
#@     }
#@     return $result
#@ }
#@ 
#@ proc get_cells_of_objects_leave_nets {objects} {
#@     return [add_to_collection [filter_collection $objects object_class==net] [get_cells_of_objects [filter_collection $objects object_class!=net]]]
#@ }
#@ 
#@ proc restore_clock_gating_attributes {} {
#@     global tech_clock_gating_latch
#@     global tech_clock_gating_latch_pattern
#@     global xg_mode
#@     global running_cadence
#@ 
#@     if {$running_cadence} {
#@         return
#@     }
#@ 
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell clock_gating_logic true
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell hpower_inv_cg_cell false
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell clock_gating_integrated_cell_instance latch_posedge_precontrol
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell combinational_type_exact TSMC_CLN90G_SC9WT_SLOW_125_0P9/SGCLATNX2G1T10W
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell pwr_cg_gating_group 0
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell pwr_cg_gated_cell_name mcp_reg_PIPE_1_RD_VALID
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID cell pwr_cg_gating_sub_group 0
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID/latch cell dont_touch true
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID/latch cell clock_gating_logic true
#@     #clk_gate_mcp_reg_PIPE_1_RD_VALID/latch cell forced_size_only true
#@ 
#@     set previous_current_design [current_design]
#@ 
#@     # This variable makes sure that the design is not
#@     # linked for every instance search. This speeds up the
#@     # process of attribute addition to verilog netlist.
#@ 
#@     set auto_link_disable true; # go faster
#@ 
#@     set i 0
#@     foreach_in_collection cell [get_cells -hierarchical * -filter "(full_name=~*clk_gate*latch || full_name=~*LV_cgCellAnd*) && ref_name=~$tech_clock_gating_latch_pattern"] {
#@         set_attribute -type boolean $cell dont_touch         true
#@         set_attribute -type boolean $cell clock_gating_logic true
#@         set_attribute -type boolean $cell forced_size_only   true
#@ 
#@         set parent_cell [get_parent_cell $cell]
#@ 
#@         if {[string match SNPS_CLOCK_GATE* [get_attribute $parent_cell ref_name]]} {
#@             set_attribute -type boolean $parent_cell clock_gating_logic true
#@             set_attribute -type boolean $parent_cell hpower_inv_cg_cell false
#@             set_attribute -type string  $parent_cell clock_gating_integrated_cell_instance latch_posedge_precontrol
#@             set_attribute -type string  $parent_cell combinational_type_exact $tech_clock_gating_latch
#@             set_attribute -type integer $parent_cell pwr_cg_gating_group     $i
#@             set_attribute -type integer $parent_cell pwr_cg_gating_sub_group 0
#@         }
#@ 
#@         incr i
#@     }
#@ 
#@     if {! $xg_mode} {
#@         # Too slow in XG mode... dunno if it was necessary yet
#@         foreach_in_collection design [get_designs SNPS_CLOCK_GATE*] {
#@             current_design $design
#@             set_attribute -type boolean [get_cells latch] clock_gating_logic true
#@             set_attribute -type integer [current_design]  clock_gating_reg_size 8
#@             set_attribute -type boolean [current_design]  pwr_cg_design_is_clock_gating true
#@             set_attribute -type boolean [current_design]  pwr_cg_design_has_clock_gating true
#@             set_attribute -type boolean [get_ports EN]    clock_gate_enable_pin true
#@             set_attribute -type boolean [get_ports CLK]   clock_gate_clock_pin true
#@             set_attribute -type boolean [get_ports TE]    clock_gate_test_pin  true
#@             set_attribute -type boolean [all_outputs]     clock_gate_out_pin   true
#@             current_design $previous_current_design
#@         }
#@     }
#@     
#@     # Power Compiler needs to get the following design attributes in order
#@     # to know that the design has undergone clock gating. The following 3
#@     # attributes specify that design has undergone clock gating and also lists
#@     # the number of clock gating groups as well as non-cg Groups.
#@ 
#@     set_attribute -type boolean [current_design] pwr_cg_design_has_clock_gating true
#@     set_attribute -type integer [current_design] pwr_cg_gating_group_count      $i
#@     set_attribute -type integer [current_design] pwr_non_cg_gating_group_count  0
#@ 
#@     set auto_link_disable false; # back to normal
#@ }
#@ 
#@ proc restore_scan_attributes {} {
#@     global xg_mode
#@     global running_cadence
#@ 
#@     if {$running_cadence} {
#@         return
#@     }
#@ 
#@     set_scan_configuration -style multiplexed_flip_flop
#@     if {! $xg_mode} {
#@         set_scan_configuration -existing_scan true
#@     }
#@ 
#@     foreach_in_collection cell [get_cells -hierarchical -filter is_sequential==true&&(ref_name=~SDFF*||ref_name=~*_SDFF*)] {
#@         set_attribute -type boolean $cell scanned_by_test_compiler true
#@     }
#@     set_attribute -type boolean [current_design] insert_scan true
#@     set_attribute -type boolean [current_design] scanned_by_test_compiler true
#@ }
#@ 
#@ proc remove_unloaded_cells {celltype} {
#@ 
#@     set top [get_object_name [current_design]]
#@     set cells [get_cells -hier * -filter "ref_name==$celltype"]
#@     array unset cellnames
#@     array unset cellnames2
#@ 
#@     foreach_in_collection cell $cells {
#@         set pins [get_pins -of_object $cell -filter "pin_direction==out"]
#@         set nets [all_connected $pins]
#@         if { [sizeof_collection $nets] == 0 } {
#@             set dir [dirname [get_object_name $cell]]
#@             if { $dir == {} } {
#@                 remove_cell [filename [get_object_name $cell]]
#@             } else {
#@                 lappend cellnames($dir) [filename [get_object_name $cell]]
#@             }
#@         }
#@     }
#@ 
#@     foreach dir [array names cellnames] {
#@         set ref [get_attribute [get_cells $dir] ref_name]
#@         set cellnames2($ref) $cellnames($dir)
#@     }
#@ 
#@     foreach dir [array names cellnames2] {
#@         current_design $dir
#@         foreach cellname $cellnames2($dir) {
#@             remove_cell $cellname
#@         }
#@     }
#@     current_design $top
#@ }
#@ 
#@ proc remove_and_prevent_reelaboration {designs_to_delete} {
#@     # W.....g: Can't remove attribute '...' from object '...'. (UID-339)
#@     # W.....g: Attribute '...' does not exist on cell '...'. (UID-101)  (on remove_attribute)
#@     suppressed { UID-339 UID-101 } {
#@         set cells [get_cells -hierarchical -filter ref_name==[join [get_object_names $designs_to_delete] ||ref_name==]]
#@         foreach_in_collection cell $cells {
#@             set ref_names([get_parent_ref_name $cell]) [get_attribute $cell name]
#@         }
#@ 
#@         remove_attribute $cells hdl_library
#@         set previous_current_design [current_design]
#@         foreach ref_name [array names ref_names] {
#@             current_design $ref_name
#@             remove_attribute [get_cells $ref_names($ref_name)] hdl_library
#@         }
#@         current_design $previous_current_design
#@ 
#@         remove_attribute [get_designs [array names ref_names]] link_design_libraries
#@         remove_attribute [current_design] link_design_libraries
#@ 
#@         remove_design -hierarchy $designs_to_delete
#@     }
#@ }
#@ 
#@ proc listall { arg1 {presort {1}} {printcount {1}} } {
#@ 
#@     if { $arg1 == {?} || $arg1 == {help}} {
#@         echo "Usage: listall <collection> <presort-default=1> <printcount-default=1>"
#@     } else {
#@         set count 0
#@         if { $presort != 1 } {
#@            set collection $arg1
#@         } else {
#@            set collection [sort_collection $arg1 {full_name}]
#@         }
#@         foreach_in_collection element $collection {
#@             set count [expr $count + 1]
#@             if { $printcount != 1 } {
#@                 echo [get_object_name $element ]
#@             } else {
#@                 if       {$count < 10 } { set gap "     "
#@                 } elseif {$count < 100 } { set gap "    "
#@                 } elseif {$count < 1000 } { set gap "   "
#@                 } elseif {$count < 10000 } { set gap "  "
#@                 } elseif {$count < 100000 } { set gap " "
#@                 } else   {                     set gap ""
#@                 }
#@                 echo $count $gap [get_object_name $element ]
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc filter_regs {} {
#@     #
#@     # This routine returns a filter expression to help get_cells find registers
#@     # e.g. set regs [get_cells * -filter [filter_regs]]
#@     # (We used to rely mainly on naming e.g. *_reg*, but this breaks down when
#@     #  layout adds buffering cells named after the nearest reg.)
#@     #  
#@     global running_design_compiler
#@     global running_primetime
#@     if { $running_primetime } {
#@         return "(@is_sequential==true)"
#@     }
#@     if { $running_design_compiler } {
#@         # Unmapped logic (after elab, before compile) doesn't have the is_sequential attribute 
#@         # so it's a little more complicated ...
#@         return "(@is_sequential==true || (@is_mapped==false && @ref_name==**SEQGEN**))"
#@     }
#@     # Otherwise assume primetime mode, or add in more modes here ...
#@     return "(@is_sequential==true)"
#@ }
#@ 
#@ proc dup_collection {col num} {
#@     set f {}
#@     for {set i 0} {$i < $num} { incr i} {
#@         append_to_collection f $col
#@     }
#@     return $f
#@ }
#@ 
#@ proc split_collection { collection layer_ratio {sort_collection 0} } {
#@     set count 0
#@     set collection_a {}
#@     set collection_b {}
#@     set num [expr [sizeof_collection $collection] * $layer_ratio]
#@     if { $sort_collection } { set collection [sort_collection $collection name -dictionary] }
#@     foreach_in_collection a $collection {
#@         if { $count < $num } {
#@             append_to_collection collection_a $a
#@             incr count
#@         } else {
#@             append_to_collection collection_b $a
#@         }
#@     }
#@     if { $sort_collection } { set collection_a [sort_collection $collection_a name -dictionary] }
#@     if { $sort_collection } { set collection_b [sort_collection $collection_b name -dictionary] }
#@     return [list $collection_a $collection_b]
#@ }
#@ 
#@ proc deinterleave_collection { collection layer_ratio } {
#@     set collection_a {}
#@     set collection_b {}
#@     set balance 0.0
#@     foreach_in_collection a $collection {
#@         if { $balance >= 0.0 } {
#@             append_to_collection collection_a $a
#@             set balance [expr $balance - (1.0-$layer_ratio)]
#@         } else {
#@             append_to_collection collection_b $a
#@             set balance [expr $balance + $layer_ratio]
#@         }
#@     }
#@     return [list $collection_a $collection_b]
#@ }
#@ 
#@ proc deinterleave_collection2 { collection way ways } {
#@     set result {}
#@     for {set index 0} {$index < [sizeof_collection $collection]} {incr index $ways} {
#@         foreach w $way {
#@             if {$w == {X}} {
#@                 append_to_collection result [current_design]
#@             } elseif {$index + $w < [sizeof_collection $collection]} {
#@                 append_to_collection result [index_collection $collection [expr $index + $w]]
#@             }
#@         }
#@     }
#@     return $result
#@ }
#@ 
#@ proc interleave_collection_balanced {a b {sort_collection 0}} {
#@     set ret ""
#@ 
#@     if { $sort_collection } { set a [sort_collection $a name -dictionary] }
#@     if { $sort_collection } { set b [sort_collection $b name -dictionary] }
#@ 
#@     set a_size [sizeof_collection $a]
#@     set b_size [sizeof_collection $b]
#@ 
#@     set a_count   0
#@     set b_count   0
#@     set ret_count 0
#@ 
#@     while { $a_count < $a_size } {
#@         append_to_collection ret [index_collection $a [expr [incr a_count] - 1]]
#@         incr ret_count $b_size
#@         while { $ret_count >= $a_size } {
#@             append_to_collection ret [index_collection $b [expr [incr b_count] - 1]]
#@             incr ret_count -$a_size
#@         }
#@     }
#@ 
#@     if { ($a_count                 != $a_size                 ) ||
#@          ($b_count                 != $b_size                 ) ||
#@          ([sizeof_collection $ret] != [expr $a_size + $b_size]) } {
#@         puts "Err\or - Interleave collection failed"
#@     }
#@ 
#@     return $ret
#@ }
#@ 
#@ proc slice_collection {collection from num} {
#@     set ret ""
#@     for { set i $from } { $i < [expr $from + $num] } { incr i } {
#@         append_to_collection ret [index_collection $collection $i]
#@     }
#@     return $ret        
#@ }
#@ 
#@ proc display_collection {coll {msg "Information: Collection contains %d objects"} {min 0} {max 1000}} {
#@     if { [sizeof_collection $coll] >= $min} {
#@         if { "$msg" != {} } {
#@             puts [format $msg [sizeof_collection $coll]]
#@         }
#@         set i 0
#@         foreach_in_collection c $coll {
#@             if { $i >= $max } {
#@                 echo "  + ..."
#@                 return
#@             }
#@             puts "  + [get_attribute $c object_class]:[get_object_name $c]"
#@             incr i
#@         }
#@     }
#@ }
#@ 
#@ proc create_constraint_high {i} {
#@     global created_constraint_high
#@ 
#@     if {! [info exists created_constraint_high($i)]} {
#@         echo "
#@             entity high_$i is
#@                 port (
#@                     inp  : NATURAL range 0 to $i;
#@                     outp : out BOOLEAN
#@                 );
#@             end;
#@ 
#@             architecture rtl of high_$i is
#@             begin
#@                 outp <= inp <= $i;
#@             end;
#@         " > high_$i.vhd
#@ 
#@         read_vhdl -container high_$i high_$i.vhd
#@ 
#@         file delete high_$i.vhd
#@ 
#@         create_constraint_type high_$i high_$i:/WORK/high_$i
#@ 
#@         set created_constraint_high($i) 1
#@     }
#@ }
#@ 
#@ proc log2 {inp} {
#@     return [expr log($inp)/log(2.0)]
#@ }
#@ 
#@ proc bit_width {inp} {
#@     return [expr int(ceil([log2 $inp]))]
#@ }
#@ 
#@ proc bit_width_1 {inp} {
#@     return [expr int(floor([log2 $inp]) + 1)]
#@ }
#@ 
#@ proc set_constraint_high {i cells} {
#@     create_constraint_high $i
#@ 
#@     foreach_in_collection cell [get_cells $cells] {
#@         set base [regsub {_[0-9]+$} [get_attribute $cell full_name] {}]
#@ 
#@         set tmp1 [list]
#@         set tmp2 [list]
#@         for {set j 0} {$j < [bit_width_1 $i]} {incr j} {
#@             lappend tmp1 ${base}_$j
#@             lappend tmp2 inp_$j=\$[expr $j + 1]
#@         }
#@ 
#@         set_constraint high_$i $tmp1 -map $tmp2
#@     }
#@ }
#@ 
#@ proc getProc {procName} {
#@     set result [list proc $procName]
#@     set formals {}
#@     foreach var [info args $procName] {
#@         if {[info default $procName $var def]} {
#@             lappend formals [list $var $def]
#@         } else {
#@             # Still need the list-quoting because variable
#@             # names may properly contain spaces.
#@             lappend formals [list $var]
#@         }
#@     }
#@     lappend result $formals [info body $procName]
#@ }
#@ 
#@ # End useful.tcl
#@ # -- End source useful.tcl

#@ source2 recurse.tcl
#@ # -- Starting source recurse.tcl

#@ 
#@ proc get_attribute_pin_name {pin} {
#@     global synopsys_program_name
#@     global running_cadence
#@ 
#@     if {$running_cadence} {
#@         return [my_get_attribute $pin name]
#@     } elseif {! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}} {
#@         return [my_get_attribute $pin pin_name]
#@     } else {
#@         return [my_get_attribute $pin lib_pin_name]
#@     }
#@ }
#@ 
#@ proc get_attribute_pin_direction {port_or_pin} {
#@     global running_cadence
#@ 
#@     if {$running_cadence && [my_get_attribute $port_or_pin object_class] == {port}} {
#@         return [my_get_attribute $port_or_pin direction]
#@     } else {
#@         return [my_get_attribute $port_or_pin pin_direction]
#@     }
#@ }
#@ 
#@ proc get_cells_of_objects {pin} {
#@     global synopsys_program_name
#@     global sh_product_version
#@     global running_cadence
#@ 
#@     if { (! [info exists sh_product_version] || [string match 2002* $sh_product_version]) && \
#@          (! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}) && \
#@          ! $running_cadence } {
#@         regsub {\/[^\/]*$} [get_object_name $pin] {} cell_name
#@         return [get_cells $cell_name]
#@     } else {
#@         return [get_cells -of_objects $pin]
#@     }
#@ }
#@ 
#@ proc get_pins_of_objects {cell} {
#@     global synopsys_program_name
#@     global sh_product_version
#@     global running_cadence
#@ 
#@     if { (! [info exists sh_product_version] || [string match 2002* $sh_product_version]) && \
#@          (! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}) && \
#@          ! $running_cadence } {
#@         return [get_pins [get_object_name $cell]/*]
#@     } else {
#@         return [get_pins -of_objects $cell]
#@     }
#@ }
#@ 
#@ proc get_lower_level_net_of_hierarchical_pin {pin} {
#@     global sh_dev_null
#@     global synopsys_program_name
#@     global xg_mode
#@     global running_cadence
#@ 
#@     if {$xg_mode || $running_cadence} {
#@         return [get_nets -of_objects [get_ports [get_object_name $pin]]]
#@     } else {
#@         set cell [get_cells_of_objects $pin]
#@     
#@         set pin_name [get_attribute_pin_name $pin]
#@ 
#@         redirect $sh_dev_null {set net [get_nets [get_object_name $cell]/$pin_name]}
#@ 
#@         if {[sizeof_collection $net] == 0} {
#@             redirect $sh_dev_null {
#@                 if {[sizeof_collection [get_designs [my_get_attribute $cell ref_name]]]} {
#@                     set previous_current_design [current_design]
#@ 
#@                     current_design [my_get_attribute $cell ref_name]
#@ 
#@                     set net [all_connected [get_ports $pin_name]]
#@ 
#@                     set net_name [get_object_name $net]
#@ 
#@                     current_design $previous_current_design
#@                 } else {
#@                     set net_name {}
#@                 }
#@             }
#@ 
#@             if {$net_name != {}} {
#@                 redirect $sh_dev_null {
#@                     set net [get_nets [get_object_name $cell]/$net_name]
#@                 }
#@             } else {
#@                 set net {}
#@             }
#@         }
#@     }
#@ 
#@     return $net
#@ }
#@ 
#@ proc get_parent_cell {cells} {
#@     global sh_dev_null
#@ 
#@     if {! [string match _sel* $cells]} {
#@         set cells [get_cells $cells]
#@     }
#@ 
#@     set result {}
#@ 
#@     foreach_in_collection cell $cells {
#@         set parent_cell_name [get_object_name $cell]
#@ 
#@         while {[regsub {\/[^\/]*$} $parent_cell_name {} parent_cell_name]} {
#@             redirect $sh_dev_null {set parent_cell [get_cells $parent_cell_name]}
#@ 
#@             if {[sizeof_collection $parent_cell]} {
#@                 append_to_collection result $parent_cell
#@                 break
#@             }
#@         }
#@     }
#@ 
#@     return $result
#@ }
#@ 
#@ proc get_parent_ref_name {cell} {
#@     global sh_dev_null
#@ 
#@     if {! [string match _sel* $cell]} {
#@         set cell [get_cells $cell]
#@     }
#@ 
#@     set parent_cell [get_parent_cell $cell]
#@ 
#@     if {[sizeof_collection $parent_cell] == 0} {
#@         redirect $sh_dev_null {set result [get_object_name [current_design]]}
#@     } else {
#@         set result [my_get_attribute $parent_cell ref_name]
#@     }
#@ 
#@     return $result
#@ }
#@ 
#@ proc rebuild_collection {old_collection} {
#@     global xg_mode
#@     global needs_rebuild_collection
#@ 
#@     if {$xg_mode && $needs_rebuild_collection} {
#@         set new_collection {}
#@         foreach_in_collection object $old_collection {
#@             if {[my_get_attribute $object object_class] == {port}} {
#@                 append_to_collection new_collection [get_ports [get_object_name $object]]
#@             } elseif {[my_get_attribute $object object_class] == {net}} {
#@                 append_to_collection new_collection [get_nets [get_object_name $object]]
#@             } elseif {[my_get_attribute $object object_class] == {cell}} {
#@                 append_to_collection new_collection [get_cells [get_object_name $object]]
#@             } elseif {[my_get_attribute $object object_class] == {pin}} {
#@                 append_to_collection new_collection [get_pins [get_object_name $object]]
#@             } else {
#@                 echo Err\or: Unknown object class [my_get_attribute $object object_class] for [get_object_name $object]
#@             }
#@         }
#@         return $new_collection
#@     } else {
#@         return $old_collection
#@     }
#@ }
#@ 
#@ proc get_object_and_ref_names {objects} {
#@     global opt
#@     set result {}
#@     foreach_in_collection object $objects {
#@         if {[my_get_attribute $object object_class] == {cell}} {
#@             lappend result [get_object_name $object] ([my_get_attribute $object ref_name])
#@         } elseif {[my_get_attribute $object object_class] == {pin}} {
#@             lappend result [get_object_name $object] ([my_get_attribute $object pin_direction] [my_get_attribute [get_cells_of_objects $object] ref_name])
#@             if { $opt(-constants) } {
#@                 suppressed ATTR-3 { 
#@                     if { [set c [my_get_attribute $object constant_value]] ne {} } {
#@                         lappend result "constant=$c"
#@                     }
#@                     if { [set c [my_get_attribute $object user_case_value]] ne {} } {
#@                         lappend result "user_case=$c"
#@                     }
#@                 }
#@             }
#@         } elseif {[my_get_attribute $object object_class] == {port}} {
#@             lappend result [get_object_name $object] ([my_get_attribute $object direction] [my_get_attribute $object object_class])
#@         } else {
#@             lappend result [get_object_name $object] ([my_get_attribute $object object_class])
#@         }
#@     }
#@     return $result
#@ }
#@ 
#@ proc doverbose {{tmp {}}} {
#@     global opt
#@     if {$opt(-verbose) || $opt(-print)} {
#@         upvar result result level level
#@         if {$tmp == {}} {
#@             set tmp $result
#@         }
#@         proc tab n {
#@             format "%${n}s" ""
#@         }
#@         foreach_in_collection object $tmp {
#@             echo [tab [expr $level*4]] [get_object_and_ref_names $object]
#@         }
#@     }
#@ }
#@ 
#@ proc recurse {port_or_pin recursions depth level stage down inversions} {
#@     global opt
#@     global synopsys_program_name
#@     global xg_mode
#@     global needs_rebuild_collection
#@     global sh_dev_null
#@     global tech_clock_gating_latch_pattern
#@     global running_cadence
#@ 
#@     if {$xg_mode} {
#@         if {[my_get_attribute $port_or_pin object_class] == {port}} {
#@             set port_or_pin [get_ports [get_object_name $port_or_pin]]
#@         } else {
#@             set port_or_pin [get_pins [get_object_name $port_or_pin]]
#@         }
#@     }
#@ 
#@     if {$recursions == 1000} {
#@         echo Warning: Reached recursion limit at [get_object_name $port_or_pin]
#@         return
#@     }
#@ 
#@     if {[is_true $opt(-stop_at_filter_regexp)]} {
#@         set stop_at_filter_regexp -regexp
#@     } else {
#@         set stop_at_filter_regexp {}
#@     }
#@ 
#@     set result {}
#@ 
#@     if {[my_get_attribute $port_or_pin object_class] != {port}} {
#@         set cell [get_cells_of_objects $port_or_pin]
#@ 
#@         if {$opt(-debug2)} {
#@             echo Information: At 1 [my_get_attribute $port_or_pin pin_direction] [my_get_attribute $port_or_pin object_class] [get_object_name $port_or_pin] [my_get_attribute $cell object_class] [get_object_name $cell] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@         }
#@ 
#@         if { $recursions != 0 && \
#@              ( ( [sizeof_collection $opt(-stop_at)] != 0 && \
#@                  ( [sizeof_collection [remove_from_collection $cell $opt(-stop_at)]] == 0 || \
#@                    [sizeof_collection [remove_from_collection $port_or_pin $opt(-stop_at)]] == 0 ) ) || \
#@                ( $opt(-stop_at_filter_cell) != {} && [sizeof_collection [filter_collection $cell $opt(-stop_at_filter_cell) {*}$stop_at_filter_regexp]] != 0 ) || \
#@                ( $opt(-stop_at_filter_port_or_pin) != {} && [sizeof_collection [filter_collection $port_or_pin $opt(-stop_at_filter_port_or_pin) {*}$stop_at_filter_regexp]] != 0 ) ) } {
#@             if {$opt(-debug)} {
#@                 echo Information: Reached stop point [get_object_name $cell] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@             }
#@             if {$opt(-cells) && ! $opt(-no_endpoints) && ! $opt(-no_stop_at_endpoints)} {
#@                 doverbose $cell
#@                 append_to_collection result $cell
#@             }
#@             if {$opt(-pins) && ! $opt(-no_endpoints) && ! $opt(-no_stop_at_endpoints)} {
#@                 if { ([my_get_attribute $port_or_pin pin_direction] == {in}  && ! $opt(-output_pins_only)) || \
#@                      ([my_get_attribute $port_or_pin pin_direction] == {out} && ! $opt(-input_pins_only) ) || \
#@                      ([my_get_attribute $port_or_pin pin_direction] == {inout} && ! $opt(-input_pins_only) && ! $opt(-output_pins_only)) } {
#@                     doverbose $port_or_pin
#@                     append_to_collection result $port_or_pin
#@                 }
#@             }
#@             return $result
#@         }
#@ 
#@         if {[is_false [my_get_attribute $cell is_hierarchical]]} {
#@             if { (! $opt(-fanin) && [my_get_attribute $port_or_pin pin_direction] == {in} ) || \
#@                  (  $opt(-fanin) && [my_get_attribute $port_or_pin pin_direction] == {out}) || \
#@                  [my_get_attribute $port_or_pin pin_direction] == {inout} } {
#@                 set flag 0
#@                 if {$opt(-cells)} {
#@                     append_to_collection result $cell
#@                 }
#@                 if {$opt(-pins)} {
#@                     if { ([my_get_attribute $port_or_pin pin_direction] == {in}  && ! $opt(-output_pins_only)) || \
#@                          ([my_get_attribute $port_or_pin pin_direction] == {out} && ! $opt(-input_pins_only) ) || \
#@                          ([my_get_attribute $port_or_pin pin_direction] == {inout} && ! $opt(-input_pins_only) && ! $opt(-output_pins_only)) } {
#@                         append_to_collection result $port_or_pin
#@                     }
#@                 }
#@                 if {$opt(-nets) && $opt(-endpoints_only)} {
#@                     append_to_collection result [all_connected $port_or_pin]
#@                 }
#@                 set include_next_pins 1
#@                 if {$opt(-dont_count_buffers) && [sizeof_collection [get_pins_of_objects $cell]] == 2} {
#@                     if {! $opt(-include_uncounted_buffers)} {
#@                         set result {}
#@                         set include_next_pins 0
#@                     }
#@                 } elseif {$opt(-dont_count_noninverting_buffers) && [sizeof_collection [get_pins_of_objects $cell]] == 2 && ([string match -nocase *BUF* [my_get_attribute $cell ref_name]] || [string match -nocase *DLY* [my_get_attribute $cell ref_name]])} {
#@                     if {! $opt(-include_uncounted_buffers)} {
#@                         set result {}
#@                         set include_next_pins 0
#@                     }
#@                 } elseif {$opt(-dont_count_noninverting_trees) && [sizeof_collection [get_pins_of_objects $cell]] == 2} {
#@                     set next_pin [remove_from_collection [get_pins_of_objects $cell] $port_or_pin]
#@                     set next_net [all_connected $next_pin]
#@                     if {! $running_cadence || ! [string match logic_?_1_net [get_object_name $next_net]]} {
#@                         set next_pins [all_connected -leaf $next_net]
#@                     } else {
#@                         set next_pins [all_connected $next_net]
#@                     }
#@                     set next_pin [remove_from_collection $next_pins $next_pin]
#@                     if {! $down} {
#@                         set next_pin [filter_collection $next_pin (object_class!=port&&pin_direction==out)||(object_class==port&&direction==in)]
#@                     }
#@                     if {([string match -nocase *BUF* [my_get_attribute $cell ref_name]] || [string match -nocase *DLY* [my_get_attribute $cell ref_name]]) || ($inversions == 1) || ($inversions == 0 && [sizeof_collection $next_pin] == 1 && [string match -nocase *INV* [my_get_attribute [get_cells_of_objects $next_pin] ref_name]])} {
#@                         if {! $opt(-include_uncounted_buffers)} {
#@                             set result {}
#@                             set include_next_pins 0
#@                         }
#@                     } else {
#@                         incr level
#@                     }
#@                 } elseif {$opt(-dont_count_latches) && ([string match $tech_clock_gating_latch_pattern [my_get_attribute $cell ref_name]] || [my_get_attribute $cell full_name] == {latch} || [string match */latch [my_get_attribute $cell full_name]])} {
#@                     if {! $opt(-include_uncounted_buffers)} {
#@                         set result {}
#@                         set include_next_pins 0
#@                     }
#@                 } elseif {$opt(-dont_count_filter_cell) != {} && [sizeof_collection [filter_collection $cell $opt(-dont_count_filter_cell) {*}$stop_at_filter_regexp]] != 0} {
#@                     if {! $opt(-include_uncounted_buffers)} {
#@                         set result {}
#@                         set include_next_pins 0
#@                     }
#@                 } else {
#@                     incr level
#@                 }
#@                 set stage_endpoint 0
#@                 if { ([is_true [my_get_attribute $cell is_sequential]] && ($opt(-stop_at_latches) || (! [string match $tech_clock_gating_latch_pattern [my_get_attribute $cell ref_name]] && [my_get_attribute $cell full_name] != {latch} && ! [string match */latch [my_get_attribute $cell full_name]]))) || \
#@                      [my_get_attribute $cell ref_name] == {**SEQGEN**} || \
#@                      ([is_true [my_get_attribute $cell is_black_box]] && [sizeof_collection [get_pins -of_objects $cell -filter pin_direction==out]] >= 4 && [my_get_attribute $cell full_name] != {SDL} && ! [string match */SDL [my_get_attribute $cell full_name]] && [my_get_attribute $cell full_name] != {MINDL} && ! [string match */MINDL [my_get_attribute $cell full_name]] && ! [string match BCM40GFD?_PMX_S* [my_get_attribute $cell ref_name]]) } {
#@                     if {$opt(-stages) < 0 || $stage >= $opt(-stages)} {
#@                         if {$opt(-debug)} {
#@                             echo Information: Reached endpoint cell [get_object_name $cell] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@                         }
#@                         if {$opt(-no_endpoints) || $opt(-stop_at_endpoints_only)} {
#@                             set result {}
#@                         }
#@                         doverbose
#@                         return $result
#@                     } else {
#@                         set stage_endpoint 1
#@                         incr stage
#@                     }
#@                 }
#@                 if {$opt(-levels) >= 0 && $level >= $opt(-levels)} {
#@                     if {$opt(-debug)} {
#@                         echo Information: Cell level limit reached at [get_object_name $port_or_pin]
#@                     }
#@                     if {($opt(-endpoints_only) && ! $opt(-include_levels_endpoints)) || ($opt(-no_endpoints) && ! $opt(-include_levels_endpoints)) || $opt(-stop_at_endpoints_only)} {
#@                         set result {}
#@                     }
#@                     doverbose
#@                     if {! $opt(-output_pins_only)} {
#@                         return $result
#@                     }
#@                     set flag 1
#@                 } elseif {($opt(-endpoints_only) || $opt(-stop_at_endpoints_only)) && (! $opt(-stage_endpoints_only) || ! $stage_endpoint)} {
#@                     set result {}
#@                 }
#@ 
#@                 doverbose
#@ 
#@                 if {! $opt(-fanin)} {
#@                     set next_pins [filter_collection [get_pins_of_objects $cell] {pin_direction==out}]
#@                 } else {
#@                     set next_pins [filter_collection [get_pins_of_objects $cell] {pin_direction==in}]
#@                 }
#@                 if {[sizeof_collection [get_pins_of_objects $cell]] == 2} {
#@                     set inversions [expr $inversions ^ [string match -nocase *INV* [my_get_attribute $cell ref_name]]]
#@                 }
#@ 
#@                 foreach_in_collection next_pin $next_pins {
#@                     set pin_name [get_attribute_pin_name $next_pin]
#@                     if { (! $opt(-fanin) && ([sizeof_collection $next_pins] == 1 || [string match Z* $pin_name] || $pin_name == {OUT} || $pin_name == {OUTP} || $pin_name == {DOUT} || $pin_name == {OUT8X} || [string match din* $pin_name] || $pin_name == {o} || $pin_name == {dly_clk} || $pin_name == {CCLKO} || $pin_name == {clkout})) || \
#@                          (  $opt(-fanin) && ([sizeof_collection $next_pins] == 1 || ! ([string match CK $pin_name] || [string match phi* $pin_name]))) } {
#@                         if {$opt(-pins) && ! $opt(-endpoints_only) && ! $opt(-stop_at_endpoints_only)} {
#@                             if {$include_next_pins} {
#@                                 if { ! $opt(-no_stop_at_endpoints) || \
#@                                      ( ( [sizeof_collection $opt(-stop_at)] == 0 || \
#@                                          [sizeof_collection [remove_from_collection $next_pin $opt(-stop_at)]] != 0 ) || \
#@                                        ( $opt(-stop_at_filter_port_or_pin) != {} && [sizeof_collection [filter_collection $next_pin $opt(-stop_at_filter_port_or_pin) {*}$stop_at_filter_regexp]] != 0 ) ) } {
#@                                     if { ([my_get_attribute $next_pin pin_direction] == {in}  && ! $opt(-output_pins_only)) || \
#@                                          ([my_get_attribute $next_pin pin_direction] == {out} && ! $opt(-input_pins_only) ) || \
#@                                          ([my_get_attribute $next_pin pin_direction] == {inout} && ! $opt(-input_pins_only) && ! $opt(-output_pins_only)) } {
#@                                         doverbose $next_pin
#@                                         append_to_collection result $next_pin
#@                                     }
#@                                 }
#@                             }
#@                         }
#@                         if {! $flag} {
#@                             append_to_collection -unique result [rebuild_collection [recurse $next_pin [expr $recursions+1] $depth $level $stage 0 $inversions]]
#@                         }
#@                     }
#@                     if {$opt(-first_path_only)} {
#@                         break
#@                     }
#@                 }
#@ 
#@                 return $result
#@             }
#@             set parent_cell [get_parent_cell $cell]
#@         } else {
#@             if {$down} {
#@                 set parent_cell $cell
#@             } else {
#@                 set parent_cell [get_parent_cell $cell]
#@             }
#@         }
#@     } else {
#@         set parent_cell {}
#@     }
#@     if { [my_get_attribute $port_or_pin object_class] == {port} || \
#@          [is_true [my_get_attribute $cell is_hierarchical]] || \
#@          (! $opt(-fanin) && [my_get_attribute $port_or_pin pin_direction] == {out}) || \
#@          (  $opt(-fanin) && [my_get_attribute $port_or_pin pin_direction] == {in} ) || \
#@          [my_get_attribute $port_or_pin pin_direction] == {inout} } {
#@         if {([my_get_attribute $port_or_pin object_class] != {port} && $opt(-include_hierarchy)) || ($recursions == 0 && $opt(-include_startpoints))} {
#@             if {$opt(-cells)} {
#@                 doverbose $cell
#@                 append_to_collection result $cell
#@             }
#@             if {$opt(-pins)} {
#@                 if { ([get_attribute_pin_direction $port_or_pin] == {in}  && ! $opt(-output_pins_only)) || \
#@                      ([get_attribute_pin_direction $port_or_pin] == {out} && ! $opt(-input_pins_only) ) || \
#@                      ([get_attribute_pin_direction $port_or_pin] == {inout} && ! $opt(-input_pins_only) && ! $opt(-output_pins_only)) } {
#@                     doverbose $port_or_pin
#@                     append_to_collection result $port_or_pin
#@                 }
#@             }
#@         }
#@         if {$down} {
#@             if {$opt(-stop_at_nonregular_nets)} {
#@                 set tmp_cell [get_cells_of_objects $port_or_pin]
#@                 set tmp_pin_name [get_attribute_pin_name $port_or_pin]
#@                 redirect $sh_dev_null {set tmp_net [get_nets [get_object_name $tmp_cell]/$tmp_pin_name]}
#@                 if {[sizeof_collection $tmp_net] == 0} {
#@                     if {$opt(-debug)} {
#@                         echo Information: Reached stop point non-regular net [get_object_name $tmp_cell]/$tmp_pin_name (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@                     }
#@                     return $result
#@                 }
#@             }
#@             set net [get_lower_level_net_of_hierarchical_pin $port_or_pin]
#@             if {$xg_mode} {
#@                 set port_or_pin [get_ports [get_object_name $port_or_pin]]
#@             }
#@         } else {
#@             # SPONG, this may take us up the hierarchy but we dont fiddle with depth. I can't remember why
#@             set net [all_connected $port_or_pin]
#@         }
#@ 
#@         if {$opt(-debug2)} {
#@             if {[sizeof_collection $net]} {
#@                 echo Information: At 2 [get_attribute_pin_direction $port_or_pin] [my_get_attribute $port_or_pin object_class] [get_object_name $port_or_pin] [my_get_attribute $net object_class] [get_object_name $net] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@             } else {
#@                 echo Information: At 2 [get_attribute_pin_direction $port_or_pin] [my_get_attribute $port_or_pin object_class] [get_object_name $port_or_pin] unconnected (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@             }
#@         }
#@ 
#@         if { ( [sizeof_collection $opt(-stop_at)] != 0 && \
#@                [sizeof_collection [remove_from_collection $net $opt(-stop_at)]] == 0 ) || \
#@              ( $opt(-stop_at_filter_net) != {} && [sizeof_collection [filter_collection $net $opt(-stop_at_filter_net) {*}$stop_at_filter_regexp]] != 0 ) } {
#@             if {$opt(-debug)} {
#@                 echo Information: Reached stop point [get_object_name $net] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@             }
#@             if {$opt(-nets) && ! $opt(-no_stop_at_endpoints)} {
#@                 doverbose $net
#@                 append_to_collection result $net
#@             }
#@             return $result
#@         }
#@ 
#@         if {[sizeof_collection $net]} {
#@             if {$opt(-nets)} {
#@                 doverbose $net
#@             }
#@ 
#@             set is_top_net [expr ! $down]
#@             set is_endpoint 0
#@             suppressed {SEL-004 SEL-005 UID-95} {
#@                 set next_port_or_pins [remove_from_collection [all_connected $net] [add_to_collection $port_or_pin [get_pins -quiet [get_object_name $port_or_pin]]]]
#@             }
#@             if {($opt(-stop_at_high_fanout_nets) && [sizeof_collection $next_port_or_pins] > 32) || ($opt(-stop_at_fanout_gt) && [sizeof_collection $next_port_or_pins] > $opt(-stop_at_fanout_gt))} {
#@                 if {$opt(-debug)} {
#@                     echo Information: Reached stop point high fanout net [get_object_name $net] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@                 }
#@             } else {
#@                 set results_stash {}
#@                 foreach_in_collection next_port_or_pin $next_port_or_pins {
#@                     if {[my_get_attribute $next_port_or_pin object_class] == {port}} {
#@                         suppressed {SEL-004 SEL-005 UID-95} {
#@                             if {[sizeof_collection [get_pins -quiet [get_object_name $next_port_or_pin]]]} {
#@                                 set next_port_or_pin [get_pins [get_object_name $next_port_or_pin]]
#@                             }
#@                         }
#@                     }
#@                     if {[my_get_attribute $next_port_or_pin object_class] != {port}} {
#@                         set next_cell [get_cells_of_objects $next_port_or_pin]
#@ 
#@                         if {$opt(-debug2)} {
#@                             echo Information: At 3 [get_attribute_pin_direction $port_or_pin] [my_get_attribute $port_or_pin object_class] [get_object_name $port_or_pin] [my_get_attribute $next_port_or_pin object_class] [get_object_name $next_port_or_pin] [my_get_attribute $next_cell object_class] [get_object_name $next_cell] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@                         }
#@ 
#@                         set next_down 0
#@                         set next_depth $depth
#@                         if { [is_true [my_get_attribute $next_cell is_hierarchical]] && \
#@                              ( ($parent_cell == {} && [my_get_attribute $port_or_pin object_class] == {port}) || \
#@                                [compare_collections $next_cell $parent_cell] != 0 ) } {
#@                             set next_down 1
#@                             set next_depth [expr $depth+1]
#@                             if {$opt(-cells) && $opt(-include_hierarchy)} {
#@                                 doverbose $next_cell
#@                                 append_to_collection result $next_cell
#@                             }
#@                             if {$opt(-depth) >= 0 && $next_depth >= $opt(-depth)} {
#@                                 if {$opt(-debug)} {
#@                                     echo Information: Hierarchical depth limit reached at [get_object_name $port_or_pin]
#@                                 }
#@                                 if {$opt(-cells) && ! $opt(-include_hierarchy) && $opt(-include_levels_endpoints)} {
#@                                     doverbose $next_cell
#@                                     append_to_collection result $next_cell
#@                                 }
#@                                 if {$opt(-pins) && $opt(-include_levels_endpoints)} {
#@                                     doverbose $next_port_or_pin
#@                                     append_to_collection result $next_port_or_pin
#@                                 }
#@                                 set is_endpoint $opt(-include_levels_endpoints)
#@                                 continue
#@                             }
#@                         }
#@ 
#@                         if { [my_get_attribute $port_or_pin object_class] != {port} && \
#@                              [is_true [my_get_attribute $next_cell is_hierarchical]] && \
#@                              [compare_collections $next_cell $parent_cell] == 0 } {
#@                             if { ! $opt(-no_stop_at_endpoints) && \
#@                                  ( ( [sizeof_collection $opt(-stop_at)] != 0 && \
#@                                      ( [sizeof_collection [remove_from_collection $cell $opt(-stop_at)]] == 0 || \
#@                                        [sizeof_collection [remove_from_collection $port_or_pin $opt(-stop_at)]] == 0 ) ) || \
#@                                    ( $opt(-stop_at_filter_cell) != {} && [sizeof_collection [filter_collection $cell $opt(-stop_at_filter_cell) {*}$stop_at_filter_regexp]] != 0 ) || \
#@                                    ( $opt(-stop_at_filter_port_or_pin) != {} && [sizeof_collection [filter_collection $port_or_pin $opt(-stop_at_filter_port_or_pin) {*}$stop_at_filter_regexp]] != 0 ) ) } {
#@                                 set is_endpoint 1
#@                             } else {
#@                                 set is_top_net 0
#@                             }
#@                         }
#@ 
#@                         if { [is_true [my_get_attribute $next_cell is_hierarchical]] || \
#@                              (! $opt(-fanin) && [my_get_attribute $next_port_or_pin pin_direction] == {in} ) || \
#@                              (  $opt(-fanin) && [my_get_attribute $next_port_or_pin pin_direction] == {out}) || \
#@                              [my_get_attribute $next_port_or_pin pin_direction] == {inout} } {
#@                             append_to_collection -unique result [rebuild_collection [recurse $next_port_or_pin [expr $recursions+1] $next_depth $level $stage $next_down $inversions]]
#@                         }
#@                     } else {
#@                         if {$opt(-debug)} {
#@                             echo Information: Reached port at [get_object_name $next_port_or_pin]
#@                         }
#@                         if {$opt(-ports)} {
#@                             if { (! $opt(-fanin) && [get_attribute_pin_direction $next_port_or_pin] == {out}) || \
#@                                  (  $opt(-fanin) && [get_attribute_pin_direction $next_port_or_pin] == {in} ) || \
#@                                  [get_attribute_pin_direction $next_port_or_pin] == {inout} } {
#@                                 doverbose $next_port_or_pin
#@                                 append_to_collection result $next_port_or_pin
#@                                 set needs_rebuild_collection 1
#@                             }
#@                         }
#@                         set is_endpoint 1
#@                     }
#@                     if {$opt(-first_path_only)} {
#@                         break
#@                     }
#@                     if { ([incr count] > 100) && ([sizeof_collection $result]>5000) } {
#@                         lappend results_stash $result
#@                         # echo "Information: Stashing result collection - $level / [llength $results_stash]"
#@                         set result {}
#@                         set count 0
#@                     }
#@                 }
#@                 if { [llength $results_stash] } {
#@                     # echo "Information: Merging stashes $level ...."
#@                     append_to_collection result -unique $results_stash
#@                     # echo "Information: "... done"
#@                 }
#@             }
#@             if {$opt(-nets) && ($opt(-include_hierarchy) || $is_top_net) && (! $opt(-endpoints_only) || $is_endpoint) && ! $opt(-stop_at_endpoints_only)} {
#@                 if {(! $opt(-include_only_noninverted_nets) || $inversions == 0) && (! $opt(-include_only_inverted_nets) || $inversions == 1)} {
#@                     append_to_collection result $net
#@                 }
#@             }
#@             return $result
#@         }
#@     }
#@     if {$opt(-debug)} {
#@         echo Information: No connectivity past [get_object_name $port_or_pin] (recursions $recursions, hierarchy depth $depth, cell levels $level, going down $down)
#@     }
#@     return $result
#@ }
#@ 
#@ proc my_link { {link_cmd link} } {
#@     global synopsys_program_name
#@     global running_cadence
#@ 
#@     if {$running_cadence} {
#@         return
#@     }
#@ 
#@     suppressed {UID-101 ATTR-1} {
#@         if {! [info exists synopsys_program_name] || $synopsys_program_name != {pt_shell}} {
#@             global linked_$link_cmd
#@             if {! [info exists linked_$link_cmd]} {
#@                 $link_cmd
#@                 set linked_$link_cmd true
#@             }
#@         } else {
#@             if {[my_get_attribute [current_design] linked] != {true}} {
#@                 $link_cmd
#@                 if {[my_get_attribute [current_design] linked] != {true}} {
#@                     define_user_attribute -type boolean -classes design linked
#@                     set_user_attribute [current_design] linked true
#@                 }
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc fast_all_fanin_or_fanout {} {
#@     global sh_dev_null
#@     global opt
#@     global clock_port_pin_names
#@     global needs_rebuild_collection
#@ 
#@     if {[info exists opt(-from)] || [info exists opt(-to)]} {
#@         set opt(-stop_at_latches) 1
#@     }
#@     if {[info exists opt(-startpoints_only)]} {
#@         set opt(-endpoints_only) 1
#@     }
#@     if {[info exists opt(-only_cells)]} {
#@         set opt(-cells) 1
#@     }
#@     if {! $opt(-cells) && ! $opt(-pins) && ! $opt(-nets) && ! $opt(-ports)} {
#@         set opt(-pins) 1
#@         set opt(-ports) 1
#@     }
#@     if {$opt(-debug2)} {
#@         set opt(-debug) 1
#@     }
#@ 
#@     if {$opt(-input_pins_only) && ! $opt(-pins)} {
#@         echo Err\or: Can't specify -input_pins_only without -pins
#@         array unset opt
#@         return
#@     }
#@     if {$opt(-output_pins_only) && ! $opt(-pins)} {
#@         echo Err\or: Can't specify -output_pins_only without -pins
#@         array unset opt
#@         return
#@     }
#@ 
#@     my_link
#@ 
#@     interp recursionlimit {} 10000
#@ 
#@     suppressed {UID-341} {
#@         if {$opt(-clock_tree)} {
#@             set opt(ports_or_pins) {}
#@             foreach clock_name [array names clock_port_pin_names] {
#@                 append_to_collection opt(ports_or_pins) $clock_port_pin_names($clock_name)
#@             }
#@         } else {
#@             redirect $sh_dev_null {set tmp [sizeof_collection $opt(ports_or_pins)]}
#@             if {$tmp == {} || $tmp == 0} {
#@                 if {[string match */* $opt(ports_or_pins)]} {
#@                     redirect $sh_dev_null {set tmp [sizeof_collection [get_pins $opt(ports_or_pins)]]}
#@                 } else {
#@                     redirect $sh_dev_null {set tmp [sizeof_collection [get_ports $opt(ports_or_pins)]]}
#@                 }
#@                 if {$tmp == {} || $tmp == 0} {
#@                     if {$opt(-fanup) || $opt(-fandown)} {
#@                         set opt(ports_or_pins) [filter_collection [get_pins -of_objects $opt(ports_or_pins)] {full_name!~*/CK && full_name!~*/phi* && full_name!~*/ti && full_name!~*/te}]
#@                     } else {
#@                         if {$opt(-fanin)} {
#@                             set opt(ports_or_pins) [filter_collection [get_pins -of_objects $opt(ports_or_pins)] {pin_direction==in && full_name!~*/CK && full_name!~*/phi* && full_name!~*/ti && full_name!~*/te}]
#@                         } else {
#@                             set opt(ports_or_pins) [filter_collection [get_pins -of_objects $opt(ports_or_pins)] {pin_direction==out}]
#@                         }
#@                     }
#@                 } else {
#@                     if {[string match */* $opt(ports_or_pins)]} {
#@                         set opt(ports_or_pins) [get_pins $opt(ports_or_pins)]
#@                     } else {
#@                         set opt(ports_or_pins) [get_ports $opt(ports_or_pins)]
#@                     }
#@                 }
#@             } else {
#@                 redirect $sh_dev_null {set tmp [sizeof_collection [get_cells $opt(ports_or_pins)]]}
#@                 if {$tmp != {} && $tmp != 0} {
#@                     if {$opt(-fanup) || $opt(-fandown)} {
#@                         set opt(ports_or_pins) [filter_collection [get_pins -of_objects $opt(ports_or_pins)] {full_name!~*/CK && full_name!~*/phi* && full_name!~*/ti && full_name!~*/te}]
#@                     } else {
#@                         if {$opt(-fanin)} {
#@                             set opt(ports_or_pins) [filter_collection [get_pins -of_objects $opt(ports_or_pins)] {pin_direction==in && full_name!~*/CK && full_name!~*/phi* && full_name!~*/ti && full_name!~*/te}]
#@                         } else {
#@                             set opt(ports_or_pins) [filter_collection [get_pins -of_objects $opt(ports_or_pins)] {pin_direction==out}]
#@                         }
#@                     }
#@                 }
#@             }
#@         }
#@ 
#@         set result {}
#@         foreach_in_collection port_or_pin_or_maybe_net $opt(ports_or_pins) {
#@             if {[my_get_attribute $port_or_pin_or_maybe_net object_class] == {net}} {
#@                 if {$opt(-fanup) || $opt(-fandown)} {
#@                     set port_or_pin_or_maybe_net [all_connected $port_or_pin_or_maybe_net]
#@                 } else {
#@                     if {$opt(-fanin)} {
#@                         set port_or_pin_or_maybe_net [filter_collection [all_connected $port_or_pin_or_maybe_net] {pin_direction==in}]
#@                     } else {
#@                         set port_or_pin_or_maybe_net [filter_collection [all_connected $port_or_pin_or_maybe_net] {pin_direction==out}]
#@                     }
#@                 }
#@             }
#@             foreach_in_collection port_or_pin $port_or_pin_or_maybe_net {
#@                 if {$opt(-debug)} {
#@                     echo Information: Recursing [my_get_attribute $port_or_pin object_class] [get_object_name $port_or_pin]
#@                 }
#@                 set down 0
#@                 if { [my_get_attribute $port_or_pin object_class] == {pin} && \
#@                      [is_true [my_get_attribute [get_cells_of_objects $port_or_pin] is_hierarchical]] } {
#@                     if {$opt(-fanin)} {
#@                         if {[get_attribute_pin_direction $port_or_pin] != {in}} {
#@                             set down 1
#@                         }
#@                     }
#@                 }
#@                 set fanout 0
#@                 if {$opt(-fanup)} {
#@                     if {[get_attribute_pin_direction $port_or_pin] == {in}} {
#@                         set opt(-fanin) 1
#@                     } elseif {[get_attribute_pin_direction $port_or_pin] == {out}} {
#@                         set opt(-fanin) 0
#@                     } else {
#@                         set opt(-fanin) 1
#@                         set fanout 1
#@                     }
#@                     set down 0
#@                 }
#@                 if {$opt(-fandown)} {
#@                     if {[get_attribute_pin_direction $port_or_pin] == {in}} {
#@                         set opt(-fanin) 0
#@                     } elseif {[get_attribute_pin_direction $port_or_pin] == {out}} {
#@                         set opt(-fanin) 1
#@                     } else {
#@                         set opt(-fanin) 1
#@                         set fanout 1
#@                     }
#@                     if {[my_get_attribute $port_or_pin object_class] == {pin}} {
#@                         set down 1
#@                     }
#@                 }
#@                 set needs_rebuild_collection 0
#@                 set tmp [recurse $port_or_pin 0 0 0 0 $down 0]
#@                 if {$tmp != {}} {
#@                     append_to_collection -unique result $tmp
#@                 }
#@                 if {$fanout} {
#@                     set opt(-fanin) 0
#@                     set tmp [recurse $port_or_pin 0 0 0 0 $down 0]
#@                     if {$tmp != {}} {
#@                         append_to_collection -unique result $tmp
#@                     }
#@                 }
#@             }
#@         }
#@     }
#@ 
#@     if {$opt(-print)} {
#@         array unset opt
#@         return [sizeof_collection $result]
#@     } else {
#@         array unset opt
#@         return $result
#@     }
#@ }
#@ 
#@ proc fast_all_fanin_or_fanout_defaults {} {
#@     global opt
#@ 
#@     unset -nocomplain opt
#@ 
#@     set opt(ports_or_pins) {}
#@     set opt(-clock_tree) 0
#@     set opt(-cells) 0
#@     set opt(-pins) 0
#@     set opt(-ports) 0
#@     set opt(-input_pins_only) 0
#@     set opt(-output_pins_only) 0
#@     set opt(-no_endpoints) 0
#@     set opt(-no_stop_at_endpoints) 0
#@     set opt(-endpoints_only) 0
#@     set opt(-stop_at_endpoints_only) 0
#@     set opt(-stage_endpoints_only) 0
#@     set opt(-nets) 0
#@     set opt(-include_hierarchy) 0
#@     set opt(-include_startpoints) 0
#@     set opt(-summary) 0
#@     set opt(-levels) -1
#@     set opt(-stages) -1
#@     set opt(-dont_count_buffers) 0
#@     set opt(-dont_count_noninverting_buffers) 0
#@     set opt(-dont_count_noninverting_trees) 0
#@     set opt(-dont_count_latches) 0
#@     set opt(-dont_count_filter_cell) {}
#@     set opt(-include_uncounted_buffers) 0
#@     set opt(-include_only_noninverted_nets) 0
#@     set opt(-include_only_inverted_nets) 0
#@     set opt(-depth) -1
#@     set opt(-include_levels_endpoints) 0
#@     set opt(-stop_at) {}
#@     set opt(-stop_at_high_fanout_nets) 0
#@     set opt(-stop_at_fanout_gt) 0
#@     set opt(-stop_at_nonregular_nets) 0
#@     set opt(-stop_at_filter_cell) {}
#@     set opt(-stop_at_filter_port_or_pin) {}
#@     set opt(-stop_at_filter_net) {}
#@     set opt(-stop_at_filter_regexp) false
#@     set opt(-stop_at_latches) 0
#@     set opt(-debug) 0
#@     set opt(-debug2) 0
#@     set opt(-verbose) 0
#@     set opt(-print) 0
#@     set opt(-first_path_only) 0
#@     set opt(-constants) 0
#@ }
#@ 
#@ proc fast_all_fanout {args} {
#@     global opt
#@ 
#@     fast_all_fanin_or_fanout_defaults
#@ 
#@     parse_proc_arguments -args $args opt
#@ 
#@     set opt(-fanin) 0
#@     set opt(-fanup) 0
#@     set opt(-fandown) 0
#@ 
#@     return [fast_all_fanin_or_fanout]
#@ }
#@ 
#@ proc fast_all_fanin {args} {
#@     global sh_dev_null
#@     global opt
#@     global clock_port_pin_names
#@ 
#@     fast_all_fanin_or_fanout_defaults
#@ 
#@     parse_proc_arguments -args $args opt
#@ 
#@     set opt(-fanin) 1
#@     set opt(-fanup) 0
#@     set opt(-fandown) 0
#@ 
#@     return [fast_all_fanin_or_fanout]
#@ }
#@ 
#@ proc fast_all_fanup {args} {
#@     global sh_dev_null
#@     global opt                            
#@     global clock_port_pin_names
#@ 
#@     fast_all_fanin_or_fanout_defaults
#@ 
#@     parse_proc_arguments -args $args opt
#@ 
#@     set opt(-fanin) 0
#@     set opt(-fanup) 1
#@     set opt(-fandown) 0
#@ 
#@     return [fast_all_fanin_or_fanout]
#@ }
#@ 
#@ proc fast_all_fandown {args} {
#@     global sh_dev_null
#@     global opt
#@     global clock_port_pin_names
#@ 
#@     fast_all_fanin_or_fanout_defaults
#@ 
#@     parse_proc_arguments -args $args opt
#@ 
#@     set opt(-fanin) 0
#@     set opt(-fanup) 0
#@     set opt(-fandown) 1
#@ 
#@     return [fast_all_fanin_or_fanout]
#@ }
#@ 
#@ foreach in_or_out [list in out up down] {
#@     define_proc_attributes fast_all_fan$in_or_out \
#@         -info "recurses through design hierarchy without retiming the design" \
#@         -define_args {
#@             {ports_or_pins                    "ports or pins"                                                "v" string optional}
#@             {-clock_tree                      "recurse all clock trees"                                      ""  boolean optional}
#@             {-cells                           "return a collection of cells"                                 ""  boolean optional}
#@             {-pins                            "return a collection of pins"                                  ""  boolean optional}
#@             {-ports                           "return a collection of ports"                                 ""  boolean optional}
#@             {-input_pins_only                 "return only input pins"                                       ""  boolean optional}
#@             {-output_pins_only                "return only output pins"                                      ""  boolean optional}
#@             {-no_endpoints                    "dont include endpoints"                                       ""  boolean optional}
#@             {-no_stop_at_endpoints            "dont include stop at endpoints"                               ""  boolean optional}
#@             {-endpoints_only                  "only include endpoints"                                       ""  boolean optional}
#@             {-stage_endpoints_only            "only include stage endpoints"                                 ""  boolean optional}
#@             {-nets                            "return a collection of nets"                                  ""  boolean optional}
#@             {-include_hierarchy               "include hierarchical pins and nets"                           ""  boolean optional}
#@             {-include_startpoints             "include startpoints in returned list"                         ""  boolean optional}
#@             {-levels                          "number of cell levels to recurse"                             "v" int optional}
#@             {-dont_count_buffers              "dont treat buffers and inverters as a cell level"             ""  boolean optional}
#@             {-dont_count_noninverting_buffers "dont treat noninverting buffers as a cell level"              ""  boolean optional}
#@             {-dont_count_noninverting_trees   "dont treat noninverting buffer trees as a cell level"         ""  boolean optional}
#@             {-dont_count_latches              "dont treat clock gating latches as a cell level"              ""  boolean optional}
#@             {-dont_count_filter_cell          "dont count if cell matches this filter expression"            ""  string optional}
#@             {-include_uncounted_buffers       "but still include them in the result"                         ""  boolean optional}
#@             {-include_only_noninverted_nets   "but still include them in the result"                         ""  boolean optional}
#@             {-include_only_inverted_nets      "but still include them in the result"                         ""  boolean optional}
#@             {-depth                           "number of levels of hierarchy to descend"                     "v" int optional}
#@             {-stages                          "number of sequential cell levels to traverse"                 "v" int optional}
#@             {-include_levels_endpoints        "Treat levels and depths as endpoints"                         ""  boolean optional}
#@             {-first_path_only                 "Follows the first pin only for multiple fanout nets"          ""  boolean optional}
#@             {-stop_at                         "stop recursing at given object"                               "v" string optional}
#@             {-stop_at_endpoints_only          "only include stop at endpoints"                               ""  boolean optional}
#@             {-stop_at_high_fanout_nets        "stop recursing if net fanout is > 32"                         ""  boolean optional}
#@             {-stop_at_fanout_gt               "stop recursing if net fanout is > threshold"                  ""  int optional}
#@             {-stop_at_nonregular_nets         "stop recursing if lower net doesn't match pin"                ""  boolean optional}
#@             {-stop_at_filter_cell             "stop recursing if cell matches this filter expression"        ""  string optional}
#@             {-stop_at_filter_port_or_pin      "stop recursing if port or pin matches this filter expression" ""  string optional}
#@             {-stop_at_filter_net              "stop recursing if net matches this filter expression"         ""  string optional}
#@             {-stop_at_filter_regexp           "use regexp in filter expression"                              ""  boolean optional}
#@             {-stop_at_latches                 "stop at latches"                                              ""  boolean optional}
#@             {-summary                         "show summary statistics"                                      ""  boolean optional}
#@             {-debug                           "debug"                                                        ""  boolean optional}
#@             {-debug2                          "debug2"                                                       ""  boolean optional}
#@             {-verbose                         "verbose"                                                      ""  boolean optional}
#@             {-print                           "print"                                                        ""  boolean optional}
#@             {-to                              "for compatibility with all_fan(in|out)"                       ""  boolean optional}
#@             {-from                            "for compatibility with all_fan(in|out)"                       ""  boolean optional}
#@             {-startpoints_only                "for compatibility with all_fan(in|out)"                       ""  boolean optional}
#@             {-only_cells                      "for compatibility with all_fan(in|out)"                       ""  boolean optional}
#@             {-flat                            "for compatibility with all_fan(in|out)"                       ""  boolean optional}
#@             {-trace_arcs                      "for compatibility with all_fan(in|out)"                       ""  one_of_string {optional {values {timing all}}}}
#@             {-constants                       "print constant_value attributes on pins too"                  ""  boolean optional}
#@         }
#@ }
#@ 
#@ # -- End source recurse.tcl

#@ source2 q2useful.tcl
#@ # -- Starting source q2useful.tcl

#@ 
#@ # Useful procedures specific to Q2
#@ 
#@ proc get_object_name2 {col} {
#@     if { $col == {} } { 
#@         return {} 
#@     } else {
#@         return [get_object_name $col]
#@     }
#@ }
#@ 
#@ proc restore_pparch {} {
#@     global pparch_implementations
#@     suppressed {UID-4 UID-109 SEL-003} {
#@         foreach implementation_name $pparch_implementations {
#@             remove_attribute [find implementation $implementation_name] dont_use
#@         }
#@     }
#@ }
#@ 
#@ proc no_pparch {} {
#@     global pparch_implementations
#@     global synthetic_library
#@     set pparch_implementations {}
#@     suppressed {UID-4 UID-109 SEL-003} {
#@         foreach outer_synthetic_library_name $synthetic_library {
#@             foreach_in_collection module_name [find module $outer_synthetic_library_name/*] {
#@                 foreach inner_synthetic_library_name $synthetic_library {
#@                     set tmp_list [list pparch apparch]
#@                     foreach tmp $tmp_list {
#@                         set implementation_name $inner_synthetic_library_name/[get_object_name $module_name]/$tmp
#@                         if {[find implementation $implementation_name] != {}} {
#@                             if {[remove_from_collection [find implementation $inner_synthetic_library_name/[get_object_name $module_name]/*] \
#@                                     [list [find implementation $inner_synthetic_library_name/[get_object_name $module_name]/sim] \
#@                                           [find implementation $implementation_name]]] != {}} {
#@                                 set_dont_use $implementation_name
#@                                 lappend pparch_implementations $implementation_name
#@                             }
#@                         }
#@                     }
#@                 }
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc set_q2_clock_latencies {clock_name tree_latencies {source_latencies {}} } {
#@     global analysis_type
#@ 
#@     set wc_offset  [lindex $tree_latencies 0]
#@     set bc_offset  [lindex $tree_latencies end]
#@     # if { [llength $tree_latencies] == 3 } {
#@     #     set nom_offset [lindex $tree_latencies 1]
#@     # } elseif { $wc_offset eq {unk} || $bc_offset eq {unk} } {
#@     #     set nom_offset unk
#@     # } else {
#@     #     set nom_offset [expr $bc_offset + (($wc_offset - $bc_offset) / 3)]
#@     # }
#@ 
#@     switch -regexp $analysis_type {
#@         {bc_wc} { eval "set_clock_latency -max $wc_offset $clock_name"
#@                   eval "set_clock_latency -min $bc_offset $clock_name" }
#@         {wc}    { eval "set_clock_latency $wc_offset $clock_name" }
#@         {bc}    { eval "set_clock_latency $bc_offset $clock_name" }
#@     }
#@ 
#@     if { [llength $source_latencies] > 0 } {
#@     
#@         # No calculation for nominal yet!
#@         set latencies(max) [lfirst $source_latencies]
#@         set latencies(min) [llast  $source_latencies]
#@ 
#@         # SPONG - limited support for different analysis types - merge into above switch ??   
#@         switch -regexp $analysis_type {
#@             {bc_wc} { # make same as worst case for the moment
#@                       set latencies(min) $latencies(max) }
#@             {wc}    { set latencies(min) $latencies(max) }
#@             {bc}    { set latencies(max) $latencies(min) }
#@         }
#@ 
#@         foreach op_cond {max min} {
#@             set late_latency  [lfirst $latencies($op_cond)]
#@             set early_latency [llast  $latencies($op_cond)]
#@     
#@             puts "$clock_name $op_cond source latencies, late: $late_latency, early: $early_latency"
#@     
#@             set_clock_latency "-$op_cond" -source -late  $late_latency   $clock_name
#@             set_clock_latency "-$op_cond" -source -early $early_latency $clock_name    
#@         }
#@     }
#@ }
#@ 
#@ 
#@ proc create_virtual_clock { clock_name period tree_latency source_latency {waveform {}} } {
#@ 
#@     global setup_uncertainty
#@     global hold_uncertainty
#@ 
#@     if { [llength $waveform] == 0 } {
#@         set waveform [simple_clock_waveform $period]
#@     }
#@     set name virtual_$clock_name
#@     regsub {virtual_ref0} $name {vrt_ref0} name
#@     
#@     create_clock -name $name -period $period -waveform $waveform
#@     
#@     find clock $name
#@     
#@     set_clock_uncertainty -setup $setup_uncertainty $name
#@     set_clock_uncertainty -hold  $hold_uncertainty  $name
#@     set_q2_clock_latencies $name $tree_latency $source_latency
#@ }
#@ 
#@ proc create_clock_from_root { clock_name root_name period tree_latency source_latency {waveform {}} } {
#@ 
#@     global setup_uncertainty
#@     global hold_uncertainty
#@     global clock_transition
#@     
#@     if { [llength $waveform] == 0 } {
#@         set waveform [simple_clock_waveform $period]
#@     }
#@ 
#@     create_clock $root_name -name $clock_name -period $period -waveform $waveform
#@ 
#@     find clock $clock_name
#@ 
#@     set_clock_uncertainty -setup $setup_uncertainty $clock_name
#@     set_clock_uncertainty -hold  $hold_uncertainty  $clock_name
#@     set_q2_clock_latencies $clock_name $tree_latency $source_latency
#@     set_clock_transition $clock_transition $clock_name
#@ }
#@ 
#@ 
#@ proc create_clock_from_port { clock_name port_name period tree_latency source_latency {waveform {}} } {
#@ 
#@     global setup_uncertainty
#@     global hold_uncertainty
#@     global clock_transition
#@     
#@     if { [llength $waveform] == 0 } {
#@         set waveform [simple_clock_waveform $period]
#@     }
#@ 
#@     # W.....g: Creating a clock source on inout port '...'. (UITE-123)
#@     set pname [find port $port_name] 
#@     suppressed UITE-123 "create_clock $pname -name $clock_name -period $period -waveform {$waveform}"
#@ 
#@     set clock [find clock $clock_name]
#@     
#@     set_clock_uncertainty -setup $setup_uncertainty $clock
#@     set_clock_uncertainty -hold  $hold_uncertainty $clock
#@     set_q2_clock_latencies $clock_name $tree_latency $source_latency   
#@     set_clock_transition $clock_transition $clock
#@     
#@     set_drive 0 [find port $port_name]
#@     
#@ }
#@ 
#@ proc create_generated_divided_clock { clock_name divide_ratio master_pin root tree_latency source_latency} {
#@ 
#@     global setup_uncertainty
#@     global hold_uncertainty
#@     global clock_transition
#@ 
#@     create_generated_clock -name $clock_name -divide_by $divide_ratio -source $master_pin $root
#@                     
#@     find clock $clock_name
#@     
#@     set_clock_uncertainty -setup $setup_uncertainty $clock_name
#@     set_clock_uncertainty -hold  $hold_uncertainty  $clock_name
#@     set_q2_clock_latencies $clock_name $tree_latency $source_latency
#@     set_clock_transition $clock_transition $clock_name
#@     
#@     set_dont_touch_network $clock_name
#@ 
#@ }
#@ 
#@ # Some ideal net stuff (and dont_touch) (and networks)
#@ 
#@ proc init_ideal_nets {} {
#@     global ideal_nets
#@     global non_sdc_commands
#@     if { [info exists ideal_nets] } {
#@         unset ideal_nets
#@     }
#@     
#@     set pre_2006_primetime_support {
#@             if { [product_version_year] < 2006 } {
#@             
#@                 proc propagate_ideal_network {net} {
#@                     upvar counts counts
#@                     # try to fanout through this network
#@                     set loads [filter [all_connected -leaf $net] "pin_direction==in"]
#@                     foreach_in_collection load $loads {
#@                         set cellname [dirname [get_object_name $load]]
#@                         set celltype [get_attribute [get_cells $cellname] ref_name]
#@                         switch -glob $celltype {
#@                             "INVX*" {
#@                                 set_ideal_network [find pin $cellname/Z] 0
#@                             }
#@                             "CTUN2*" {
#@                                 set_ideal_network [find pin $cellname/Z] 0
#@                             }
#@                             "CTUI*" {
#@                                 set_ideal_network [find pin $cellname/Z] 0
#@                             }
#@                             "BUF*" {
#@                                 set_ideal_network [find pin $cellname/Z] 0
#@                             }
#@                             "*_CKBUFX16" {
#@                                 set_ideal_network [find pin $cellname/o] 0
#@                             }
#@                             "*_INVX*" {
#@                                 set_ideal_network [find pin $cellname/o] 0
#@                             }
#@                             "*_BUFX*" {
#@                                 set_ideal_network [find pin $cellname/o] 0
#@                             }
#@                             default {
#@                                 if { ! [info exists counts($celltype) ] } { set counts($celltype) 0 }
#@                                 set counts($celltype) [expr $counts($celltype)+1]
#@                             }
#@                         }
#@                     }
#@                 }
#@             
#@                 proc set_ideal_network {arg {top 1}} {
#@                     if { $top } {
#@                         puts "Information: Can't really set_ideal_network on [get_attribute $arg object_class] [get_object_name $arg], but doing my best..."
#@                         array unset counts
#@                     } else {
#@                         upvar counts counts
#@                     }
#@                     suppressed {SEL-004 SEL-005} {
#@                         foreach_in_collection pin [filter $arg "object_class==pin"] {
#@                             set net [get_nets -of_object $pin]
#@                             set_load -subtract_pin_load 0.0 $net
#@                             puts "    set_load -subtract_pin_load 0.0 [get_object_name $net] ([get_attribute [get_cells [dirname [get_object_name $pin]]] ref_name]/[filename [get_object_name $pin]])"
#@                             propagate_ideal_network $net
#@                         }
#@                         foreach_in_collection port [filter $arg "object_class==port"] {
#@                             set_drive 0 $port
#@                             puts "    set_drive 0 [get_object_name $port]"
#@                             propagate_ideal_network [all_connected $port]
#@                         }
#@                     }
#@                     if { $top } {
#@                         puts "    ignoring the following celltypes found on the network"
#@                         foreach celltype [array names counts] {
#@                             puts "      $celltype $counts($celltype)"
#@                         }
#@                         puts ""
#@                     }
#@ 
#@                 }
#@            
#@                 proc set_ideal_latency {delay pins} {
#@                     foreach_in_collection pin $pins {
#@                         set_annotated_delay  $delay -net -from $pin
#@                         puts "    set_annotated_delay  $delay -net -from [get_object_name $pin]"
#@                     }
#@                 }
#@             }
#@     }
#@ 
#@     set ideal_nets {{
#@         if { [info exists force_primetime_ideal_nets] && $force_primetime_ideal_nets  } {
#@ 
#@             # pre_2006_primetime_support skipped here
#@ 
#@             proc set_ideal_net {arg {top 1}} {
#@                 foreach_in_collection net $arg {
#@                     if { $top } {
#@                         puts "Information: Using approximation to set_ideal_net for [get_object_name $net]"
#@                     }
#@                     puts "Doing: set_ideal_network -no_propagate [get_object_name $net]"
#@                     suppressed {UITE-450} {set_ideal_network -no_propagate $net}
#@                 }
#@             }
#@             
#@         }
#@     }}
#@     set non_sdc_commands {}
#@     if { [product_version_year] < 2015 } {
#@         lappend non_sdc_commands {
#@             proc set_cell_mode {val cellname} {
#@                 # This is Prime Time version of the Design Compiler "set_cell_mode" command
#@                 puts "Doing: set_mode -type cell $val $cellname"
#@                 set_mode -type cell $val $cellname
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc do_ideal_nets { cmd str } {
#@     global running_primetime
#@     global ideal_nets
#@     global postlayout_netlist
#@     if { [exists_and_true postlayout_netlist] } {
#@         puts "Information: This is a postlayout netlist. No '$cmd' on '$str'"
#@     } else {
#@         lappend ideal_nets [concat $cmd $str]
#@         if { ! $running_primetime } {
#@             echoed [concat $cmd $str]
#@         }
#@     }
#@ }
#@ 
#@ proc do_non_sdc_command { cmd } {
#@     global running_primetime
#@     global non_sdc_commands
#@     lappend non_sdc_commands "$cmd"
#@     if { ! $running_primetime } {
#@         echoed "$cmd"
#@     }
#@ }
#@ 
#@ proc set_ideal_net_2004-12 {net} {
#@     global postlayout_netlist
#@     if { [exists_and_true postlayout_netlist] } {
#@         puts "Information: This is a postlayout netlist. No set_ideal_net_2004-12 on '$net'"
#@     } else {
#@         set pins [filter_collection [get_pins -of_object $net] "@pin_direction==out"]
#@         set ports [get_ports -of_object $net -filter "@port_direction == in || @port_direction == inout"]
#@         # hopefully inout applies only to top level ports
#@         if { $pins != {} } {
#@             foreach_in_collection pin $pins {
#@                 if { [get_attribute [get_cells -of_object $pin] is_hierarchical] == false } {
#@                     puts "set_ideal_network [get_object_name $pin] -no_propagate"
#@                     remove_ideal_network $pin
#@                     set_ideal_network $pin -no_propagate
#@                 }
#@             }
#@         }
#@         if { $ports != {} } {
#@             remove_ideal_network $ports
#@             set_ideal_network $ports -no_propagate
#@         }
#@         if { "$ports$pins" == {} } {
#@             puts "Err\or: no driving port or pin found for $net"
#@         }
#@     }
#@ }
#@ 
#@ proc my_set_ideal_net {str} {
#@     global running_primetime
#@     if { (! $running_primetime) && ( [product_version_month] >= 2004.12 ) } {
#@         lappend ideal_nets [concat set_ideal_net $str]
#@         echoed "set_ideal_net_2004-12 $str"
#@     } else {
#@         do_ideal_nets set_ideal_net $str
#@     }
#@ }
#@ 
#@ proc my_set_dont_touch {str} {
#@     do_ideal_nets set_dont_touch $str
#@ }
#@ 
#@ proc my_set_dont_touch_network {str} {
#@     do_ideal_nets set_dont_touch_network $str
#@ }
#@ 
#@ proc my_set_ideal_network {str} {
#@     do_ideal_nets set_ideal_network $str
#@ }
#@ 
#@ proc my_set_ideal_latency {args} {
#@     do_ideal_nets set_ideal_latency [join $args " "]
#@ }
#@ 
#@ proc my_set_ideal_transition {args} {
#@     do_ideal_nets set_ideal_transition [join $args " "]
#@ }
#@ 
#@ proc my_set_cell_mode {mode cells} {
#@     set cells [get_cells $cells]
#@     set cellnames [get_object_name $cells]
#@     do_non_sdc_command "set_cell_mode {$mode} \[get_cells \{$cellnames\}\]"
#@ }
#@ 
#@ proc read_tpd {} {
#@     # SPONG to reinstate # exec perl ../src/common/scripts/vhdl/vpp.pl -t: ../src/q4chip/src/top/q4chip.tpd -I: ../src/q4chip/src/templates ../scripts/tpd_info.tpt
#@ }
#@ 
#@ 
#@ proc reset_all_timing {} {
#@ 
#@     global running_primetime
#@     
#@     if {$running_primetime} {
#@         if {[product_version_year] >= 2017 } {
#@             reset_design
#@         } else {
#@             reset_design -timing
#@         }
#@         # Using this instead prevents PT removing the PC annotated lump RC values and SDF delays but is not very satisfactory for a 'clean' timing report:
#@         # remove_clock -all
#@     } else {
#@         
#@         echo "Resetting timing"
#@     
#@         remove_constraint -all
#@         remove_input_delay [all_inputs]
#@         remove_output_delay [all_outputs]
#@         remove_clock -all
#@ 
#@         global dont_reset_all_timing_attributes
#@ 
#@         if { [exists_and_true dont_reset_all_timing_attributes] } {
#@         
#@             echo "Warning: Not resetting design fully, because 'dont_reset_all_timing_attributes' is true"
#@ 
#@         } else {
#@ 
#@             echo {To make this quicker "set dont_reset_all_timing_attributes true" if you know what you are doing}
#@ 
#@             suppressed {UID-101 UID-339} { 
#@         
#@                 echo "Resetting Output Port Attributes"
#@     
#@                 foreach attr {load min_load fanout_load wire_capacitance } {
#@                     remove_attribute [all_outputs] $attr
#@                 }
#@ 
#@                 echo "Resetting Input Port Attributes"
#@     
#@                 foreach attr {user_case_value
#@                               driving_cell_rise
#@                               driving_cell_library_rise
#@                               driving_cell_no_drc
#@                               driving_cell_fall
#@                               driving_cell_library_fall } {
#@                     remove_attribute [all_inputs] $attr
#@                 }
#@ 
#@                 # Our create_clock and ideal_net artifacts
#@                 foreach attr { dont_touch_network
#@                                ideal_network_source
#@                                ideal_network_options
#@                                rise_drive
#@                                fall_drive
#@                              } {
#@                     remove_attribute [all_inputs] $attr
#@                 }
#@ 
#@                 echo "Resetting Internal Pin Attributes"
#@     
#@                 suppressed UID-95 {set all_hier_pins [get_internal_pins * -hier]}
#@ 
#@                 foreach attr {user_case_value
#@                               dont_touch_network
#@                               ideal_network_source
#@                               ideal_network_options
#@                              } {
#@                     remove_attribute $all_hier_pins $attr
#@                 }
#@                 remove_clock_uncertainty $all_hier_pins
#@                 remove_clock_latency     $all_hier_pins
#@ 
#@                 echo "Resetting Internal Net Attributes"
#@     
#@                 set all_hier_nets [get_nets * -hier]
#@         
#@                 foreach attr {ideal_net
#@                              } {
#@                     remove_attribute $all_hier_nets $attr
#@                 }
#@             }
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # Somewhat Agere library / structural mux type specific...
#@ 
#@ # Set Disable Timing on MUX DATA path
#@ proc sdt_mux_data { cells sd_value } {
#@     if { ( $sd_value == 0 ) } {
#@         set_disable_timing $cells -from D1 -to Q
#@     } elseif { ( $sd_value == 1 ) } {
#@         set_disable_timing $cells -from D0 -to Q
#@     } else {
#@         echo "Err\or: sdt_mux_data - unsupported sd_value $sd_value"
#@     }
#@ }
#@ 
#@ # Set Disable Timing on MUX DATA and Control paths
#@ proc sdt_mux_data_ctrl { cells sd_value } {
#@     # set_disable_timing $cells -from sel -to o
#@     set_disable_timing $cells -from SEL1 -to Q
#@     sdt_mux_data $cells $sd_value
#@ }
#@ 
#@ proc sdt_clock_mux_data_ctrl { cells sd_value } {
#@     # set_disable_timing $cells -from sel -to o
#@     set_disable_timing $cells -from S0 -to CK_OUT
#@     set_disable_timing $cells -from S1 -to CK_OUT
#@     if { ( $sd_value != 0 ) } { set_disable_timing $cells -from CK0 -to CK_OUT }
#@     if { ( $sd_value != 1 ) } { set_disable_timing $cells -from CK1 -to CK_OUT }
#@     if { ( $sd_value != 2 ) } { set_disable_timing $cells -from CK2 -to CK_OUT }
#@     if { ( $sd_value != 3 ) } { set_disable_timing $cells -from CK3 -to CK_OUT }
#@ }
#@ 
#@ ########
#@ 
#@ #proc read_agere_black_boxes {} {
#@ #    set all [find design *]
#@ #    read_file -format db ../results/agere_black_box_models.db
#@ #    foreach_in_collection des [remove_from_collection [find design *] $all] {
#@ #        current_design $des
#@ #        compile
#@ #    }
#@ #}
#@ 
#@ proc blockname {designname} {
#@     global local_designname_to_blockname
#@     if { [info exists local_designname_to_blockname($designname)] } {
#@         return $local_designname_to_blockname($designname)
#@     } else {
#@         return $designname
#@     }
#@ }
#@ 
#@ proc get_block_info {ver {field {}}} {
#@     global blocks_info
#@     global ilm_block_names
#@     array unset b
#@     # we may be passed in the full designname (which includes generics)
#@     set ver [blockname $ver]
#@     # get the block specific bits
#@     if { [lsearch [array names blocks_info] $ver] != -1 } {
#@         array set b $blocks_info($ver)
#@     } else {
#@         # what about uniquified designs
#@         foreach name [array names blocks_info] {
#@             if { [regexp "${name}_\[0-9\]" $ver] } {
#@                 array set b $blocks_info($name)
#@                 set b(block_name) $name               
#@                 break
#@             }
#@         }
#@     }
#@     # fill in some sort of generically
#@     if { [lsearch [array names b] lib] == -1 } {
#@         if {[string match reset_* $ver]} {
#@             set b(lib) book
#@         } elseif { [string match xpl2* $ver] } {
#@             set b(lib) xpl2_1t
#@         }
#@     }
#@     if { [lsearch [array names b] block_name] == -1 } {
#@         set b(block_name) $ver
#@     }
#@     # then fill in any default fields not so far filled in
#@     array set d $blocks_info(default)
#@     foreach f [array names d] {
#@         if { [lsearch [array names b] $f] == -1 } {
#@             set b($f) $d($f)
#@         }
#@     }
#@     # A useful flag
#@     set b(ilm) [expr [lsearch -exact $ilm_block_names $b(block_name)] != -1]
#@     
#@     # and return it
#@     if { $field != {} } {
#@         return $b($field)
#@     } else {
#@         return [array get b]
#@     }
#@ }
#@ 
#@ proc designname {ver} {
#@     global std_generics
#@     array set b [get_block_info $ver]
#@     if { [array get b designname] != {} } {
#@         return $b(designname)
#@     }
#@     set designname $ver
#@     while { [llength $b(generics)] > 0 }  {
#@         # double dereference (if necessary)
#@         append designname {_} [lfirst $b(generics)] [expr [lsecond $b(generics)]]
#@         set b(generics) [lreplace $b(generics) 0 1]
#@     }
#@     return $designname
#@ }
#@ 
#@ ###############
#@ 
#@ proc elab_parameters {ver} {
#@     global std_generics
#@     array set generics [get_block_info $ver generics]
#@     set parameters {}
#@     set designname $ver
#@     foreach n [ array names generics ] {
#@         # double dereference (if necessary)
#@         lappend parameters "$n=>[expr $generics($n)]"
#@     }
#@     return [join $parameters {,}]
#@ }
#@ 
#@ proc set_compile_options {} {
#@ 
#@     global running_primetime
#@     global running_physical_compiler
#@     global technology
#@     
#@     global physopt_enable_via_res_support
#@ 
#@     if {! $running_primetime} {
#@ 
#@         # All compiles, all technologies.
#@ 
#@         puts "proc set_compile_options"
#@ 
#@         # Some constraints we want tighter for synthesis than we are going to check
#@ 
#@         set_max_transition 0.3 [current_design]
#@ 
#@         # And others only really make sense for compiles
#@     
#@         set_critical_range 0.250 [current_design]
#@ 
#@         # All compiles, technology specific
#@ 
#@         if {    [string match SC9WT*   $technology] \
#@              || [string match TSMC65*  $technology] \
#@              || [string match TSMC40*  $technology] \
#@              || [string match AV16*    $technology] \
#@              || [string match TSMC7FF* $technology] \
#@              || [string match TSMC5FF* $technology] \
#@              || [string match TSMC3FF* $technology] \
#@            } {
#@             set_fix_multiple_port_nets -all 
#@         } else {
#@             echo Technology $technology not known
#@             exit
#@         }
#@ 
#@         if { $running_physical_compiler } {    
#@ 
#@             # PC specific, all technologies
#@ 
#@ 
#@             # PC specific, Technology specific
#@             if {   [string match SC9WT*   $technology] \
#@                 || [string match TSMC65*  $technology] \
#@                 || [string match TSMC40*  $technology] \
#@                 || [string match AV16*    $technology] \
#@                 || [string match TSMC7FF* $technology] \
#@                 || [string match TSMC5FF* $technology] \
#@                 || [string match TSMC3FF* $technology] \
#@                } {
#@ #SPONG 3NM: Check these vs MC reccommendations ) Is running_physical_compiler even set for dcg ?
#@ #SPONG 5NM: Check these vs MC reccommendations ) 
#@ 
#@                 # Check for TSMC65 later - SJ - 03/29/07
#@ 
#@                 # Denis suggests the following physical flags and switches
#@                 # set Capmult 1.1
#@                 # set Resmult 1.2
#@                 # during our tune-project we decided to go with lower values 11/10/2005 (Luc-Mark)
#@                 set Capmult 1.05
#@                 set Resmult 1.1
#@                 set_delay_estimation_options -max_unit_horizontal_capacitance_scaling_factor $Capmult \
#@                                              -max_unit_vertical_capacitance_scaling_factor   $Capmult
#@                 # set Resmult [env Resmult 1.2]
#@                 set_delay_estimation_options -max_unit_horizontal_resistance_scaling_factor $Resmult \
#@                                              -max_unit_vertical_resistance_scaling_factor   $Resmult
#@                 set_delay_estimation_options -max_via_resistance_scaling_factor 2.5
#@                 set physopt_enable_via_res_support true
#@ 
#@                 # And this is how Denis suggests modelling the power grid
#@                 #
#@                 # set Vias "-model_vias -mult_via_x 2 -mult_via_y 2" ;# ?
#@                 # eval set_mpc_pnet_options -name pwr6 -layer METAL6 -type pwr -width 1.28 -pitch 20.52 -offset 0 $Vias
#@                 # eval set_mpc_pnet_options -name gnd6 -layer METAL6 -type gnd -width 1.28 -pitch 20.52 -offset 10.26 $Vias
#@                 # eval set_mpc_pnet_options -name pwr7 -layer METAL7 -type pwr -width 1.66 -pitch 20.52 -offset 0 $Vias
#@                 # eval set_mpc_pnet_options -name gnd7 -layer METAL7 -type gnd -width 1.66 -pitch 20.52 -offset 10.26 $Vias
#@ 
#@                 # Where did this one come from ? (MS)
#@                 set_congestion_options -horizontal 0.77 -vertical 0.73 -max_util 0.92
#@             
#@             } else {
#@                 echo Technology $technology not known
#@                 exit
#@             }
#@         }
#@         
#@     }
#@ 
#@ }
#@ 
#@ proc set_q2_operating_conditions {} {
#@ 
#@     global technology
#@ 
#@     global tech_library
#@     global tech_library_file
#@ 
#@     global dont_use_min_library
#@     global only_use_min_library
#@     global only_use_typ_library
#@     global only_use_bch_library
#@     
#@     global running_primetime    
#@     global running_design_compiler_topographical
#@     global analysis_type
#@ 
#@     if {[string match SC9WT* $technology]} {
#@ 
#@         echo We have the technology: $technology
#@ 
#@         # SPONG - these should get set in common.tcl
#@         set min_op_cond "fast_-40_1.1"
#@         set typ_op_cond "typical_xxx"
#@         set max_op_cond "slow_125_0.9"
#@ 
#@     } elseif {[string match TSMC65* $technology]} {
#@         set min_op_cond "BCIND"
#@         set typ_op_cond "TYP"
#@         set max_op_cond "WCIND_WCT"
#@ 
#@     } elseif {[string match TSMC40* $technology]} {
#@         set min_op_cond "BCIND"
#@         set typ_op_cond "TYP"
#@         set max_op_cond "WCIND_WCT"
#@ 
#@     } elseif {[string match AV16* $technology]} {
#@         set min_op_cond "BC_TIMING"
#@         set bch_op_cond "BC_TIMING"
#@         set typ_op_cond "TYP_TIMING"
#@         set max_op_cond "WC_TIMING"
#@         
#@     } elseif {[string match TSMC7FF* $technology]} {
#@         set min_op_cond "BCIND"
#@         set bch_op_cond "BCIND"
#@         set typ_op_cond "BCIND"
#@         set max_op_cond "WCIND"
#@     } elseif {[string match TSMC5FF* $technology]} {
#@ #SPONG_5NM: Check these vs MC reccommendations
#@         set min_op_cond "BCIND"
#@         set bch_op_cond "BCIND"
#@         set typ_op_cond "BCIND"
#@         set max_op_cond "WCIND"
#@     } elseif {[string match TSMC3FF* $technology]} {
#@ #SPONG_3NM: Check these vs MC reccommendations
#@         set min_op_cond "BCIND"
#@         set bch_op_cond "BCIND"
#@         set typ_op_cond "BCIND"
#@         set max_op_cond "WCIND"
#@     }
#@ 
#@     if {   [string match SC9WT*   $technology] \
#@         || [string match TSMC65*  $technology] \
#@         || [string match TSMC40*  $technology] \
#@         || [string match AV16*    $technology] \
#@         || [string match TSMC7FF* $technology] \
#@         || [string match TSMC5FF* $technology] \
#@         || [string match TSMC3FF* $technology] \
#@        } {
#@ 
#@         # This could actually be any of WC,NOM,BC
#@         set the_ref_lib ${tech_library_file}:${tech_library}
#@ 
#@         
#@         if { 1 } {
#@ 
#@             puts "One library mode"
#@             set num_libs 1
#@             set the_op_cond $max_op_cond
#@             if { [exists_and_true only_use_min_library] } {
#@                 set the_op_cond $min_op_cond
#@             }
#@             if { [exists_and_true only_use_bch_library] } {
#@                 set the_op_cond $bch_op_cond
#@             }
#@             if { [exists_and_true only_use_typ_library] } {
#@                 set the_op_cond $typ_op_cond
#@             }
#@             
#@         } else {
#@             # For the moment we are not even going to consider 2 libs mode in DC,PC or PT
#@             # ...get_libs
#@             
#@         }
#@ 
#@ 
#@         if { $running_primetime } {
#@            switch -regexp $analysis_type {
#@                {bc_wc} {  puts "Warn\ing: PT analysis type bc_wc will be phased out"
#@                           if { $num_libs == 1 } {
#@                               echoed "set_operating_conditions -max $the_op_cond -lib $the_ref_lib -analysis_type bc_wc"
#@                           } else {
#@                               echoed "set_operating_conditions -max $max_op_cond -max_lib $max_ref_lib -min $min_op_cond -min_lib $min_ref_lib -analysis_type bc_wc"
#@                           }
#@                        }
#@                {wc}    {  echoed "set_operating_conditions $the_op_cond -lib $the_ref_lib -analysis_type on_chip_variation"
#@                        }
#@                {bc}    {  echoed "set_operating_conditions $the_op_cond -lib $the_ref_lib -analysis_type on_chip_variation"
#@                        }
#@            }
#@ 
#@         } else {
#@             # DC, PC etc.
#@             
#@             if { $running_design_compiler_topographical } { 
#@                 # This DC warn...g is just not applicable in dct
#@                 # W.....g: Current operating conditions specify best_case_tree as the interconnect model. Annotated resistance will be ignored in this case. (UID-389)
#@                 set supp "UID-389" 
#@             } else {
#@                 set supp ""
#@             }
#@             suppressed $supp {
#@                 if { $num_libs == 1 } {
#@                     echoed "set_operating_conditions $the_op_cond -lib $the_ref_lib"
#@                 } else {
#@                     echoed "set_operating_conditions -max $max_op_cond -max_lib $max_ref_lib -min $min_op_cond -min_lib $min_ref_lib"
#@                 }
#@             }
#@         }
#@ 
#@     } else {
#@         echo Technology $technology not known
#@         exit
#@     }
#@ 
#@ }
#@ 
#@ proc set_design_constraints { block_info_array_name {setup_wireloads 1} } {
#@ 
#@     upvar  $block_info_array_name block_info
#@     global tech_library
#@     global technology
#@     global running_cadence
#@     global blocks_info
#@     global running_design_compiler_topographical
#@ 
#@     puts "proc set_design_constraints"
#@ 
#@     set_q2_operating_conditions
#@ 
#@     if {[string match SC9WT* $technology]} {
#@ 
#@         # Set op conditions for current design
#@         set_max_area 0
#@         set_max_fanout 34 [current_design]
#@         set_max_transition 0.5 [current_design]
#@ 
#@ 
#@     } elseif {[string match TSMC65* $technology]} {
#@         # Set op conditions for current design
#@         set_max_area 0
#@         set_max_fanout 34 [current_design]
#@         set_max_transition 0.5 [current_design]
#@ 
#@ 
#@     } elseif {[string match TSMC40* $technology]} {
#@         # Set op conditions for current design
#@         set_max_area 0
#@         set_max_fanout 34 [current_design]
#@         set_max_transition 0.5 [current_design]
#@         
#@     } elseif {[string match AV16* $technology]} {
#@ 
#@         # Set op conditions for current design
#@         set_max_area 0
#@         set_max_fanout 34 [current_design]
#@         set_max_transition 0.3 [current_design]
#@ 
#@     } elseif {[string match TSMC7FF* $technology]} {
#@ 
#@         # Set op conditions for current design
#@         set_max_area 0
#@         set_max_fanout 33 [current_design]
#@         set_max_transition 0.28 [current_design]
#@ 
#@     } elseif {[string match TSMC5FF* $technology]} {
#@ 
#@ #SPONG_5NM: Check these vs MC reccommendations
#@ 
#@         # Set op conditions for current design
#@         if {! $running_cadence} {
#@             set_max_area 0
#@         }
#@         set_max_fanout 33 [current_design]
#@         set_max_transition 0.28 [current_design]
#@ 
#@     } elseif {[string match TSMC3FF* $technology]} {
#@ 
#@ #SPONG_3NM: Check these vs MC reccommendations
#@ 
#@         # Set op conditions for current design
#@         if {! $running_cadence} {
#@             set_max_area 0
#@         }
#@         set_max_fanout 33 [current_design]
#@         set_max_transition 0.28 [current_design]
#@ 
#@     } else {
#@         echo Technology $technology not known
#@         exit
#@     }
#@ 
#@     if { $setup_wireloads && !$running_design_compiler_topographical } {
#@ 
#@         if { [regexp {^(top|q4chip)$} $block_info(block_name)] } {
#@             set prefix {(Q|V|S|E|T|X|XPP|XPM|D|DMFE)_}
#@         } else {
#@             set prefix "($block_info(uniquification_prefix))"
#@         }
#@ 
#@         suppressed {SEL-004 SEL-005} { set all_cells [get_cells -hier * -filter "@is_hierarchical==true"] }
#@ 
#@         array unset cellname
#@         array unset cells
#@         array unset refnames
#@         foreach_in_collection cell $all_cells {
#@             set cellname [get_object_name $cell]
#@             set cells($cellname)   $cell
#@             set refnames($cellname) [get_attribute $cell ref_name]
#@         }
#@ 
#@         foreach cellname [array names cells] {
#@             regexp "^($prefix)?(.*?)(_\\d+)?$" $refnames($cellname) res d1 d2 refname2 d3
#@             set block_name2 [blockname $refname2]
#@             if { [info exists blocks_info($block_name2)] } {
#@                 array unset block_info2
#@                 array set block_info2 $blocks_info($block_name2)
#@                 if { [info exists block_info2(wire_load_model)] } {
#@                     puts "Refname $refnames($cellname) maps to $refname2 has blockname $block_name2"
#@                     echoed "set_wire_load_model -name [get_block_info $block_name2 wire_load_model] -library $tech_library \[get_cells $cellname\]"
#@                 }
#@             }
#@         }
#@ 
#@         if { $block_info(wire_load_model) != {} } {
#@             if { [regexp {^(TSMC_CLN90G_WLM)} $block_info(wire_load_model)] } {
#@                 puts "INFO:  TSMC wire load requested.  Using library:  TSMC_CLN90G_WIRE"
#@                 set_wire_load_model -name $block_info(wire_load_model) -library  TSMC_CLN90G_WIRE
#@             } else {
#@                 puts "INFO:  Non TSMC_90 wire load requested.  Using library:  $tech_library"
#@                 set_wire_load_model -name $block_info(wire_load_model) -library $tech_library
#@             }
#@             set_wire_load_mode $block_info(wire_load_mode)
#@         }
#@         
#@     }
#@ 
#@ }
#@ 
#@ ####
#@ 
#@ # The total delay (core_clock_info(period)) is made up of
#@ #
#@ #   output ff_delay
#@ # + output_logic_delay      
#@ # + output_transit_delay    
#@ # + top_level_transit_time  
#@ # + input_transit_delay     
#@ # + input_logic_delay       
#@ # + input ff_setup                
#@ # + clock_skew              
#@ # + clock_uncertainty
#@ 
#@ proc find_derate_factor { setup_hold clock_data early_late } {
#@     set f 1.00
#@ 
#@     global analysis_type
#@     global ocv_derate_factors
#@ 
#@     if { [regexp {ocv} $analysis_type] } {
#@ 
#@         array set factors $ocv_derate_factors($analysis_type)
#@         if { $factors($setup_hold) == {setup} } {
#@             set setup_hold setup
#@         }
#@         if { $factors($setup_hold) == {hold} } {
#@             set setup_hold hold
#@         }
#@ 
#@         foreach param $factors($setup_hold) {
#@             if { [regexp -- "-$clock_data" $param] &&
#@                  [regexp -- "-$early_late" $param] } {
#@                  regexp {[\d.]+} $param f
#@                  break
#@             }
#@         }
#@    
#@     }
#@     return $f
#@ }
#@ 
#@ proc calc_and_set_xx_delay { args } {
#@ 
#@     global running_design_compiler
#@     global running_design_compiler_topographical
#@     global ff_setup
#@     global ff_delay
#@     
#@     # This doesn't especially need to be a procedure, which would aleviate the 'uplevel 2' requirement.
#@     proc calc_minmax_delay { minmax raw_args_name } {
#@ 
#@         global running_design_compiler_topographical
#@         global running_design_compiler
#@         global analysis_type
#@     
#@         upvar $raw_args_name raw_args 
#@ 
#@         array set cmd_map {max lfirst min llast}
#@         array unset mm_args        
#@         foreach element [array names raw_args] {
#@             # Look specifically for list ranges. A bit restrictive but saves a lot of hassle.
#@             # puts "Raw arg $raw_args($element)"            
#@             if { [regexp {^-?(\.|\d)+ *-?(\.|\d)+$} $raw_args($element)] } {
#@                 set abc [$cmd_map($minmax) "$raw_args($element)"]
#@             } else {
#@                 set abc $raw_args($element)
#@             }
#@             set def [regsub {uplevel} $abc {uplevel 2}]
#@             set mm_args($element) [regsub {args\(} $def {mm_args(}]
#@             #puts "New arg $mm_args($element)"
#@         }
#@     
#@         set clock_latency         [lfirst $raw_args(-clock_latency)]
#@         set virtual_clock_latency [lfirst $raw_args(-virtual_clock_latency)]
#@     
#@         if { [regexp "bc" $analysis_type] } {
#@             set clock_latency         [llast $raw_args(-clock_latency)]
#@             set virtual_clock_latency [llast $raw_args(-virtual_clock_latency)]
#@         }
#@     
#@         if { $minmax == "max" } {
#@             if { $mm_args(direction) == "ip" } {
#@                 # virtual input clock is not derated
#@                 set clock_ocv [expr $virtual_clock_latency - ( $clock_latency * [find_derate_factor setup clock early] ) ]
#@             } else {
#@                 # virtual output clock is not normally derated
#@                 set clock_ocv [expr ( $clock_latency * [find_derate_factor setup clock late] ) - $virtual_clock_latency ]
#@             }
#@         } else {
#@             if { $mm_args(direction) == "ip" } {
#@                 # virtual input clock is not normally derated
#@                 set clock_ocv [expr ( $clock_latency * [find_derate_factor hold clock late] ) - $virtual_clock_latency  ]
#@             } else {
#@                 # virtual output clock is not derated
#@                 set clock_ocv [expr $virtual_clock_latency - ( $clock_latency * [find_derate_factor hold clock early] ) ]
#@             }
#@         }
#@     
#@         global postlayout_clock_skew
#@         if { [info exists postlayout_clock_skew] } {
#@             # assume we are doing the post clock tree inserted version of the sdc
#@             set pl_clock_skew $postlayout_clock_skew
#@         } else {
#@             set pl_clock_skew 0.0
#@         }
#@ 
#@         set margin [expr $mm_args(-clock_period) - $mm_args(-op_ff)               \
#@                                                  - $mm_args(-op_logic)            \
#@                                                  - $mm_args(-op_transit)          \
#@                                                  - $mm_args(-op_isolation)        \
#@                                                  - $mm_args(-top_transit)         \
#@                                                  - $mm_args(-ip_isolation)        \
#@                                                  - $mm_args(-ip_transit)          \
#@                                                  - $mm_args(-ip_logic)            \
#@                                                  - $mm_args(-ip_ff)               \
#@                                                  - $mm_args(-skew)                \
#@                                                  - $mm_args(-phase_error)         \
#@                                                  - $mm_args(-clock_uncertainty)   \
#@                                                  - $clock_ocv                     \
#@                                                  - $pl_clock_skew
#@                    ]
#@ 
#@         set margin [format {%5.3f} $margin]
#@         if { $margin > 0 } {
#@             if { $minmax == "max" } {
#@                 # Max (setup)
#@                 # We need to make sure that we aren't over generous (i.e. we don't give the margin to both
#@                 # input and output delay), so in fact give it to neither...
#@                 set fudge $margin
#@                 # We could alternatively give 33% of the margin to each of ip, op and top_transit ...
#@                 # set fudge [expr $margin *2/3]
#@                 # ... or 50/50
#@             } else {
#@                 # Min (hold)
#@                 set fudge 0
#@             }
#@         } else {
#@             set mm_args(-quiet) 0
#@             set fudge 0
#@         }
#@ 
#@         array set alt { ip op op ip }
#@         set a $alt($mm_args(direction))
#@         set delay [expr  $mm_args(-${a}_ff)                  \
#@                        + $mm_args(-${a}_logic)               \
#@                        + $mm_args(-${a}_transit)             \
#@                        + $mm_args(-${a}_isolation)           \
#@                        + $mm_args(-top_transit)              \
#@                        + $mm_args(-skew)                     \
#@                        + $fudge]
#@ 
#@         if { ! [expr $mm_args(-physical)] } {
#@             set delay [expr $delay + $mm_args(-${mm_args(direction)}_transit)]
#@         }
#@ 
#@         # Then show what we've done
#@ 
#@         if { ! $mm_args(-quiet) } {
#@ 
#@             puts ""
#@             puts "Subchip $minmax timing for block [get_object_name [current_design]] - $mm_args(-clock_name) - $mm_args(-comment)"
#@             puts ""
#@ 
#@             foreach a { delay margin } {
#@                 puts [format {%-30s %s} $a [set $a]]
#@             }
#@             puts ""
#@             foreach a [array names mm_args] {
#@                 if { [regexp (comment|direction|ports|clock_name|group|cmd_args|virtual_clock_latency|clock_latency) $a] } continue
#@                 set val $mm_args($a)
#@                 if { [expr $val] != $val } {
#@                     set val [format {%-4s %s} [expr $val] "($val)"]
#@                 }
#@                 puts [format {%-30s %s} $a $val]
#@             }
#@             puts ""
#@             puts [format {%-30s %s (%s)} {-clock_latency}         $clock_latency         $mm_args(-clock_latency)]
#@             puts [format {%-30s %s (%s)} {-virtual_clock_latency} $virtual_clock_latency $mm_args(-virtual_clock_latency)]
#@             puts [format {%-30s %s} {-clock_ocv}             $clock_ocv]
#@             puts [format {%-30s %s} {-postlayout_clock_skew} $pl_clock_skew]
#@         }
#@ 
#@         if { $margin < 0 } {
#@             puts "Warn\ing: Subchip i/o budget violated (margin = $margin) $mm_args(-comment)"
#@             puts ""
#@         }
#@ 
#@         return $delay
#@ 
#@     }
#@ 
#@     ##################
#@     # Main starts here
#@ 
#@     array set fulldir { ip input op output }
#@     array set fromto  { ip from  op to }
#@ 
#@     # An argument of the form "-args {-arg1 val1 -arg2 val2}" can be used to wrap up other args
#@     for {set i 0} { $i < [llength $args] } {incr i} {
#@         if { [lindex $args $i] == {-args} } {
#@             eval "set args \[lreplace \$args $i [expr $i+1] [lindex $args [expr $i+1]]\]"
#@         }
#@     }
#@ 
#@     set tmp $args
#@     unset args
#@     array set args { 
#@                      -clock_uncertainty     {[uplevel "set ${args(-clock_name)}_info(setup_uncertainty)"]}
#@                      -clock_period          {[uplevel "set ${args(-clock_name)}_info(period)"]}
#@                      -op_logic              0.0
#@                      -op_transit            {0.220 0.000}
#@                      -op_isolation          0.020
#@                      -top_transit           0.0
#@                      -ip_isolation          0.020
#@                      -ip_transit            {0.220 0.000}
#@                      -ip_logic              0.0
#@                      -skew                  0.0
#@                      -phase_error           0.0
#@ 
#@                      -minmax                0
#@                      -physical              {$running_design_compiler_topographical || !$running_design_compiler}
#@                      
#@                      -quiet                 0
#@                      -comment               ""
#@                      -group                 "default"
#@                      -cmd_args              ""
#@                      -set_ilm_load          0
#@                      direction              {}
#@                      ports                  {}
#@                    }
#@ 
#@     # Need actual strings in array for these (ie. not deferred eval)
#@     set args(-clock_name) [uplevel {set block_info(default_clock)}]
#@     set args(-op_ff)      [list [expr [lfirst $ff_delay(wc)] *  [find_derate_factor setup data late]]   \
#@                                 [expr [llast  $ff_delay(wc)] *  [find_derate_factor setup data early]]]
#@     set args(-ip_ff)      $ff_setup(wc)
#@     global ilm_design_names
#@     if { [lsearch $ilm_design_names [get_object_name [current_design]] ] == -1 } {
#@         set args(-ip_isolation) 0.0
#@         set args(-op_isolation) 0.0
#@     }
#@ 
#@     parse_proc_arguments -args $tmp args
#@ 
#@     set ref_clock_name $args(-clock_name)
#@     # Nasty hack for our extra ref[0-9]_ clocks
#@     set args(-clock_name) [regsub {^ref\d_} $ref_clock_name {}]
#@ 
#@     if { [uplevel "set $args(-clock_name)_info(virtual_present)"] } {
#@         set ref_clock_name virtual_$ref_clock_name
#@     }
#@ 
#@     if { $args(-group) == "default" } {
#@         set args(-group) "default_$fulldir($args(direction))s"
#@         puts "Using default path group: $args(-group)"
#@     }
#@     
#@     # add a couple more args
#@     
#@     set args(-clock_latency)         [uplevel "set ${args(-clock_name)}_info(tree_latency)"]
#@     set args(-virtual_clock_latency) [uplevel "set ${args(-clock_name)}_info(tree_latency)"]
#@                      
#@     # Calculate the margin - for both max and min versions of the arguments
#@     set delays(max) [calc_minmax_delay max args]
#@     
#@     if { $args(-minmax) } {
#@         set delays(min) [calc_minmax_delay min args]
#@     } else {
#@         set delays(min) $delays(max)
#@     }
#@ 
#@     puts ""
#@     puts "Setting timing for $args(-comment), clock = $ref_clock_name, path group = $args(-group)"
#@ 
#@     if { [is_a_collection $args(ports)] } {
#@         set ports $args(ports)
#@     } else {
#@         foreach px $args(ports) { echo "   " $px }
#@         set ports [get_ports $args(ports)]        
#@     }
#@     echo "Total ports: " [sizeof_collection $ports]
#@ 
#@     foreach pi $args(ports) {
#@         foreach mm {max min} {
#@             echoed "set_$fulldir($args(direction))_delay $delays($mm) -$mm -clock $ref_clock_name $args(-cmd_args) $pi"    
#@         }
#@     }
#@     group_path -name $args(-group) "-$fromto($args(direction))" $ports
#@         
#@     if { $args(-set_ilm_load) } {
#@         global ilm_output_port_load
#@         set_load $ilm_output_port_load $ports
#@     }
#@ 
#@     return "$delays(max) $delays(min)"
#@ 
#@ }
#@ 
#@ proc do_set_input_delay { ip_ports args } {
#@     #Warning: duplicate option '-xxx' overrides previous value. (CMD-018)
#@     uplevel "suppressed CMD-018 {calc_and_set_xx_delay ip {$ip_ports} $args}"
#@ }
#@ 
#@ proc do_set_output_delay { op_ports args } {
#@     #Warning: duplicate option '-xxx' overrides previous value. (CMD-018)
#@     uplevel "suppressed CMD-018 {calc_and_set_xx_delay op {$op_ports} $args}"
#@ }
#@ 
#@ proc set_cts_delay { delay pins } {
#@     global analysis_type
#@     
#@     if { [llength $delay] == 2 } {
#@         if { [regexp "bc" $analysis_type]} {
#@              set delay_value [lindex $delay 1]
#@         } else {
#@              set delay_value [lindex $delay 0]
#@         }
#@         my_set_ideal_latency $delay_value "\[get_pins $pins\]"
#@     } else {
#@         my_set_ideal_latency $delay "\[get_pins $pins\]"
#@     }
#@ }
#@ 
#@ proc set_cts_transition { delay pins } {
#@     global analysis_type
#@     
#@     if { [llength $delay] == 2 } {
#@         if { [regexp "bc" $analysis_type]} {
#@              set delay_value [lindex $delay 1]
#@         } else {
#@              set delay_value [lindex $delay 0]
#@         }
#@         my_set_ideal_transition $delay_value $pins
#@     } else {
#@         my_set_ideal_transition $delay $pins
#@     }
#@ }
#@ 
#@ # clock_name defines default clock_period as ${$clock_name}_info(period)
#@ # clock_name defines default clock_uncertainty as ${$clock_name}_info(setup_uncertainty)
#@ 
#@ define_proc_attributes calc_and_set_xx_delay    \
#@     -info {calculates and sets input or output delay} \
#@     -define_args {
#@         { direction     {direction}                                 direction one_of_string {required value_help {values {ip op}}}}
#@         { ports         {list of ports}                             {"object_list"} list required }
#@ 
#@         { -clock_name   {name of interface clock}                   {"xxx_clock"} string optional }
#@         { -clock_uncertainty {clock uncertainty}                    0.20 list   optional }
#@         { -clock_period {clock period}                              1.66 list   optional }
#@         
#@         { -op_ff        {driving flop clock to q delay}             xxxx list   optional }
#@         { -op_logic     {delay through logic in source block}       xxxx list   optional }
#@         { -op_transit   {physical delay in source block}            xxxx list   optional }
#@         { -op_isolation {delay of ilm isolation cells}              xxxx list   optional }
#@         { -top_transit  {physical delay between blocks}             xxxx list   optional }
#@         { -ip_isolation {delay of ilm isolation cells}              xxxx list   optional }
#@         { -ip_transit   {physical delay in dest block}              xxxx list   optional }
#@         { -ip_logic     {delay through logic in dest block}         xxxx list   optional }
#@         { -ip_ff        {dest flop setup time}                      xxxx list   optional }
#@         { -skew         {clock skew between blocks (src-dest)}      xxxx list   optional }
#@         { -phase_error  {known clock skew (src-dest)}               xxxx list   optional }
#@ 
#@         { -cmd_args     {Extra args for set_(in|out)put_delay}      {"-add_delay"} string optional }
#@         { -group        {Path group name}                           {"default"} string optional }
#@         
#@         { -minmax       {do separate min & max calculations}        {}   boolean optional }
#@         { -physical     {allow for physical effects}                {}   boolean optional }
#@         { -quiet        {do not show what is going on}              {}   boolean optional }        
#@         { -set_ilm_load {also set the load to ilm_output_port_load} {}   boolean optional }
#@ 
#@         
#@         { -comment      {a description of this delay}               {"desc"}   string  optional }
#@     }
#@ 
#@ ####
#@ 
#@ # Parameters:
#@ # setuphold is {setup hold} or single value
#@ # ip_transit is {max min} or single value
#@ 
#@ proc do_basic_set_input_delay { ports clock_name setuphold ip_transit {group {}} {misc {}} {cmd_args {}} } {
#@ 
#@     global running_design_compiler
#@     
#@     set ref_clock_name $clock_name
#@     # Nasty hack for our extra ref[0-9]_ clocks
#@     set clock_name [regsub {^ref\d_} $ref_clock_name {}]
#@     upvar ${clock_name}_info local_clock_info
#@     if { $local_clock_info(virtual_present) } {
#@         set ref_clock_name virtual_$ref_clock_name
#@     }
#@     set period $local_clock_info(period)
#@ 
#@     # Misc args - could all be done a lot neater
#@     set cmd_edges(a_pos) {}
#@     if { $misc == "ddr" } {
#@         set period [expr $period / 2.0]
#@         set cmd_edges(b_neg) {-add -clock_fall}
#@     }
#@ 
#@     # Real basic setup/hold calculation - note we DO NOT allow for the capture clock uncertainty
#@     set delays(max) [expr $period - [lfirst $setuphold]]
#@     set delays(min) [llast $setuphold]
#@ 
#@     if { $running_design_compiler } {
#@         # Input transit not present
#@         set delays(max) [expr $delays(max) + [lfirst $ip_transit]]
#@         set delays(min) [expr $delays(min) + [llast  $ip_transit]] 
#@     }
#@ 
#@     if { ( [llength $group] == 0 ) } {
#@         if { ! [is_a_collection $ports] } {
#@             set group [lfirst $ports]
#@         } else {
#@             set group "default_source_clocked_inputs"
#@         }
#@     }
#@ 
#@     puts ""
#@     puts "do_basic_set_input_delay $misc - path group $group"
#@ 
#@     if { ! [is_a_collection $ports] } {
#@         foreach px $ports { echo "   " $px }
#@         set ports [get_ports $ports]
#@     }
#@     echo "Total ports: " [sizeof_collection $ports]
#@ 
#@     foreach edge [array names cmd_edges] {
#@         foreach mm {max min} {
#@             echoed "set_input_delay $delays($mm) -$mm -clock $ref_clock_name $cmd_edges($edge) $cmd_args $ports" 
#@         }
#@     }
#@     echoed "group_path -name $group -from $ports -to $clock_name"
#@ 
#@ }
#@ 
#@ ###
#@ 
#@ proc do_source_set_input_delay { ports clock_name adjust setuphold ip_transit {group {}} {misc {}} {cmd_args {}} } {
#@ 
#@     global running_design_compiler
#@     
#@     set ref_clock_name $clock_name
#@     # Nasty hack for our extra ref[0-9]_ clocks
#@     set clock_name [regsub {^ref\d_} $ref_clock_name {}]
#@     upvar ${clock_name}_info local_clock_info
#@     if { $local_clock_info(virtual_present) || $local_clock_info(vrt_ref0_present)} {
#@         set ref_clock_name virtual_$ref_clock_name
#@         regsub {virtual_ref0} $ref_clock_name {vrt_ref0} ref_clock_name
#@     }
#@     set period $local_clock_info(period)
#@ 
#@     # Misc args - could all be done a lot neater
#@     set cmd_edges(a_pos) {}
#@     if { $misc == "ddr" } {
#@         set period [expr $period / 2.0]
#@         set cmd_edges(b_neg) {-add -clock_fall}
#@     }
#@ 
#@     # Real basic setup/hold calculation - note we DO NOT allow for the capture clock uncertainty
#@     # make adjustement for possible internal delay in the clock, e.g due to delay line
#@     
#@     if {[llength $adjust] == 1 } {
#@         set adjust_value $adjust
#@     } else {
#@         global analysis_type
#@         if {[regexp "wc" $analysis_type]} {
#@             set adjust_value [lfirst $adjust]
#@         } else {
#@             set adjust_value [llast $adjust]
#@         }
#@     }
#@     
#@     set delays(max) [expr $period - [lfirst $setuphold] + $adjust_value]
#@     set delays(min) [expr [llast $setuphold] + $adjust_value]
#@ 
#@     if { $running_design_compiler } {
#@         # Input transit not present
#@         set delays(max) [expr $delays(max) + [lfirst $ip_transit]]
#@         set delays(min) [expr $delays(min) + [llast  $ip_transit]] 
#@     }
#@ 
#@     if { ( [llength $group] == 0 ) } {
#@         if { ! [is_a_collection $ports] } {
#@             set group [lfirst $ports]
#@         } else {
#@             set group "default_source_clocked_inputs"
#@         }
#@     }
#@ 
#@     puts ""
#@     puts "do_source_set_input_delay $misc - path group $group"
#@ 
#@     if { ! [is_a_collection $ports] } {
#@         foreach px $ports {
#@             echo "   " $px 
#@         }
#@         set ports_str "\[get_ports {$ports}\]"
#@         set ports [get_ports $ports]
#@     } else {
#@         set ports_str $ports
#@     }
#@         echo "Total ports: " [sizeof_collection $ports]
#@ 
#@     foreach edge [array names cmd_edges] {
#@         foreach mm {max min} {
#@             echoed "set_input_delay $delays($mm) -$mm -clock $ref_clock_name $cmd_edges($edge) $cmd_args $ports_str" 
#@         }
#@     }
#@     echoed "group_path -name $group -from $ports_str -to $clock_name"
#@ 
#@ }
#@ 
#@ ####
#@ 
#@ proc get_ba_src_id {} {
#@     global synthesis_dir
#@     set ba_src_id [filename $synthesis_dir]
#@     
#@     # strip the (optional) "avago_(date)" part of directory names
#@ 
#@     regsub {^avago_\d\d\d\d\d\d-} $ba_src_id {} ba_src_id
#@ 
#@     # strip trailing "-<further_identification>" which we can use to differentiate multiple
#@     # analysis directories working on the same avago delivery (say with development versions
#@     # of the scripts)
#@     
#@     regsub -- {-.*$} $ba_src_id {} ba_src_id
#@ 
#@     puts "Back annotation source ID is '$ba_src_id' (from syndir = '$synthesis_dir')"
#@     return $ba_src_id
#@ }
#@ 
#@ proc report_cell_drive_strengths {} {
#@ 
#@     set num [sizeof_collection [get_cells -hier * -filter "@is_hierarchical==false"]]
#@     puts "Total non hierarchical cells = $num"
#@     set total 0
#@ 
#@     foreach drive {L 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20} {
#@         suppressed {SEL-004 SEL-005} { set n [sizeof_collection [get_cells -hier * -filter "@ref_name=~*X${drive}G1T*"]] }
#@         puts [format "%3s %6d %4.1f%%" "X$drive" $n [expr 100.0 * $n.0 / $num.0]]
#@         incr total $n 
#@     }
#@ 
#@     puts "Standard Cells found = $total. The rest ([expr $num-$total]) are hopefully rams or i/o."
#@ 
#@ }
#@ 
#@ proc report_recalculated_timing_paths2 {args} {
#@ 
#@     set rep [lindex $args 0]
#@ 
#@     set a [join [lrange $args 1 end]]
#@     if { [regexp -- {-nworst ([0-9]+)} $a dummy nworst] } {
#@         regsub -- {-nworst [0-9]+} $a {} a
#@     } else {
#@         set nworst 1
#@     }
#@     
#@     if { [regexp -- {-max_paths ([0-9]+)} $a dummy max_paths] } {
#@         regsub -- {-max_paths [0-9]+} $a {} a
#@     } else {
#@         set max_paths $nworst
#@     }
#@     
#@     if { ! [regexp -- {-slack_lesser_than ([\-0-9\.]+)} $a dummy slack_lesser_than] } {
#@         set slack_lesser_than 0
#@     }  
#@     
#@     if { ! [regexp -- {-slack_greater_than ([\-0-9\.]+)} $a dummy slack_greater_than] } {
#@         set slack_greater_than -10000.0
#@     }
#@     
#@     if { [regexp -- {-pba_mode (\w+)} $a dummy pba_mode] } {
#@         regsub -- {-pba_mode \w+} $a {} a
#@     } else {
#@         set pba_mode exhaustive
#@     }
#@     
#@     if { ( [product_version_year] >= 2017)  && ( $pba_mode == {exhaustive} ) } {
#@         
#@         # With the later versions it is possible to find a reasonable number (say up to around 5000) of worst paths exhaustively
#@         # On P5 we have ...
#@         # time { puts [sizeof_collection [set p [get_timing_paths  -pba_mode exh -max_paths 5000]]] }
#@         # 525955043 microseconds per iteration        
#@         # i.e. < 10 minutes
#@         
#@         time { echoed "
#@             report_timing $a                                       \
#@                     -slack_lesser_than     $slack_lesser_than      \
#@                     -slack_greater_than    $slack_greater_than     \
#@                     -max_paths             $max_paths              \
#@                     -nworst                1                       \
#@                     -path                  full_clock_expanded     \
#@                     -pba_mode       $pba_mode
#@         " }
#@         
#@     } elseif { [product_version_year] >= 2008 } {
#@         
#@         # Newer versions of Primetime start to tackle this correctly ...
#@         # (This is significantly safer than the older algorithm below ...)
#@         
#@         # First find all the failing endpoints, and pba the worst path to that. (Slack can be > 0 after this)
#@         
#@         time {
#@             set p1 [eval "get_timing_paths $a                                             \
#@                                      -slack_lesser_than     $slack_lesser_than      \
#@                                      -slack_greater_than    $slack_greater_than     \
#@                                      -max_paths             $max_paths              \
#@                                      -nworst                1                       \
#@                                      -path                  full_clock_expanded     \
#@                                      -pba_mode       path"]
#@         }
#@         
#@         if { [sizeof_collection $p1] == $max_paths } {
#@             echo "Err\or: get_recalculated_timing_paths2 more than $max_paths violating endpoints prior to recalculation"
#@         } else {
#@             echo "Inf\o: get_recalculated_timing_paths2: found [sizeof_collection $p1] failing endpoints prior to recalculation"
#@         }
#@         
#@         time {
#@             global pba_exhaustive_endpoint_path_limit
#@             set pba_exhaustive_endpoint_path_limit 500
#@             array unset done
#@             
#@             foreach_in_collection p $p1 {
#@                 set ep [get_object_name [get_attribute $p endpoint]]
#@                 if { ! [info exists done($ep)] } {
#@                     echo "Recalculate paths to '$ep'"
#@                     set slack [expr [get_attribute $p slack] + 0.001]
#@                     eval "$rep    $a                                                    \
#@                                     -pba_mode           $pba_mode                       \
#@                                     -to                 $ep                             \
#@                                     -path               full_clock_expanded             \
#@                                     -nworst             $nworst                         \
#@                                     -slack_greater_than $slack_greater_than             \
#@                                     -slack_lesser_than  $slack                          \
#@                          "
#@                     set done($ep) 1
#@                 }
#@             }
#@             
#@             set pba_exhaustive_endpoint_path_limit 25000
#@         }
#@         
#@     } else {
#@         
#@         # We are actually want to inspect all the failing paths, but for safety (runtime) we apply some limits
#@         # SPONG: and we should really verify that these are in fact large enough,
#@         #        i.e. that we don't actually hit my_max_paths or my_nworst  in any path_group
#@         
#@         set my_nworst    100
#@         set my_max_paths 5000
#@         
#@         set paths [eval "get_timing_paths $a -nworst $my_nworst -max_paths $my_max_paths -slack_lesser_than 0"]
#@         set paths [suppressed {SEL-005} { get_recalculated_timing_paths $paths } ]
#@         set paths [sort_collection $paths {slack}]
#@         
#@         # And now, we need to find just the nworst for each endpoint and re filter results on slack
#@         
#@         array unset epc
#@         set num_paths 0
#@         
#@         foreach_in_collection path $paths {
#@             set slack [get_attribute $path slack]
#@             if { $slack > $slack_lesser_than  } continue
#@             if { $slack < $slack_greater_than } continue
#@ 
#@             # implement nworst filter
#@             set ep  [get_attribute $path endpoint]
#@             set epn [get_object_name $ep]
#@             if { ! [info exists epc($epn) ] } {
#@                 set epc($epn) 0
#@             }
#@             if { $epc($epn) >= $nworst } continue
#@             incr epc($epn)
#@ 
#@             # and max_paths (should really be max_paths per group ...)
#@             if { $num_paths >= $max_paths } break
#@             echoed "$rep $path"
#@             incr num_paths
#@         }
#@         
#@     }    
#@ }
#@ 
#@ proc set_non_generated_clocks_async {} {
#@ 
#@     foreach_in_collection c [all_clocks] {
#@         set clocks([get_object_name $c]) [get_object_name $c]
#@     }
#@ 
#@     # Seems to work with 2006.06
#@ 
#@     redirect -variable tmp {
#@         report_clock -nosplit
#@     }
#@ 
#@     set flag false
#@     foreach l [split $tmp "\n"] {
#@         if { [regexp {^Generated +Master } $l] } { set flag true }
#@         regsub -all { +} $l { } l
#@         set l [split $l]
#@         set generated_clock  [lindex $l 0]
#@         set master_clock     [lindex $l 3]
#@         if { [info exists clocks($generated_clock)] && $flag} {
#@             unset clocks($generated_clock)
#@             lappend clocks($master_clock) $generated_clock
#@         }
#@     }
#@ 
#@     set cmd "set_clock_groups -asynchronous -allow_paths -name all_clocks_clock_group"
#@     foreach master_clock [array names clocks] {
#@         append cmd " -group {$clocks($master_clock)}"
#@     }
#@ 
#@     puts $cmd
#@     eval $cmd
#@ }
#@ 
#@ proc nocmlxtalk {} {
#@ 
#@     proc top_level_net {net} {
#@         set iter 0
#@         while { $net != {} } {
#@             set netname [get_object_name $net]
#@             set newnet {}
#@             foreach_in_collection pin [all_connected $net] {
#@                 set pinname [get_object_name $pin]
#@                 if { $pinname == [filename $pinname] } {
#@                     # its a top level port
#@                 } elseif { [dirname [get_object_name $pin]] == [dirname $netname] } {
#@                     set newnet [all_connected [get_pins [get_object_name $pin]]]
#@                     break
#@                 } else {
#@                     # its not a port
#@                 }
#@             }
#@             if { $newnet == {} } break
#@             if { [incr iter] > 50 } break
#@             set net $newnet
#@         }
#@         return $net
#@     }
#@ 
#@     proc pn2tlnn {pinname} {
#@         get_object_name [top_level_net [get_nets -of_object [get_pins $pinname]]]
#@     }
#@ 
#@     array unset cml_outputs
#@     array set cml_outputs {
#@         CLKCH_CML2CML       {o_clkoutp o_clkoutn}
#@         CLKCH_CMLBUF        {o_clkoutp o_clkoutn}
#@         CLKCH_CMLBUF_NoCAP  {o_clkoutp o_clkoutn}
#@         CML3G3B1G1T10       {OUTP OUTN}
#@         CML3G3B1C1G1T10     {OUTP OUTN}
#@         CTCML3G3B1G1T10     {OUTP OUTN}
#@         PLLCSPQV18G8T10     {VCOP VCON}
#@         CK3G3I1OV10G8T10F   {OCMLP OCMLN}
#@         CK3G3TI1OV10G8T10F  {OCMLP OCMLN}
#@         CK3G3I1JOV10G8T10F  {OCMLP OCMLN}
#@     }
#@ 
#@     foreach celltype1 [array names cml_outputs] {
#@         foreach_in_collection cell [suppressed {SEL-004 SEL-005} {get_cells -hier "*" -filter "@ref_name==$celltype1"}] {
#@             set cellname [get_object_name $cell]
#@             set nets "\[get_nets {[pn2tlnn $cellname/[lindex $cml_outputs($celltype1) 0] ] [pn2tlnn $cellname/[lindex $cml_outputs($celltype1) 1]]}\]"
#@             echoed "set nets $nets"
#@             echoed "set_si_delay_analysis -exclude -aggressors \$nets -victims \$nets"
#@         }
#@     }
#@     
#@     # and for some additional special cases on CML inputs ...
#@     if { [get_object_name [current_design]] == "dmfe"} {
#@         set nets "\[get_nets from_dm_clock_*\]"
#@         echoed "set nets $nets"
#@         echoed "set_si_delay_analysis -exclude -aggressors \$nets -victims \$nets"
#@     }
#@ 
#@     if { [get_object_name [current_design]] == "statistics"} {
#@         set nets "\[get_nets qdr_x2_clock_cml_*\]"
#@         echoed "set nets $nets"
#@         echoed "set_si_delay_analysis -exclude -aggressors \$nets -victims \$nets"
#@     }
#@ 
#@ }
#@ 
#@ proc check_all_clocks_uncertainties { {ignore_clocks {}} {verbose 0} } {
#@ 
#@     # just in case a collection of clocks or a wildcard is passed in, convert it to a list of clock names
#@     set new_ignore_clocks {}
#@     foreach clock_cond $ignore_clocks {
#@         suppressed {SEL-004 SEL-005} {set clocks [get_clocks [lfirst $clock_cond]]}
#@         if { $clocks == {} && $verbose } {
#@             echo "Info: check_all_clocks_uncertainties - no clocks matched ignore pattern [lfirst $clock_cond]"
#@         }
#@         foreach clockname [get_object_names $clocks] {
#@             lappend new_ignore_clocks [lreplace $clock_cond 0 0 $clockname]
#@         }
#@     }
#@     set ignore_clocks $new_ignore_clocks
#@ 
#@     foreach_in_collection c [get_clocks *] {
#@         set n [get_object_name $c]
#@ 
#@         foreach setup_hold {setup hold} {
#@             set ignore [expr ([lsearch -exact $ignore_clocks $n] != -1) || ([lsearch -exact $ignore_clocks "$n $setup_hold"] != -1)]
#@             set uncert [get_attribute $c "${setup_hold}_uncertainty"]
#@             if { ($uncert == {}) || ($uncert == 0) } {
#@                 if { $ignore } {
#@                     if $verbose { echo "Info: check_all_clocks_uncertainties - ignoring clock $n with no $setup_hold uncertainty set" }
#@                 } else {
#@                     echo "Err\or: check_all_clocks_uncertainties - clock $n has no $setup_hold uncertainty set (or set to 0)"
#@                 }
#@             } else {
#@                 if { $ignore } {
#@                     echo "Info: check_all_clocks_uncertainties - ignoring clock $n even though it DOES have $setup_hold uncertainty set"
#@                 } else {
#@                     if $verbose { echo "Info: check_all_clocks_uncertainties - clock $n $setup_hold uncertainty = $uncert" }
#@                 }
#@ 
#@             }
#@         }
#@     }
#@ }
#@ 
#@ 
#@ # calculate the start and end points of a through point that exists in an async path
#@ # writes the corresponding 'set_false_path' for the paths to a file desc and stdout
#@ # expects one start point and one or more end points
#@ proc write_async_report_line {through_pin_name async_rpt} {
#@     set start_point [all_fanin -flat -startpoints_only -to [get_pins $through_pin_name]]
#@     set end_point [all_fanout -flat -endpoints_only -from [get_pins $through_pin_name]]
#@     set stnum [sizeof_collection $start_point]
#@     set endnum [sizeof_collection $end_point]
#@     
#@     if {($stnum < 1) || ($stnum > 1) || ($endnum < 1)} {
#@         if {$stnum < 1} {
#@             puts "Warning:  got $stnum startpoints for $through_pin_name (expected 1)"
#@         }
#@         if {$stnum > 1} {
#@             puts "Err\or:  got $stnum startpoints for $through_pin_name (expected 1)"
#@         } 
#@         if {$endnum < 1} {
#@             puts "Warning:  got $endnum endpoints for $through_pin_name"
#@         }
#@     } else {
#@         if  {$endnum > 1} {
#@             puts "Warning:  got $endnum endpoints for $through_pin_name"
#@         }
#@         set epts ""
#@         foreach_in_collection pt $end_point {
#@             lappend epts [get_object_name $pt]
#@         }
#@         puts $async_rpt "\#    through: $through_pin_name  "
#@         puts $async_rpt "        set_false_path -from [get_object_name $start_point] -to \[get_pins {$epts}\]"
#@     }
#@ }
#@ 
#@ proc check_xxputs_are_constrained {dir filter verbose} {
#@ 
#@     global version
#@     echo ""
#@     echo "${dir}put Port constraint report for $version"
#@     echo "=============================================" 
#@     echo ""
#@ 
#@     set total  0
#@     set fcount 0
#@     set bcount 0
#@     set currdes [get_object_name [current_design]]
#@ 
#@     set virtual_clock_exists ""
#@     foreach_in_collection clock [get_clocks] {
#@         if { [regexp {virtual_(.*)} [get_object_name $clock] match clock_name] } {
#@             lappend virtual_clock_exists $clock_name
#@         }
#@     }
#@ 
#@     switch $dir {
#@         {in}    { set tofrom     from
#@                   set port_clock startpoint_clock
#@                 }
#@         {out}   { set tofrom     to
#@                   set port_clock endpoint_clock
#@                 }
#@     }
#@     
#@     foreach_in_collection port [all_${dir}puts] {
#@ 
#@         incr total
#@ 
#@         set name [get_object_name $port]
#@                 
#@         set doit 1
#@ 
#@         if { [regexp lv $filter] } {
#@             switch -regexp $name {
#@                 #func_clock_sel                  {set doit 0}
#@                 #use_test_reset                  {set doit 0}
#@                 #USE_TEST_RESET                  {set doit 0}
#@                 #^LV_                            {set doit 0}
#@                 #bypass_mindelays                {set doit 0}
#@             }
#@         }
#@         
#@         if { [regexp brcm $filter] } {
#@             switch -regexp $name {
#@                 #jtag_test_control               {set doit 0}
#@                 #jtag_test_status                {set doit 0}
#@                 #mbist_control                   {set doit 0}
#@                 #mbist_status                    {set doit 0}
#@                 #overstress_enable               {set doit 0}
#@                 #bcm_jtce                        {set doit 0}
#@                 #testscreen_split_dis            {set doit 0}
#@                 #^tm_                            {set doit 0}
#@                 #{^por$}                         {set doit 0}
#@             }
#@         }
#@         
#@         if { [regexp q4 $filter] } {
#@             switch -regexp $name {
#@                 #{^VESD$}                        {set doit 0}
#@                 #{^(DRAM|SRAM)(VSS|VDD|VREF)}    {set doit 0}
#@                 #{PRES(UP|DOWN)$}                {set doit 0}
#@                 {(^|_)clock(_raw)?(_[0-9]+)?(_x2)?(_in)?$} {set doit 0}
#@                 #{ctc_sbus_(in|out)_CLK$}         {set doit 0}
#@                 {lcp_request_[PN]_CLOCK$}        {set doit 0}
#@                 #{serdes_rx_rec_clk_([0-9]+)}     {set doit 0}
#@                 #{clock_NEG$}                    {set doit 0}
#@                 #lv_test_mode                    {set doit 0}
#@                 #^jtag_id                        {set doit 0}
#@                 {fcx_in_(0|4|6|10|12|16|18|22)}  {set doit 0}
#@                 {TO_PHY_C.*FIFO_DFI_CLK}         {set doit 0}
#@                 {FROM_PHY_C.*_DFI_CLK.*}         {set doit 0}
#@                 {TIELOW.*}                       {set doit 0}
#@             }
#@         }
#@         
#@         if { [regexp bidir $filter] } {
#@             if { [get_attribute $port direction] == {inout} } { set doit 0 }
#@         }
#@         set done 0
#@         
#@         # Filtered off pins
#@         
#@         if { ! $doit } {
#@             incr fcount
#@             echo "Information: ${dir}put port $name skipped due to filters"
#@             set done 1
#@         }
#@ 
#@         # Find and count the timing paths
#@ 
#@         array set count {min 0 max 0}
#@         
#@         if { ! $done } {
#@             foreach mm {max min} {
#@                 set paths($mm) [get_timing_paths -$tofrom $port -delay $mm]
#@                 foreach_in_collection path $paths($mm) {
#@                     set slack [get_attribute $path slack]
#@                     if { $slack != "INFINITY" } {
#@                         incr count($mm)
#@                         
#@                         # W.....g: Attribute 'startpoint_clock' does not exist on timing_path 'path' (ATTR-3)
#@                         suppressed ATTR-3 { set clock [get_attribute $paths($mm) $port_clock] }
#@                         if { [sizeof_collection $clock] } {
#@                             set clock_name [get_object_name $clock]
#@                             if { $clock_name in $virtual_clock_exists } {
#@                                 echo "Err\or: ${dir}put port $name is clocked by $clock_name rather than virtual_$clock_name"
#@                             }
#@                         }
#@                     }
#@                 }
#@             }
#@             if { $count(min) > 0 && $count(max) > 0 } {
#@                 if { $verbose } {
#@                     echo "${dir}put port $name has $count(max) max timing paths $tofrom it and $count(min) min timing paths"
#@                 }
#@                 set done 1
#@             }
#@         }
#@         
#@         # Unused inputs
#@ 
#@         if { (! $done) && ($dir == "in") } {
#@             set pins [filter_collection [all_connected [all_connected $port]] "object_class==pin"]
#@             if { $pins == {} } {
#@                 echo "Information: ${dir}put port $name is unused in block $currdes"
#@                 set done 1
#@             }
#@         }
#@         
#@         # Tiedoff or unconnected outputs
#@ 
#@         if { (! $done) && ($dir == "out") } {
#@             set pins [filter_collection [all_connected [all_connected $port]] "object_class==pin"]
#@             if { $pins == {} } {
#@                 echo "Warning: ${dir}put port $name is undriven by block $currdes"
#@                 incr bcount
#@                 set done 1
#@             } elseif { [sizeof_collection $pins] == 1 } {
#@                 suppressed DES-067 {set driving_cell [fast_all_fanin $pins -cells -dont_count_buffers]}
#@                 if { [sizeof_collection $driving_cell] == 1 } {
#@                     set driving_cell_type [get_attribute $driving_cell ref_name]
#@                     global tech_library_tieoff_cells
#@                     if { [lsearch $tech_library_tieoff_cells $driving_cell_type] != -1 } {
#@                         echo "Information: ${dir}put port $name is driven by a tieoff in block $currdes"
#@                         set done 1
#@                     }
#@                 }
#@             }
#@         }
#@         
#@         # ... otherwise it must be bad
#@ 
#@         if { ! $done } {
#@             foreach mm {max min} {
#@                 if { $count($mm) == 0 } {
#@                     echo "Warning: ${dir}put port $name has no $mm paths $tofrom it"
#@                     incr bcount
#@                     break
#@                 }
#@             }
#@         }
#@ 
#@     }
#@     
#@     echo "Info: Of $total ${dir}puts, $fcount were not checked due to filters ($filter) and $bcount had failures"
#@ }
#@ 
#@ proc check_inputs_are_constrained {{filter {}} {verbose 0}} {
#@     check_xxputs_are_constrained in $filter $verbose
#@ }
#@ 
#@ proc check_outputs_are_constrained {{filter {}} {verbose 0}} {
#@     check_xxputs_are_constrained out $filter $verbose
#@ }
#@ 
#@ # simple procedure to set case analysis on broadcom MIDLs to a required value
#@ proc set_midl_select8 { value delay_line {debug 0} } {
#@     echo "midl ${delay_line}, SELECT8 value = $value"
#@     set tmp $value
#@     set_case_analysis 0 [get_pins ${delay_line}/SELECT8[*]]
#@     for {set i 0} {$i < 9} {incr i} {
#@         set_case_analysis [expr $tmp % 2] [get_pins ${delay_line}/SELECT8[$i]]
#@         if { $debug } { echo "$value SELECT8 $i - " [expr $tmp % 2] }
#@         set tmp [expr $tmp / 2]
#@     }
#@ }    
#@ 
#@ proc map_vendor_pin_names {} {
#@     # i.e. for Broadcom
#@     uplevel {
#@         # Flops
#@         set phi    phi
#@         set d      d
#@         set q      q
#@         set setb   setb
#@         set resetb resetb
#@         # Simple buffer or inverter
#@         set i      i
#@         set o      o
#@         # Simple mux cell
#@         set sel    sel
#@         set i0     i0
#@         set i1     i1
#@         # CKMUX Cells
#@         set sel0   sel0
#@         set sel1   sel1
#@         set ck_out ck_out
#@         set ck0    ck0
#@         set ck1    ck1
#@         set ck2    ck2
#@         set ck3    ck3
#@         # AOI cells
#@         set i0_0   i0_0
#@         set i0_1   i0_1
#@         set i1_0   i1_0
#@         set i1_1   i1_1
#@     }
#@     # or for Avago libraries
#@     # uplevel {
#@     #     # Flops
#@     #     set phi    CK
#@     #     set d      D
#@     #     set q      Q
#@     #     set setb   PRE_N
#@     #     set resetb CLR_N
#@     #     # Simple buffer or inverter
#@     #     set i      A
#@     #     set o      Q
#@     #     # Simple mux cell
#@     #     set sel    SEL1
#@     #     set i0     D0
#@     #     set i1     D1
#@     #     # CKMUX Cells
#@     #     set sel0   S0
#@     #     set sel1   S1
#@     #     set ck_out CK_OUT
#@     #     set ck0    CK0
#@     #     set ck1    CK1
#@     #     set ck2    CK2
#@     #     set ck3    CK3
#@     #     # AOI cells
#@     #     set i0_0   A
#@     #     set i0_1   B
#@     #     set i1_0   C
#@     #     set i1_1   D
#@     # }
#@ }
#@ 
#@ # simple procedure to set case analysis on aldl (or aldlmindelay) to a required value
#@ proc set_aldl_therm { value delay_line_name } {
#@     global preflatten_netlist
#@ 
#@     echo "aldl ${delay_line_name}, coarse step setting = $value"
#@ 
#@     # We are passed in either a cell name for the aldl_structural or the aldl_structural_wrapper
#@     if { [exists_and_true preflatten_netlist] } {
#@         if { [string match {*wrapper*} [get_attribute [get_cells $delay_line_name] ref_name]] } {
#@             set delay_line_name [fixpaths ${delay_line_name}/U]
#@         }
#@     } else {
#@         if { [suppressed {UID-95 SEL-004 SEL-005} {sizeof_collection [get_cells $delay_line_name]}] == 0 } {
#@             set delay_line_name [fixpaths ${delay_line_name}/U]
#@         }
#@     }
#@     
#@     map_vendor_pin_names
#@ 
#@     if { [suppressed {UID-95 SEL-004 SEL-005} {sizeof_collection [get_cells [fixpaths ${delay_line_name}/*]]}] != 0 } {
#@         echo "\n*** Configuring GATE LEVEL MODEL of aldl\n"
#@         #set_case_analysis 1 [get_pins ${delay_line_name}/sel*]
#@         #set_case_analysis 0 [get_pins ${delay_line_name}/Z_sel*]
#@         set_disable_timing [get_cells [fixpaths ${delay_line_name}/U*/U1]] -from $i    -to $o -restore
#@         set_disable_timing [get_cells [fixpaths ${delay_line_name}/U*/U2]] -from $i0_0 -to $o -restore
#@         set_disable_timing [get_cells [fixpaths ${delay_line_name}/U*/U2]] -from $i1_0 -to $o -restore
#@         # These are the control paths into the mux. 
#@         set_disable_timing [get_cells [fixpaths ${delay_line_name}/U*/U2]] -from $i0_1 -to $o
#@         set_disable_timing [get_cells [fixpaths ${delay_line_name}/U*/U2]] -from $i1_1 -to $o
#@         
#@         set max_step [sizeof_collection [get_pins ${delay_line_name}/sel*]]    
#@         if { $value < 0 } {
#@             echo "Err\or: The delay step '$value' is smaller than the minimum supported (0)"
#@         } elseif { $value >  $max_step } {
#@             echo "Err\or: The delay step '$value' is greater than the maximum supported ($max_step)" 
#@         } else {
#@             for {set i 0} {$i < $value} {incr i} {
#@                 #set_case_analysis 0 [get_pins ${delay_line_name}/sel_$i]
#@                 #set_case_analysis 1 [get_pins ${delay_line_name}/Z_sel_$i]
#@                 echoed "  set_disable_timing \[get_cells [fixpaths ${delay_line_name}/U_$i/U2]\] -from $i0_0 -to $o"
#@             }
#@             echoed "  set_disable_timing \[get_cells [fixpaths ${delay_line_name}/U_$i/U2]\] -from $i1_0 -to $o"
#@         }
#@     } else {
#@         global running_primetime
#@         echoed "my_set_cell_mode DELAY$value $delay_line_name"
#@     }
#@ }    
#@ 
#@ proc analxtalk {path} {
#@     foreach_in_collection point [get_attribute $path points] {
#@         suppressed ATTR-3 {
#@              foreach attr {arrival
#@                            object
#@                            object_class
#@                            rise_fall
#@                            slack
#@                            transition
#@                            annotated_delay_delta
#@                            annotated_delta_transition
#@                            si_xtalk_bumps
#@                           } {
#@                 set $attr [get_attribute $point $attr]
#@              }
#@             puts "[get_object_name $object] $annotated_delay_delta"
#@             if { $annotated_delay_delta != {} } {
#@                 foreach bump $si_xtalk_bumps {
#@                     puts "    $bump"
#@                 }
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc index_into {val param} {
#@ 
#@     # Simple case ...
#@     
#@     if { [llength $val] == 1 } {
#@         return $val
#@     }
#@ 
#@     array unset info
#@     array set info $val
#@ 
#@     # Do we have analysis_type dependent values ?
#@ 
#@     global analysis_type
#@ 
#@     if { [regexp {(bc|bc_hot|wc|wc_cold)} $analysis_type an2] } {
#@         if { [info exists info($an2)] } {
#@             set val $info($an2)
#@             puts "      Info: '$param' being set to '$an2' value of '$val'"
#@             return [index_into $val $param]
#@         }
#@     }
#@     if { [regexp {(bc|wc)} $analysis_type an2] } {
#@         if { [info exists info($an2)] } {
#@             set val $info($an2)
#@             puts "      Info: '$param' being set to '$an2' value of '$val'"
#@             return [index_into $val $param]
#@         }
#@     }
#@    
#@     return $val          
#@ }
#@ 
#@ proc get_clock_param {clock_name param block_name {default none-specified}} {
#@     
#@     global clock_info
#@     array unset info
#@     array set info $clock_info($clock_name)
#@     
#@     if { [info exists info($param)] } {
#@         if { [llength $info($param)] == 1 } {
#@             set val $info($param)
#@             puts "    Info: Found simple '$param' value : '$val'"
#@         } else {
#@             array unset info2
#@             array set info2 $info($param)
#@             if { [info exists info2($block_name)] } {
#@                 set val $info2($block_name)
#@                 puts "    Info: Found block ($block_name) specific '$param' value: '$val'"
#@             } elseif { [info exists info2(default)] } {
#@                 set val $info2(default)
#@                 puts "    Info: Using clock default '$param' value : '$val'"
#@             }
#@         }
#@     }
#@     if { ! [info exists val] } {
#@         if { $default != {none-specified} } {
#@             set val $default
#@             puts "    Info: using global default '$param' value : '$val'"
#@         } else {
#@             echo "Err\or: No default specified for param '$param' for clock'$clock_name' in block '$block_name'"
#@             set val 0.0
#@         }
#@     }
#@     
#@     set val [index_into $val $param]
#@     
#@     return $val
#@     
#@ }
#@ 
#@ proc bcm_get_cells {args} {
#@     eval "get_cells [set args]"
#@ }
#@ 
#@ proc bcm_get_pins {args} {
#@     eval "get_pins [set args]"
#@ }
#@ 
#@ proc lvt_it {path} {
#@     global lvtlist
#@     foreach_in_collection point [get_attribute $path points] {
#@          foreach attr {object object_class} {
#@             set $attr [get_attribute $point $attr]
#@          }
#@          set cellname [dirname [get_object_name $object]]
#@          set cell [get_cell $cellname]
#@          set celltype [get_attribute $cell ref_name]
#@          if { [regsub {^G[SH](5?)_} $celltype {GL_} celltype2] } {
#@             set cmd "size_cell $cellname $celltype2"
#@             puts $cmd
#@             lappend lvtlist $cmd
#@          }
#@     }
#@ }
#@ 
#@ proc lvt_em {paths} {
#@     foreach_in_collection p $paths {
#@         lvt_it $p
#@     }
#@ }
#@ 
#@ proc skew_it_early {path} {
#@     
#@     global clkpins
#@     global lvtlist
#@ 
#@     foreach attr {startpoint slack} {
#@        set $attr [get_attribute $path $attr]
#@     }
#@     
#@     if { $slack > 0 } return
#@     
#@     set spname [get_object_name $startpoint]
#@     set spcellname [dirname $spname]
#@ 
#@     report_timing $path -nosplit > .skew_it_early.rpt
#@     
#@     set file [open .skew_it_early.rpt]
#@     set lines {}
#@     while {! [eof $file]} {
#@         gets $file line
#@         if { [regexp "/o " $line] } { lappend lines $line }
#@         if { [regexp "$spcellname/(phi|clk|ck)" $line clkpinname] } break
#@     }
#@     close $file
#@ 
#@     set num [expr floor($slack / -0.010 + 0.99)]
#@     if { $num > 2 } { set num 2 }
#@     # puts "Found clkpin $clkpinname $num"
#@     
#@     for { set i [expr [llength $lines]-1] } {$i >= 0} {set i [expr $i-1]} {
#@         set line [lindex $lines $i]
#@         if { [regexp {([^ ]*)/o \((.*)\)} $line dummy cellname celltype] } {
#@             if { [regsub {^G[SH](5?)_} $celltype {GL_} celltype2] } {
#@                 set cmd "size_cell $cellname $celltype2"
#@                 puts $cmd
#@                 lappend lvtlist $cmd
#@                 set num [expr $num -1]
#@                 if { $num <= 0 } break
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc skew_em_early {paths} {
#@     foreach_in_collection p $paths {
#@         skew_it_early $p
#@     }
#@ }
#@ 
#@ proc skew_it_late {path} {
#@     
#@     global clkpins
#@     global lvtlist
#@     
#@     foreach attr {endpoint slack} {
#@        set $attr [get_attribute $path $attr]
#@     }
#@     
#@     if { $slack > 0 } return
#@     
#@     set epname [get_object_name $endpoint]
#@     set epcellname [dirname $epname]
#@     
#@     report_timing $path -nosplit > .skew_it_late.rpt
#@     
#@     set file [open .skew_it_late.rpt]
#@     set lines {}
#@     while {! [eof $file]} {
#@         gets $file line
#@         if { [regexp "$epcellname/(phi|clk|ck_)" $line clkpinname] } {
#@             break
#@         }
#@     }
#@     close $file
#@     
#@     if { ! [info exists clkpins($clkpinname)] } {
#@         set clkpins($clkpinname) 0
#@     }
#@     
#@     set num [expr floor($slack / -0.030 + 0.99)]
#@     puts "Found clkpin $clkpinname $num"
#@     for {set i $clkpins($clkpinname)} {$i < $num} {incr i} {
#@         incr clkpins($clkpinname)
#@         set cmd "insert_buffer $clkpinname GS_BUFX8"
#@         puts $cmd
#@         lappend lvtlist $cmd
#@     }
#@     
#@ }
#@ 
#@ proc skew_em_late {paths} {
#@     foreach_in_collection p $paths {
#@         skew_it_late $p
#@     }
#@ }
#@ 
#@ set use_ilms 0
#@ 
#@ proc create_ilm_or_block_abstraction {} {
#@     global use_ilms
#@     global output_file_base
#@     global format
#@     array set block_info [get_block_info [get_object_name [current_design]]]
#@     if { $block_info(block_abstraction) } {
#@         if { $use_ilms } {
#@             create_ilm 
#@             #-keep_macros
#@             write -hierarchy -format $format -output $output_file_base.ilm.$format
#@         } else {
#@             create_block_abstraction
#@             #write -hierarchy -format $format -output $output_file_base.block_abs.$format
#@         }
#@     }
#@ }
#@ 
#@ proc load_ilms_or_block_abstractions {} {
#@     global use_ilms
#@     global format
#@     global chip_name
#@     global results_dir
#@     set design_name [get_object_name [current_design]]
#@     array set block_info [get_block_info $design_name]
#@ 
#@     foreach physical_subblock $block_info(physical_subblocks) {
#@         if {$use_ilms == 0} {
#@             set_top_implementation_options -block_references $physical_subblock -optimize_block_interface false -optimize_shared_logic false
#@             set filename $results_dir/${chip_name}_pcompile_${physical_subblock}.$format
#@         } else {
#@             set filename $results_dir/${chip_name}_pcompile_${physical_subblock}.ilm.$format
#@         }
#@         if {[file readable $filename]} {
#@             read_file -format $format $filename
#@             current_design $design_name
#@         } else {
#@             puts "Err\or - file $filename does not exist"
#@             exit
#@         }
#@     }
#@ }
#@ 
#@ proc do_name_changes {name_changes {fname_suffix name_changes}} {
#@ 
#@     global output_file_base
#@     set fname "$output_file_base-$fname_suffix.txt"
#@     set file [open $fname w]
#@     puts $file $name_changes
#@     close $file
#@     echoed "change_names -hierarchy -names_file $fname"
#@ 
#@ }
#@ 
#@ proc check_fixed_netnames {version {fix 0}} {
#@ 
#@     global preflatten_netlist
#@     global script_name
#@ 
#@     set top [get_object_name [current_design]]
#@     array set fixed_netnames [get_block_info $version fixed_netnames]
#@     set name_changes {}
#@ 
#@     foreach pinname [array names fixed_netnames] {
#@ 
#@         set cellname [dirname $pinname]
#@         if { $script_name == {elab} } {
#@             set expected [llast  $fixed_netnames($pinname)]
#@         } else {
#@             set expected [lfirst $fixed_netnames($pinname)]
#@         }
#@         if { ! [exists_and_true preflatten_netlist] } {
#@             regsub -all {/} $cellname {_} cellname
#@             set pinname $cellname/[file tail $pinname]
#@             regsub -all {/} $expected {_} expected
#@         }
#@         set actual   [get_object_name [all_connected [get_pins $pinname]]]
#@         
#@         if { $actual eq {} } {
#@             echo "Error: check_fixed_netnames - Pin '$pinname' not found or no net connected"
#@         } else {
#@             set msg "check_fixed_netnames - At pin '$pinname', Current net named '$actual', expected '$expected'"
#@             if { $fix } {
#@                 echo "Information: $msg"
#@                 if { $actual != $expected } {
#@                     if { [suppressed UID-95 {sizeof_collection [get_nets $expected]}] != 0 } {
#@                         echo "Error: check_fixed_netnames - net '$expected' already exists elsewhere"
#@                     } else {
#@                         # Change the net name
#@                         if { [dirname $expected] == {} } {
#@                             set design $top
#@                         } else {
#@                             set design [get_attribute [dirname $expected] ref_name]
#@                         }
#@                         append name_changes "$design net [file tail $actual] [file tail $expected]\n"
#@                     }
#@                     if { [get_attribute [get_nets $actual] is_bussed] } {
#@                         remove_bus [filename [get_attribute [get_nets $actual] bus_name]]
#@                     }
#@                 }
#@             } else {
#@                 if { $actual != $expected } {
#@                     echo "Error: $msg"
#@                 } else {
#@                     echo "Information: $msg"
#@                 }
#@             }
#@         }
#@     }
#@     if { $fix } {
#@         if { $name_changes ne {} } {
#@             do_name_changes $name_changes
#@             check_fixed_netnames $version
#@         } else {
#@             echo "Information: check_fixed_netnames - All fixed netnames are correct already"
#@         }
#@     }
#@ }
#@ 
#@ proc change_fixed_netnames {version} {
#@     check_fixed_netnames $version 1
#@ }
#@ 
#@ proc fix_syndir_naming_cell {} {
#@ 
#@     global preflatten_netlist
#@     global technology
#@     global tech_library
#@     global vt
#@     
#@     set design_name [get_object_name [current_design]]
#@     
#@     # Fix SYNDIR naming cell ##
#@ 
#@     set special_top_cell_blocks {q4chip xpl_serdes_x16}
#@     set cells [get_cells * -hier -filter "full_name=~*SYNDIR*U"]
#@ 
#@     suppressed {UID-95 SEL-005 UID-341 HDL-193 LBR-1 LINK-5} { 
#@ 
#@         set cellnames [get_object_name $cells]
#@         puts $cellnames
#@         set hacked_cellnames {}
#@     
#@         foreach cellname $cellnames {
#@         
#@             current_design $design_name
#@         
#@             if { [regexp {(.*)/(SYNDIR.*)} $cellname dummy parent_cellname refdes] } {
#@                 set parent_designname [get_attribute [get_cells $parent_cellname] ref_name]
#@             } else {
#@                 set parent_designname $design_name
#@                 set refdes $cellname
#@             }
#@             if { "$parent_designname / $refdes" in $hacked_cellnames } {
#@                 puts "Passing on '$parent_designname / $refdes'- already hacked"
#@                 continue
#@             }
#@         
#@             puts "Hacking syndir cell '$cellname' in '$parent_designname' / '$refdes'"
#@             current_design $parent_designname
#@ 
#@             lappend hacked_cellnames "$parent_designname / $refdes"
#@         
#@             set new_cell_refdes [filename [dirname [pwd]]]
#@             regsub -all {[\.]} $new_cell_refdes {_} new_cell_refdes
#@             set new_cell_refdes ${new_cell_refdes}
#@             set top [current_design]
#@ 
#@             if { ! [exists_and_true preflatten_netlist] } {
#@     
#@                 set old_cell_refdes $refdes
#@               # set new_cell_refdes "AVAGOTECH_REV_TAG_$new_cell_refdes"
#@                 set new_cell_refdes "BROADCOM_REV_TAG_$new_cell_refdes"
#@     
#@             } else {
#@ 
#@                 set syndir_cell [get_cells SYNDIR]
#@                 set syndir_design [get_attribute $syndir_cell ref_name]
#@                 current_design $syndir_design
#@                 set old_cell_refdes U
#@ 
#@             }
#@ 
#@             if { [string match AV16* $technology] } {
#@                set i "A"
#@                set o "Q"
#@             } else {
#@                set i "i"
#@                set o "o"
#@             }
#@     
#@             foreach pin [list $i $o] {
#@                 set nets($pin) [get_nets -of_object [get_pins $old_cell_refdes/$pin]]
#@                 disconnect_net $nets($pin) [get_pins $old_cell_refdes/$pin]
#@             }
#@             remove_cell $old_cell_refdes
#@ 
#@             puts "Creating buffer for $technology"
#@             if {[string match TSMC7FF $technology]} {
#@                    echoed "create_cell $new_cell_refdes $tech_library/P6L8B_BUFX2"
#@             } elseif {[string match TSMC5FF $technology]} {
#@                     #SPONG_5NM: Correct this for 5nm library
#@                    echoed "create_cell $new_cell_refdes $tech_library/5NM_BUFX2_CELLTYPE"
#@             } elseif {[string match TSMC3FF $technology]} {
#@                    echoed "create_cell $new_cell_refdes $tech_library/E1ENRA_BUFX2"
#@             } elseif {[string match AV16* $technology]} {
#@                    if { $parent_designname in $special_top_cell_blocks } {
#@                        echoed "create_cell $new_cell_refdes $tech_library/a16lvt16_toprptrm2_a4"
#@                    } else {
#@                        echoed "create_cell $new_cell_refdes $tech_library/a16${vt}16_buf_a1"
#@                    }
#@             } elseif {[string match TSMC65LP* $technology]} {
#@                 if {[string match TSMC65LP14 $technology]} {
#@                    create_cell $new_cell_refdes tsmc65lp14_108125/LP14L_BUFX1
#@                 } elseif {[string match TSMC65LP16 $technology]} {
#@                    create_cell $new_cell_refdes tsmc65lp16_108125/LP16L_BUFX2
#@                 } else {
#@                    create_cell $new_cell_refdes tsmc65lp_108125/LPL_BUFX2
#@                 }
#@             } elseif {[string match TSMC40G $technology]} {
#@                    create_cell $new_cell_refdes tsmc40g_sc10t090v_ss090125/GH_BUFX2
#@             } else {
#@                 puts ".. or not. Technology $technology not known"
#@             }
#@ 
#@             foreach pin [list $i $o] {
#@                 connect_net $nets($pin) [get_pins $new_cell_refdes/$pin]
#@             }
#@ 
#@             set_dont_touch [get_cells $new_cell_refdes]
#@                        
#@             # tidy up
#@             unset nets
#@             current_design $top
#@             # Fix SYNDIR naming cell - end ## close both "suppressed" and "if" above
#@         }
#@     }
#@ 
#@     current_design $design_name
#@     link
#@ }
#@ 
#@ proc get_all_ram_cells {{pattern *}} {
#@     global all_ram_cell_names_cache
#@     set des [get_object_name [current_design]]
#@     if { [info exists all_ram_cell_names_cache($des)] } {
#@         set ram_cells [get_cells $all_ram_cell_names_cache($des)]
#@     } else {
#@         set ram_cells [get_cells * -hier -filter "(@ref_name=~M3SP111* || @ref_name=~M3PSP111* || @ref_name=~M3PD211* || @ref_name=~M3SRF211* ) && @is_hierarchical==FALSE"]
#@         set all_ram_cell_names_cache($des) [get_object_name $ram_cells]
#@     }
#@     return [filter_collection $ram_cells "@full_name=~$pattern"]
#@ }
#@ 
#@ proc change_names_of_clashing_cells {} {
#@ 
#@     global null
#@     global output_file_base
#@ 
#@     # The nwest verilog contains regs called both <xyz> and a delayed version <xyz>_reg. The cell/instance/register driving <xyz> is named <xyz>_reg by dcs 
#@     # and that clashes with the latter net/port. "change_names" finds it very difficult to fix these apparently.
#@     
#@     set des [current_design]
#@     
#@     # Find nets that _might_ have this problem
#@     
#@     set nets [get_nets *_reg -hier -filter "@name=~*reg"]
#@     
#@     # Find the (unique) designs that contain those nets
#@     
#@     set designs {}
#@     foreach_in_collection n $nets {
#@         set c [dirname [get_object_name $n]]
#@         if { $c eq {} } {
#@             append_to_collection designs [current_design]
#@         } else {
#@             append_to_collection -unique designs [get_designs [get_attribute [get_cells $c] ref_name]]
#@         }
#@     }
#@     
#@     # Then find the cells whose names match those nets, and generate a unique new cell name
#@     
#@     redirect -tee ${output_file_base}-chnames.txt {
#@         foreach_in_collection d $designs {
#@             set name [get_object_name $d]
#@             current_design $d > $null
#@             set nets [get_nets  *_reg -filter "@name=~*reg"]
#@             foreach_in_collection net $nets {
#@                 set cell [get_cells -quiet [get_object_name $net]]
#@                 if { [sc $cell] > 0 } {
#@                     set old [get_object_name $cell]
#@                     set new ${old}_inst
#@                     while { [sizeof_collection [get_cells -quiet $new]] > 0 || [sizeof_collection [get_nets -quiet $new]] > 0 } {
#@                         set new ${new}_inst
#@                     }
#@                     puts "$name cell $old $new"
#@                 }
#@             }
#@         }
#@     }
#@     
#@     # And change the names
#@     
#@     current_design $des
#@     change_names -hier -names_file ${output_file_base}-chnames.txt -verbose
#@ }
#@ 
#@ # End q2useful.tcl
#@ # -- End source q2useful.tcl

#@ source2 q6_avago.tcl
#@ # -- Starting source q6_avago.tcl

#@ 
#@ proc get_avago_test_ports_to_set_high { {prefix {}} } {
#@ 
#@     set port_list [list TEST__TDR_RST TEST__CLK_CONTROL_RESET]
#@ 
#@     set ret ""
#@     foreach port $port_list {
#@         lappend ret ${prefix}${port}
#@     }
#@     return $ret
#@ }
#@ 
#@ proc create_avago_sbus_ctrl_clock { sbus_ctrl_clock } {
#@ 
#@     puts "create_avago_sbus_ctrl_clock:"
#@ 
#@     # Q4 generated source is:            L/LCP40G/regs/slow_clock_reg_1/Q 
#@     # Q4 master clock source pin is:    [get_ports LCPREFCLKP]
#@     
#@     # But in fact q4 has a data driven method of creating generated clocks, so I haven't used this routine at all ...
#@ 
#@     # Does the clock already exist
#@     
#@     suppressed {SEl-004 SEL-005} { 
#@         set sbus_ctrl_clock [get_clocks $sbus_ctrl_clock]
#@     }
#@     
#@     if { [sizeof_collection $sbus_ctrl_clock] == 0 } {
#@         
#@         # Gayvins recipe (16/10/15 email)
#@         #
#@         # create_clock -period $period -waveform [list 0 [expr $period/2]] -name refclk [get_ports CHIP_REFCLK_PIN_P]
#@         # set_clock_transition -rise <board_level_rise_time> [get_clocks refclk]
#@         # set_clock_transition -fall <board_level_fall_time> [get_clocks refclk]
#@         # set_clock_uncertainty -setup <value> [get_clocks refclk]
#@         # set_clock_uncertainty -hold <value> [get_clocks refclk]
#@         # set_propagated_clock [get_clock refclk]
#@         
#@         puts "Err\or: create_avago_sbus_ctrl_clock - routine not implemented"
#@         
#@     }
#@ 
#@     # Any constraints relative to sbus_ctrl_clk
#@     
#@ }
#@ 
#@ proc create_all_avago_sbus_clocks {sbus_ctrl_clock_or_period sbus_clock_divider} {
#@ 
#@     puts "create_all_avago_sbus_clocks:"
#@ 
#@     set sbus_master_celltype sd03sbus_master_01
#@ 
#@     if { [regexp {^([0-9\.]*)$} $sbus_ctrl_clock_or_period] } {
#@         set scc_period $sbus_ctrl_clock_or_period
#@     } else {
#@         set scc_period [get_attribute [get_clocks $sbus_ctrl_clock_or_period] period]
#@     }
#@ 
#@     set x 0
#@     set cells [get_cells -hier * -filter "ref_name == $sbus_master_celltype"]
#@     proc mycmp {a b} {
#@       # if { [set c [string compare [regexp ^P_ $a] [regexp ^P_ $b]]] } { return $c }
#@         return [string compare $a $b]
#@     }
#@     foreach sbm [lsort -command mycmp [get_object_name $cells]] {
#@ 
#@         set sbm [get_cells $sbm]
#@         set cellname [get_object_name $sbm]
#@         if { [llength $sbus_clock_divider] == 1 } {
#@             set my_divider $sbus_clock_divider
#@         } else {
#@             set my_divider [lfirst $sbus_clock_divider]
#@             set sbus_clock_divider [lreplace $sbus_clock_divider 0 0]
#@         }
#@     
#@         # This is Avagos recipe (GS email: 16/10/15)
#@     
#@         echoed "create_clock -period [expr $scc_period*$my_divider] -waveform \{0 [expr $scc_period * ( $my_divider / 2 )] \} -name sbus_clock_$x \[get_pins $cellname/sbus_clk\]"
#@       # set_annotated_transition -rise 0.200 [get_pins {path_to_sbus_controller/instance_name/sbus_clk}]
#@       # set_annotated_transition -fall 0.050 [get_pins {path_to_sbus_controller/instance_name/sbus_clk}]
#@         echoed "  set_clock_uncertainty -setup 0.110 \[get_clocks sbus_clock_$x\]"
#@         echoed "  set_clock_uncertainty -hold  0.040 \[get_clocks sbus_clock_$x\]"
#@         echoed "  set_propagated_clock \[get_clock sbus_clock_$x\]"
#@ 
#@         #if { [get_pins $cellname/rom_rclk] != {} } {
#@         #    echoed "  set_clock_uncertainty -setup 0.110 \[get_clocks $cellname/rom_rclk\]"
#@         #    echoed "  set_clock_uncertainty -hold  0.040 \[get_clocks $cellname/rom_rclk\]"
#@         #  # echoed "  set_propagated_clock \[get_clock $cellname/rom_rclk\]"
#@         #}
#@         
#@         global running_primetime
#@         if { [exists_and_true running_primetime] } {
#@             # This is a variation on Lori's Milehigh top level timing skew constraint
#@           # set to_sbm_async_skew -5.0
#@             set to_sbm_async_skew  0.0
#@             set_false_path -from [get_clocks lcpref_clock] -to [get_clocks sbus_clock_$x]
#@             foreach_in_collection p [remove_from_collection [get_pins "$cellname/core_sbus_command* $cellname/core_sbus_data* $cellname/core_sbus_receiver_address*"]  \
#@                                                             [get_pins "$cellname/core_sbus_data_out*"]] {
#@                 set_data_check -setup -from [get_pins $cellname/core_sbus_execute] -to $p $to_sbm_async_skew
#@             }
#@         }
#@         incr x
#@     }
#@ 
#@     ## sbus_reset_in signal is asynchronous into all IP.
#@ 
#@     foreach_in_collection sbus_reset_in_pin [get_pins -hier */sbus_reset_in] {
#@         set ref_name [get_attribute [get_cells -of_objects $sbus_reset_in_pin] ref_name]
#@         if { ! [regexp sd16sbus_master_.* $ref_name] } {
#@             echoed "set_false_path -through \[get_pins [get_object_name $sbus_reset_in_pin]\]"
#@         }
#@     }
#@     
#@     # And the sbus master core_sbus_xxx signals are actually async into here. We can constrain with an MCP
#@     
#@     foreach_in_collection sbm [get_cells -hier * -filter "ref_name == $sbus_master_celltype"] {
#@         set cellname [get_object_name $sbm]
#@         foreach pin {core_sbus_command core_sbus_data_address core_sbus_data core_sbus_receiver_address core_sbus_execute} {
#@             echoed "  set_multicycle_path 5 -start -from lcpref_clock -to \[get_pins $cellname/$pin\]"
#@             echoed "  set_multicycle_path 5 -hold  -from lcpref_clock -to \[get_pins $cellname/$pin\]"
#@         }
#@     }
#@     
#@     # And the sbus master ring signals are timed off spico clock which is fast but they are actually all MCP - SPONG HOW MUCH ?
#@     
#@     foreach_in_collection sbmc [get_cells -hier * -filter "ref_name == $sbus_master_celltype"] {
#@         set sbm [get_object_name $sbmc]
#@         #foreach pin {o_sbm_ring_out*} {
#@         #    echoed "  set_multicycle_path 4 -start -through \[get_pins $sbm/$pin\]"
#@         #    echoed "  set_multicycle_path 4 -hold  -through \[get_pins $sbm/$pin\]"
#@         #}
#@         # In fact this is Glenn's approach
#@         echoed "set_disable_timing -from spico_clk -to i_sbm_ring_in_vld   \[get_cells $sbm\]"  ; #MJN check in test runs, async signal
#@         echoed "set_disable_timing -from spico_clk -to i_sbm_ring_out_ack  \[get_cells $sbm\]"  ; #MJN check in test runs, async signal
#@         for { set i 0 } { $i <= 13 } { incr i } {
#@             echoed "set_disable_timing -from spico_clk -to i_sbm_ring_in[$i] \[get_cells $sbm\]"  ; #MJN check in test runs, async signal
#@         }
#@         # And Glenn has separate skew constraint (which are actually quite tight). We'll not bother reproducing those here.
#@ 
#@         #set to_sbm_async_skew -5.0 ; # sbus_clock is running at 200 MHz ... this is one clock period but the vld uses more than one clock to process prior to data capture
#@         #set from_sbm_async_skew -2.0 ; # the core capture clock is running at 1 GHz ... this is two clock periods and the customer is using a xsync to capture the rcv_data_valid
#@         #for { set i 0 } { $i < 32 } { incr i } {
#@         #    lappend core_sbus_data_out_endpoint_list(M_TC_U_sbmstr_U_sbus_master_U)  L/LCP40G_regs_SBUS_SYNC_1_0_outp_reg_${i}/D
#@         #    ... etc.
#@         #}
#@         #foreach current_core_sbus_data_out_endpoint [set core_sbus_data_out_endpoint_list($sbm)] {
#@         #    set_data_check -setup -from [get_pins [set core_sbus_rcv_data_valid_path_endpoint($sbm)]] -to [get_pins $current_core_sbus_data_out_endpoint] $from_sbm_async_skew
#@         #}
#@         #foreach current_core_sbus_result_code_endpoint [set core_sbus_result_code_endpoint_list($sbm)] {
#@         #   set_data_check -setup -from [get_pins [set core_sbus_rcv_data_valid_path_endpoint($sbm)]] -to [get_pins $current_core_sbus_result_code_endpoint] $from_sbm_async_skew
#@         #}
#@         #for { set i 0 } { $i <= 13 } { incr i } {
#@         #    set_data_check -setup -from [get_pins ${sbm}/i_sbm_ring_in_vld] -to [get_pins ${sbm}/i_sbm_ring_in[$i] ] $to_sbm_async_skew
#@         #}
#@         #for { set i 0 } { $i <= 7 } { incr i } {
#@         #   set_data_check -setup -from [get_pins ${sbm}/core_sbus_execute] -to [get_pins ${sbm}/core_sbus_command[$i] ] $to_sbm_async_skew
#@         #   set_data_check -setup -from [get_pins ${sbm}/core_sbus_execute] -to [get_pins ${sbm}/core_sbus_data_address[$i] ] $to_sbm_async_skew
#@         #   set_data_check -setup -from [get_pins ${sbm}/core_sbus_execute] -to [get_pins ${sbm}/core_sbus_receiver_address[$i] ] $to_sbm_async_skew
#@         #}
#@         #for { set i 0 } { $i <= 31 } { incr i } {
#@         #    set_data_check -setup -from [get_pins ${sbm}/core_sbus_execute] -to [get_pins ${sbm}/core_sbus_data[$i] ] $to_sbm_async_skew
#@         #}
#@         
#@         # And Glenn had these two too
#@         echoed "set_multicycle_path 2 -setup -thr \[get_pins ${sbm}/i_rom_data\[*\]\]"
#@         echoed "set_multicycle_path 1 -hold  -thr \[get_pins ${sbm}/i_rom_data\[*\]\]"
#@         
#@         # These from Ben on E4
#@         # Strictly ony 0 (MISCWRAP_USBMSTR_0_U_sbus_master_U) is connected to the fuse block
#@         echoed "set_multicycle_path 2 -setup -thr \[get_pins ${sbm}/FUSE_SBUS_DATA_SEL\[*\]\]"
#@         echoed "set_multicycle_path 1 -hold  -thr \[get_pins ${sbm}/FUSE_SBUS_DATA_SEL\[*\]\]"
#@     }
#@     
#@ }
#@ 
#@ proc disable_avago_clock_control_test_clock_paths {} {
#@ 
#@     # SPONG: 3NM
#@     foreach_in_collection ccx [get_cells -hier * -filter "ref_name == ds07p_clock_control1_01"] {
#@         set cellname [get_object_name $ccx]
#@         foreach pinpair { {EXT_CLK CLK_OUT} {TEST__SHIFT_CLK CLK_OUT}} {
#@             echoed "  set_disable_timing -from [lfirst $pinpair] -to [llast $pinpair] \[get_cells $cellname\]"
#@         }
#@     }
#@ 
#@ }
#@ 
#@ #############################################################
#@ #
#@ # HBM PHY Setup
#@ #
#@ 
#@ proc setup_hbm_phy {mode doit} {
#@     uplevel "set mode $mode"
#@     uplevel "set doit $doit"
#@     uplevel {
#@         set phy [fixpath DMFE*/PHY/U_hbm/U]
#@         set dfi "$phy/C*_DFI"
#@         # set dfi {Q_DMFEA_PHY_U_hbm_U/C0_DFI_*DATA_?0[0]}
#@         set _inps  "\[get_pins ${dfi}* -filter \"@direction==in\  && full_name!~*DFI_CLK*\"\]"
#@         set _outps "\[get_pins ${dfi}* -filter \"@direction==out\ && full_name!~*DFI_CLK*\"\]"
#@     
#@         if { $mode == {hbm_fifo_enabled} } {
#@             set cell_mode fifo_enabled_mode
#@             set hbm_fifo  "reset_path    "
#@             set dmfe_fifo "set_false_path "
#@         } elseif { $mode == {dmfe_core_fifo_enabled} } {
#@             set cell_mode fifo_disabled_mode
#@             set hbm_fifo  "set_false_path"
#@             set dmfe_fifo "reset_path     "
#@         } else {
#@             puts "Err\or: usage: setup_dmfe_phy (hbm_fifo_enabled|dmfe_core_fifo_enabled)"
#@             return
#@         }
#@         set cmd "
#@                 set_cell_mode $cell_mode  \[get_cells $phy\]
#@                 set inps  $_inps
#@                 set outps $_outps
#@                "
#@         append cmd "
#@                 set_multicycle_path 10 -setup -from \[get_cells [fixpath "DMFE*/CORE/NWCTRLR_*/PHYFIFO/CTRL2PHY*/enable_fifo_div2_reg"]\]
#@                 set_multicycle_path  9  -hold -from \[get_cells [fixpath "DMFE*/CORE/NWCTRLR_*/PHYFIFO/CTRL2PHY*/enable_fifo_div2_reg"]\]
#@                 "
#@         # set false paths for ($mode == {hbm_fifo_enabled})
#@         append cmd "
#@                 $dmfe_fifo -from \[get_clocks DMFE*CLK_OUT*\]                                -through \$inps
#@                 $dmfe_fifo                                  -to \[get_clocks dram_div2_*\]   -through \$inps
#@                 $dmfe_fifo                                  -to \[get_clocks DMFE*CLK_OUT*\] -through \$outps
#@                 "
#@         # set false paths for ($mode == {dmfe_core_fifo_enabled})
#@         append cmd "
#@                 $hbm_fifo  -from \[get_clocks dram_div2_*\]                                 -through \$inps
#@                 $hbm_fifo                                   -to \[get_clocks DMFE*CLK_IN*\] -through \$inps
#@                 $hbm_fifo                                   -to \[get_clocks dram_div2_*\]  -through \$outps
#@                 "
#@         if { $doit } {
#@             echoed $cmd
#@         } else {
#@             puts $cmd
#@         }
#@         puts "
#@                 rt -through \$inps  -delay max_rise
#@                 rt -through \$inps  -delay min_rise
#@                 rt -through \$outps -delay max_rise
#@                 rt -through \$outps -delay min_rise
#@         "
#@     }
#@ }
#@ 
#@ #############################################################
#@ #
#@ # Legacy Q4 routines, not used by Q5
#@ #
#@ 
#@ proc XXX_disable_avago_resynchroniser_si_paths {} {
#@ 
#@     suppressed {SEL-003 SEL-004 SEL-005} {
#@         set cells [sort_collection -dictionary [get_cells * -hier -filter "@ref_name=~a16*vt16_*x*sync*dff* && @is_hierarchical==FALSE"] full_name]
#@     
#@         foreach cellpath [get_object_name $cells] {
#@             set_disable_timing -from CK -to SI $cellpath
#@         }
#@     }
#@ }
#@ 
#@ proc XXX_disable_memoir_power_gating_paths {} {
#@     set cells [get_cells * -hier -filter "@ref_name=~RR16FFGL* && @is_hierarchical==FALSE"]
#@     foreach_in_collection cell $cells {
#@         foreach power_gating_mode {DS LS SD} {
#@             set power_gating_mode_pin [suppressed {UID-95 SEL-004 SEL-005} {get_pins [get_object_name $cell]/$power_gating_mode}]
#@             if { [sizeof_collection $power_gating_mode_pin] } {
#@                 set_multicycle_path 5 -setup -through $power_gating_mode_pin
#@                 set_multicycle_path 4 -hold  -through $power_gating_mode_pin
#@             }
#@         }
#@     }
#@ }
#@ 
#@ proc XXX_disable_avago_tap_test_outputs_etc { {tap tap_inst} {sbus_master P_SBUS_MASTER_0_U_sbus_master_U} {mem_master P_MEMMASTER_U_memmaster_U} } {
#@ 
#@     echoed {
#@     
#@         ########################
#@         # Disable test paths
#@         ########################
#@ 
#@         set_case_analysis 0 [get_pins $tap/TEST__SCAN_EN]
#@         set_case_analysis 0 [get_pins $tap/TEST__SHIFT_CLK*]
#@         set_case_analysis 0 [get_pins $tap/TEST__CLK_GATE_DISABLE*]
#@         set_case_analysis 0 [get_pins $tap/TEST__DOM_SCAN]
#@         set_case_analysis 0 [get_pins $tap/TEST__CLOCK_DR]
#@         set_case_analysis 0 [get_pins $tap/TEST__UPDATE_DR]
#@         set_case_analysis 0 [get_pins $tap/TEST__TCK]
#@         set_case_analysis 0 [get_pins $tap/TEST__TMS]
#@         set_case_analysis 0 [get_pins $tap/TEST__CORE_TDI]
#@         set_case_analysis 0 [get_pins $tap/TEST__RTSTMODE*]
#@         set_case_analysis 0 [get_pins $tap/TEST__DTSTMODE*]
#@ 
#@         ## GEL added Feb 29, 2016 PN99_1 netlist
#@         set_case_analysis 0 [get_pins $tap/TEST__ASYNC_DISABLE]
#@ 
#@         ## GEL added June 14, 2016 the TEST__TDO path through this sbus_master is invalid and not used
#@         set_disable_timing -from spico_clk -to TEST__TDO [get_cells $sbus_master]
#@ 
#@         ## GEL added June 23, 2016 to eliminate CDC run paths that are not valid because this chip does not use this functionality
#@         set_disable_timing -from spico_clk -to TEST__SBUS_TDI [get_cells $sbus_master]
#@ 
#@         ## GEL added June 24, 2016 to eliminate CDC run paths that are not valid because this chip does not use this functionality
#@         set_disable_timing -from spico_clk -to TEST__SBUS_TAP_CTRL_L [get_cells $sbus_master]
#@ 
#@         # false path scan only paths
#@         set_false_path -th [get_pins */DFT_lockup*/*]
#@         set_false_path -th [get_pins */ts_*_lockup_latch*/d]
#@ 
#@         if {[sizeof_collection [get_pins -hier -quiet *_Q_MUXD_LOCKUP]] > 0} {
#@             set_false_path -th [get_pins *_Q_MUXD_LOCKUP/D]                           ;# MJN remove "if" once test insert stable
#@         }
#@ 
#@         set_false_path -th [get_pins */TEST__SIN*]
#@         set_false_path -th [get_pins */*/TEST__SIN*]
#@         set_false_path -th [get_pins */*/TEST__JSIN*]
#@         set_false_path -th [get_pins */*/TEST__SOUT_PAR]
#@         set_false_path -th [get_pins */*/TEST__SIN_PAR]
#@         set_false_path -setup -through [get_pins -hier */SI]
#@         set_false_path -setup -through [get_pins -hier *TEST__SOUT*]
#@ 
#@         # and
#@ 
#@         set_case_analysis 0 [get_pins $tap/TEST__LBIST_ACTIVE*]
#@ 
#@         set_multicycle_path 2 -setup -from [get_clocks tap_dft_clock] -thr [get_pins $mem_master/REDN_CLK_SEL] -to [get_clocks tap_dft_clock]
#@         set_multicycle_path 2 -hold  -from [get_clocks tap_dft_clock] -thr [get_pins $mem_master/REDN_CLK_SEL] -to [get_clocks tap_dft_clock]
#@ 
#@     }
#@ }
#@ 
#@ proc XXX_disable_avago_hstl_buffer_test_paths { {se_mode false} {diff_mode true} } {
#@ 
#@ 
#@     # All this from Glenn's email of 9/7/2016
#@     
#@     foreach_in_collection current_pad16_HSTLsdio_tran15_0 [get_cells -hier -filter "ref_name==pad16_HSTLsdio_tran15_0"] {
#@ 
#@       set_disable_timing -from p_tripad_internal   -to PAD [get_cells $current_pad16_HSTLsdio_tran15_0 ]
#@       set_disable_timing -from p_tripad_n_internal -to PAD [get_cells $current_pad16_HSTLsdio_tran15_0 ]
#@ 
#@       set_disable_timing -from n_tripad_internal   -to PAD_N [get_cells $current_pad16_HSTLsdio_tran15_0 ]
#@       set_disable_timing -from n_tripad_n_internal -to PAD_N [get_cells $current_pad16_HSTLsdio_tran15_0 ]
#@ 
#@       set_disable_timing -from TEST__CLOCK_DR -to DIFF_DRV_DATA [get_cells $current_pad16_HSTLsdio_tran15_0]
#@ 
#@ 
#@       if { ! bool($se_mode) } {
#@         set_disable_timing -from ENABLE_SE                -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@         set_disable_timing -from N_SE_DRV_DATA            -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@  
#@         set_disable_timing -from ENABLE_SE                -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@         set_disable_timing -from N_SE_DRV_DATA            -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@ 
#@         set_disable_timing -from ENABLE_SE                -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@         set_disable_timing -from P_SE_DRV_DATA            -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@ 
#@         set_disable_timing -from ENABLE_SE                -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@         set_disable_timing -from P_SE_DRV_DATA            -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       }
#@ 
#@        
#@       if { ! bool($diff_mode) } {
#@         #HB: Add any paths to be disabled if diff_mode is NOT used. Get Avago's approval!!
#@       }
#@ 
#@       set_disable_timing -from TEST__DTSTMODE           -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE          -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE_OVERRIDE -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__PAR_SCAN           -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__UPDATE_DR          -to n_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@ 
#@       set_disable_timing -from TEST__DTSTMODE           -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE          -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE_OVERRIDE -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__PAR_SCAN           -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__UPDATE_DR          -to n_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@ 
#@       set_disable_timing -from TEST__DTSTMODE           -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE          -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE_OVERRIDE -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__PAR_SCAN           -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__UPDATE_DR          -to p_m_drv_data_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@ 
#@       set_disable_timing -from TEST__DTSTMODE           -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE          -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__ENABLE_SE_OVERRIDE -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__PAR_SCAN           -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       set_disable_timing -from TEST__UPDATE_DR          -to p_m_drv_data_n_internal [get_cells $current_pad16_HSTLsdio_tran15_0]
#@       
#@     }
#@ }
#@ 
#@ proc XXX_create_avago_rx_launch_clock {launch_clock_name serdes_rx_clock baud_rate_multiplier  phase_shift_bauds} {
#@ 
#@     # Largely extracted from "16 nm CM4 SerDes Timing Model, Version 1.0"
#@     
#@     set serdes_rx_clock [get_clocks $serdes_rx_clock]
#@     set period          [get_attribute $serdes_rx_clock period]
#@     set baud_period     [expr $period / $baud_rate_multiplier]
#@     
#@     set latency         [expr $phase_shift_bauds * $baud_period ]
#@ 
#@     set source_pin [get_attribute $serdes_rx_clock sources]
#@     if { [sizeof_collection $source_pin] != 1 } {
#@         puts "Err\or: create_avago_rx_launch_clock, reference clock has multiple sources"
#@         return
#@     }
#@     if { ! [regexp {^(.*)/(rx_.*_fifo_clk.*)$} [get_object_name $source_pin] {} source_cellname source_pinname] } {
#@         puts "Err\or: create_avago_rx_launch_clock, reference clock source error"
#@         puts "Err\or: create the serdes rx clock on the serdes internal pin /rx_f??_fifo_clk???"
#@         return
#@     }
#@     regsub {_fifo_} $source_pinname {_var_} source_pinname
#@     
#@     echoed "create_clock $source_cellname/$source_pinname -name $launch_clock_name -period $period"
#@ 
#@     set_clock_uncertainty  0.1 [get_clocks $launch_clock_name]
#@     
#@     echoed "  set_clock_transition  0.1          \[get_clocks $launch_clock_name\]"
#@ 
#@     echoed "  set_clock_latency -source $latency \[get_clocks $launch_clock_name\]"
#@     echoed "  set_clock_uncertainty 0.250 -hold -from  \[get_clocks $launch_clock_name\] -to \[get_clocks [get_object_name $serdes_rx_clock]\]"
#@     
#@ }
#@ 
#@ proc XXX_create_avago_phase_beacon_clocks {base_name phase_beacon_cell master_clock baud_rate_multiplier edge {master_clock_source_pin {}} {uncertainties {0.450 0.450}} } {
#@ 
#@     proc echoed2 {cmd} {
#@         regsub -all { +} $cmd { } cmd
#@         puts $cmd
#@         eval $cmd
#@     }
#@ 
#@     set master_clock [get_clocks $master_clock]
#@     set master_clock_str "\[get_clocks [get_object_name $master_clock]\]"
#@ 
#@     if { "$master_clock_source_pin" == {} } {
#@         set master_clock_source_pin [get_attribute $master_clock sources]
#@         if { [sizeof_collection $master_clock_source_pin] != 1 } {
#@             puts "Err\or: create_avago_phase_beacon_clocks, master_clock has multiple sources"
#@             return
#@         }
#@     } else {
#@         set master_clock_source_pin [get_pins $master_clock_source_pin]
#@     }
#@     set master_clock_source_pin_str "\[get_pins [get_object_name $master_clock_source_pin]\]"
#@         
#@     set pb_cellname [get_object_name [get_cells $phase_beacon_cell]]
#@     set f2_clk_src_pin_str "\[get_pins $pb_cellname/CK\]"
#@     set pb_clk_src_pin_str "\[get_pins $pb_cellname/Q\]"
#@     
#@     # This ia avago's reccomended recipe - from CM4 Serdes Timing Model document
#@     set baud_rate_multiplier_div2 [expr $baud_rate_multiplier/2]
#@ 
#@     echoed2 "create_generated_clock -add -name ${base_name}_f2_clock    \
#@             -source $master_clock_source_pin_str                        \
#@             -master_clock $master_clock_str                             \
#@             -multiply_by $baud_rate_multiplier_div2                                          \
#@             $f2_clk_src_pin_str"
#@     
#@     set e $edge
#@     echoed2 "create_generated_clock -add -name ${base_name}_early_clock \
#@             -source $f2_clk_src_pin_str                                 \
#@             -master_clock \[get_clocks ${base_name}_f2_clock\]          \
#@             -edges \{ $e [expr $e+$baud_rate_multiplier_div2] [expr $e+$baud_rate_multiplier] \}                   \
#@             $pb_clk_src_pin_str"
#@             
#@     set e [expr $edge + 2]
#@     echoed2 "create_generated_clock -add -name ${base_name}_late_clock  \
#@             -source $f2_clk_src_pin_str                                 \
#@             -master_clock \[get_clocks ${base_name}_f2_clock\]          \
#@             -edges \{ $e [expr $e+$baud_rate_multiplier_div2] [expr $e+$baud_rate_multiplier] \}                   \
#@             $pb_clk_src_pin_str"
#@             
#@     set my_clocks_str "\[get_clocks \{${base_name}_early_clock ${base_name}_late_clock\}\]"
#@     echoed2 "  set_clock_uncertainty [lfirst $uncertainties] -setup -from $master_clock_str -to $my_clocks_str"
#@     echoed2 "  set_clock_uncertainty [llast  $uncertainties] -hold  -from $master_clock_str -to $my_clocks_str"
#@     
#@     # Elway additions
#@     
#@     set f2_clock_str "\[get_clocks ${base_name}_f2_clock\]"
#@     
#@     echoed2 "  set_clock_transition  0.080              $f2_clock_str"
#@     echoed2 "  set_multicycle_path   $baud_rate_multiplier_div2           -end -setup -to $f2_clock_str"
#@     echoed2 "  set_multicycle_path   [expr $baud_rate_multiplier_div2 -1] -end -hold  -to $f2_clock_str"
#@     echoed2 "  set_clock_uncertainty 0.200 -setup       $f2_clock_str"
#@     echoed2 "  set_clock_uncertainty 0.050 -hold        $f2_clock_str"
#@   # echoed2 "  set_propagated_clock                     $f2_clock_str"
#@     
#@     set uncertainty_value 0.300
#@     echoed2 "  set_clock_uncertainty $uncertainty_value $my_clocks_str"
#@   # echoed2 "  set_propagated_clock                     $my_clocks_str"
#@     
#@ }
#@ 
#@ # -- End source q6_avago.tcl

#@ 
#@ if {$running_design_compiler_topographical} {
#@     source $common_dir/place.tcl
#@ }
#@ 
#@ if { ! [info exists preflatten_netlist] } {
#@     if { [regexp {^elab} $script_name] } {
#@         set preflatten_netlist true
#@     }
#@     if { [regexp "${chip_name}_elab_*|${chip_name}_compile_*|${chip_name}_prefloorplan2_*" $input_file_name] } {
#@         set preflatten_netlist true
#@     }
#@ }
#@ 
#@ if { [string match *nopresto* [pwd]] } {
#@     puts "Information: disabling presto - This could be really really slow"    
#@     set hdlin_enable_presto_for_vhdl         FALSE
#@     # Workaround for non-presto elaboration bug for feedthrough(NATURAL) problem
#@     # This is OK, because we currently have no intention of using the non-presto compiles except for formal verification
#@     setenv SYNTHESIS_KEEPERS_NO_MAP_TO_ENTITY 1
#@ }
#@ 
#@ if { [exists_and_true running_formality]} {
#@     setenv SYNTHESIS_KEEPERS_NO_MAP_TO_ENTITY 1
#@ }
#@ 
#@ array set ocv_derate_factors {  ocv_wc_prelayout     {setup      { {-clock      -early 0.94} 
#@                                                                    {-clock      -late  1.06}
#@                                                                    {-data       -late  1.00}
#@                                                                    {-data       -early 0.90}
#@                                                                    {-cell_check -late  1.00} }
#@                                                       hold       setup
#@                                                      }
#@                                 ocv_wc               {setup      { {-clock      -early 0.94} 
#@                                                                    {-clock      -late  1.06}
#@                                                                    {-data       -late  1.00} 
#@                                                                    {-data       -early 0.90}
#@                                                                    {-cell_check -late  1.00} }
#@                                                       hold       setup
#@                                                      }
#@                                 ocv_wc47             {setup      { {-clock      -early 0.953} 
#@                                                                    {-clock      -late  1.000}
#@                                                                    {-data       -late  1.060} 
#@                                                                    {-data       -early 0.953}
#@                                                                    {-cell_check -late  1.060} }
#@                                                       hold       setup
#@                                                      }
#@                                 ocv_bc               {setup      { {-clock      -early 1.000}
#@                                                                    {-clock      -late  1.120}
#@                                                                    {-data       -late  1.000}
#@                                                                    {-data       -early 1.000} }
#@                                                       hold       setup
#@                                                      }
#@                                 ocv_bc_hot           ocv_bc
#@                                 ocv_bc_cold          ocv_bc
#@                                 ocv_wc_hot           ocv_wc
#@                                 ocv_wc0          {setup      { {-late  1.00} }
#@                                                   hold       setup
#@                                                  }
#@                                 #ocv_wc_px    {        setup      { {-clock      -early 0.96}
#@                                                                    {-clock      -late  1.04}
#@                                                                    {-data       -late  1.10}
#@                                                                    {-data       -early 0.90}
#@                                                                    {-cell_check -late  1.10}
#@                                                                    {-cell_delay -early 0.80 [set cells [suppressed {SEL-004 SEL-005} {get_cells * -hier -filter "@ref_name=~GS5*"}]]}
#@                                                                    {-cell_delay -early 0.70 [set cells [suppressed {SEL-004 SEL-005} {get_cells * -hier -filter "@ref_name=~GL*"}]]}
#@                                                                    {-cell_delay -early 0.70 [set cells [suppressed {SEL-004 SEL-005} {get_cells * -hier -filter "@ref_name=~GH*"}]]}
#@                                                                  }
#@                                                       hold       setup
#@                                              }
#@                                 #ocv_bc_px    {        setup      { {-clock      -early 0.96}
#@                                                                    {-clock      -late  1.04}
#@                                                                    {-data       -late  1.10}
#@                                                                    {-data       -early 0.90}
#@                                                                    {-cell_check -late  1.10}
#@                                                                    {-cell_delay -early 0.80 [set cells [suppressed {SEL-004 SEL-005} {get_cells * -hier -filter "@ref_name=~GS5*"}]]}
#@                                                                    {-cell_delay -early 0.70 [set cells [suppressed {SEL-004 SEL-005} {get_cells * -hier -filter "@ref_name=~GL*"}]]}
#@                                                                    {-cell_delay -early 0.70 [set cells [suppressed {SEL-004 SEL-005} {get_cells * -hier -filter "@ref_name=~GH*"}]]}
#@                                                                  }
#@                                                       hold       setup
#@                                              }
#@                              }
#@ 
#@ if { [ regexp {ocv_} $analysis_type] && ( [lsearch [array names ocv_derate_factors] $analysis_type] == -1 ) } {
#@     puts "Err\or: ocv_derate_factors do not exist for analysis_type '$analysis_type'"
#@     exit
#@ }
#@ foreach ocv [array names ocv_derate_factors] {
#@     while { [llength $ocv_derate_factors($ocv)] == 1 } {
#@         set ocv_derate_factors($ocv) $ocv_derate_factors($ocv_derate_factors($ocv))
#@     }
#@ }
#@ 
#@ # Timing report file base
#@ if { [info exists trep_ext] } {
#@     set trep_base ${report_file_base}${trep_ext}
#@ } else {
#@     set trep_base ${report_file_base}-${analysis_type}
#@ }
#@ 
#@ # Useful stuff
#@ history keep 10000
#@ alias rt   report_timing -net -cap -input -trans -nosplit -sig 3
#@ alias rtx  report_timing -net -capacitance -input_pins -transition -crosstalk_delta -nosplit -sig 3
#@ alias rtf  report_timing -net -cap -input -trans -nosplit -sig 3 -path full_clock
#@ alias rtxx report_timing -net -capacitance -input_pins -transition -crosstalk_delta -nosplit -sig 3 -pba_mode exhaustive
#@ alias rtx3 report_timing -net -capacitance -input_pins -transition -crosstalk_delta -nosplit -sig 3 -pba_mode exhaustive -path full_clock_expanded
#@ alias rt0  report_timing -slack_lesser_than -0.002
#@ alias sc   sizeof_collection
#@ alias h history
#@ alias ll ls -l
#@ 
#@ if { [exists_and_true running_design_compiler_topographical] } {
#@     alias rt   report_timing -net -cap -input -trans -nosplit -sig 3 -phys
#@     alias rt0  report_timing -net -cap -input -trans -nosplit -sig 3 -phys -slack_lesser_than -0.002
#@     alias sc   sizeof_collection
#@     alias rc   report_collection
#@ }
#@ 
#@ alias ptideal set force_primetime_ideal_nets 1
#@ alias dcrun set running_design_compiler 1
#@ 
#@ #############################################################
#@ # Block level stuff
#@ 
#@ # Subblocks are precompiled and then dont_touch'ed during the main block compile
#@ # Setting block names in post_ungroup, or post_incremental, cause a second -incremental compile
#@ 
#@ set ilm_block_names [list datapath                  \
#@                           ecp_top                   \
#@                           lcp_top                   \
#@                           statistics_block_x2       \
#@                           dmfe_buffer_top           \
#@                           dmfe_spreader_0           \
#@                           dmfe_spreader_1           \
#@                           dmfe_core                 \
#@                           queue_manager_top         \
#@                           scheduler_plus_top        \
#@                           fcx2_top                  \
#@                     ]
#@ 
#@ #                          dmfe_core_bis             \
#@ 
#@ #                          dmfed_buffers             \
#@ #                          qmisc_buffers             \
#@ #                          misc_buffers              \
#@ #                          lcp_buffers               \
#@ #                          fcx_buffers               \
#@ #                          dmfe_pll                  \
#@ 
#@ #                          scheduler_top             \
#@ #                          scheduler_slave_top       \
#@ #                          scheduler_wslave_top      \
#@ #                          dmscx                     \
#@ #                          statistics_small          \
#@ #                          xpl2vtop_core             \
#@ #                          xpl2_phys                 \
#@ 
#@ #                          xpl_buffers               \
#@ #                          dmfe_buffers              \
#@ #                          dmfe_serdes               \
#@ #                          xpl_serdes_x16            \
#@ #                          sensor                    \
#@ 
#@ foreach ilm $ilm_block_names {
#@     set ilm_mode($ilm) 0
#@ }
#@ if { [regexp {q[3456]chip|P6} $version] } {
#@     if { [ regexp {^q[3456]chip_ilmwilm$} $version ] } {
#@         foreach ilm $ilm_block_names {
#@             if { $ilm != {otpc} && $ilm != {xpl2vtop_core} } {
#@                 set ilm_mode($ilm) 1
#@             }
#@         }
#@     } elseif { [regsub {q[3456]chip_ilm} $version {} postmatch] } {
#@         set imode 1
#@         foreach ilm [split $postmatch {_}] {
#@             if { $ilm eq {} } continue
#@             if { $ilm eq {all} } {
#@                 foreach i $ilm_block_names {
#@                     set ilm_mode($i) $imode
#@                 }
#@             } elseif { $ilm eq {except} } {
#@                 set imode 0
#@             } elseif { [set i [lsearch $ilm_block_names "${ilm}*"]] != -1 } {
#@                 set ilm_mode([lindex $ilm_block_names $i]) $imode
#@             } else {
#@                 puts "Err\or: '$ilm' not a recognisable ilm name"
#@                 exit
#@             }
#@         }
#@     }
#@     puts "ILM Summary"
#@     puts "==========="
#@     foreach ilm [lsort [array names ilm_mode]] {
#@         puts [format "  %-20s %d" $ilm $ilm_mode($ilm)]
#@     }
#@ }
#@ global std_generics
#@ array unset std_generics 
#@ array set std_generics  { NUM_RX_BUNDLES                    2
#@                           NUM_TX_BUNDLES                    6
#@                           NUM_LINKS                        64
#@                           NUM_RX_BUF_WORDS                768
#@                           NUM_TX_BUF_WORDS                256
#@                           NUM_XPL2_LINKS_PER_PHYS_ITF       2
#@                           EXTERNAL_BUFFER_REQUEST_REGS      0
#@                           ADDITIONAL_RXBUF_READ_LATENCY     0
#@                           ADDITIONAL_RAM_READ_LATENCY       0
#@                         }
#@ 
#@ array unset blocks_info
#@ array set blocks_info   {
#@     default             {
#@                           block_name        default
#@                           lib               q6chip
#@                           timing            { 
#@                                               subchip_mbist_timing
#@                                               mickey_mouse_test_input_stuff
#@                                               mickey_mouse_reset_tree_input_stuff
#@                                               mickey_mouse_input_timing
#@                                               mickey_mouse_output_timing
#@                                             }
#@                           mbist_block_timing   { core_clock 5 }
#@                           reset_tree_portnames { reset core_reset core_reset_* xpl_reset dll_bist_reset dram_reset dram_div2_reset }
#@                           subblocks         {}
#@                           compile_tighter   {}
#@                           map_effort        ultra
#@                           area_effort       medium
#@                           clock_gating      before_compile
#@                           compile           {
#@                                                 set gate_clock {}
#@                                                 suppressed {PWR-206 PWR-729} {
#@                                                     global tech_clock_gating_latch
#@                                                     set_clock_gating_style -sequential_cell     latch                               \
#@                                                                            -minimum_bitwidth    8                                   \
#@                                                                            -positive_edge_logic integrated:$tech_clock_gating_latch \
#@                                                                            -control_point       before                              \
#@                                                                            -control_signal      scan_enable                         \
#@                                                                            -setup               0.15
#@                                                     switch $block_info(clock_gating) {
#@                                                         {before_compile} { get_licenses   Power-Optimization
#@                                                                            insert_clock_gating         
#@                                                                            remove_license Power-Optimization
#@                                                                          }
#@                                                         {during_compile} { set gate_clock {-gate_clock}
#@                                                                          }
#@                                                     }
#@                                                 }
#@                                                 suppressed {UID-109 CMD-036} {
#@                                                     set_boundary_optimization [get_designs feedthrough*] false
#@                                                 }
#@                                                 uniquify
#@                                                 if { $block_info(map_effort) == {ultra} } {
#@                                                     echoed "compile_ultra -scan -no_autoungroup -no_seq_output_inversion $gate_clock"
#@                                                     suppressed {UI-32} {
#@                                                         remove_license Power-Optimization
#@                                                     }
#@                                                 } else {
#@                                                     set_resource_allocation none
#@                                                     compile -map_effort $block_info(map_effort) -area_effort $block_info(area_effort) -scan
#@                                                 }
#@                                             }
#@                           post_ungroup      {}
#@                           post_incremental  {}
#@                           compile2_auto
#@                                             {
#@                                                 # This block is run if post_incremental or post_ungroup or compile_tighter is set
#@                                                 # (in some cases compile2 might call it up directly)
#@                                                 global compile_implementation_selection
#@                                                 set compile_implementation_selection false
#@                                                 if { $block_info(map_effort) == {ultra} } {
#@                                                     compile_ultra -inc -scan -no_autoungroup -no_seq_output_inversion
#@                                                 } else {
#@                                                     compile -inc -scan -map_effort medium    
#@                                                 }
#@                                                 set compile_implementation_selection true
#@                                             }
#@                           compile2          {}
#@                           post_compile2_ungroup { ungroup_*_node* }
#@                           elab              {}
#@                           generics          {}
#@                           default_clock     core_clock
#@                           wire_load_model   {}
#@                           wire_load_mode    enclosed
#@                           compile_check_for_unmapped_logic 1
#@                           uniquification_prefix {}
#@                           top_level_path    {unknown}
#@                           physical_compile  {
#@                                               # Including support for dcnxt and ICC2 based compile -spg
#@                                               my_compile_ultra_spg
#@                                             }
#@                           physical_compile_incr
#@                                             {
#@                                               my_compile_ultra_spg
#@                                             }
#@                           physical_compile_lvo
#@                                             {
#@                                             # remove_attribute [current_design] max_area
#@                                               set_size_only [get_cells *]
#@                                               compile_ultra -spg -incremental -no_seq_output_inversion
#@                                             }
#@                           no_constraint_compile
#@                                              {
#@                                               global dont_use_implementations
#@                                               foreach impl $dont_use_implementations {
#@                                                 suppressed UID-101 { remove_attribute $impl dont_use }
#@                                               }
#@                                               remove_constraint -all
#@                                               set_max_area 0
#@                                               set_resource_allocation none
#@                                               if { $block_info{wire_load_model} != {} } { set_wire_load_model -name $block_info(wire_load_model) }
#@                                               compile -map_effort high -area_effort high -scan
#@                                             }
#@                           compile2_for_no_constraint_compile
#@                                             {
#@                                               source timing.tcl
#@                                               set_max_area 0
#@                                               if { $block_info{wire_load_model} != {} } { set_wire_load_model -name $block_info(wire_load_model) }
#@                                               compile -map_effort high -area_effort high -scan -inc
#@                                               
#@                                               ungroup_things *DW*
#@                                               compile -map_effort high -area_effort high -scan -inc
#@                                               
#@                                               global dont_use_implementations
#@                                               foreach impl $dont_use_implementations {
#@                                                 dont_use $impl
#@                                               }
#@                                             }
#@                           congestion_map    {
#@                                               #W.....g: Contact *'s upper layer enclosure does not satisfy legal dimension requirement. (ZRT-120)
#@                                               #W.....g: Contact *'s upper layer enclosure does not satisfy legal width requirement. (ZRT-083)
#@                                               #W.....g: Layer * pitch * may be too small: wire/via-down *, wire/via-up *. (ZRT-026)
#@                                               puts "#log_info_suppress_messages ZRT-120,ZRT-083,ZRT-026"
#@                                               report_congestion -build_map
#@                                               puts "#log_info_unsuppress_messages ZRT-120,ZRT-083,ZRT-026"
#@                                             }
#@                           block_abstraction 0
#@                           physical_subblocks {}
#@                           fixed_netnames    {}
#@                           timing_reports    {}
#@                           check_avago_grid  check_avago_grid
#@                         }
#@ 
#@     # {Queue_manager subchip}
#@     
#@     queue_manager_top   { subblocks          { queue_manager
#@                                                write_request_fifo
#@                                              }
#@ 
#@                           mbist_block_timing { core_clock 12 }
#@                           
#@                           sched_to_qmgr_timing       { -ip_transit 0.150 -top_transit 0.050 -op_transit 0.260 }
#@                           qmgr_to_sched_timing       { -ip_transit 0.190 -top_transit 0.050 -op_transit 0.220 }
#@                           sslave_to_qmgr_timing      { -ip_transit 0.050 -top_transit 0.050 -op_transit 0.360 }
#@                           qmgr_to_sslave_timing      { -ip_transit 0.250 -top_transit 0.050 -op_transit 0.160 }
#@                           wslave_to_qmgr_timing      { -ip_transit 0.120 -top_transit 0.050 -op_transit 0.290 }
#@                           qmgr_to_wslave_timing      { -ip_transit 0.100 -top_transit 0.050 -op_transit 0.310 }
#@                           
#@                           qmgr_northside_in_timing   { -ip_transit 0.300 -top_transit 0.050 -op_transit 0.110 }
#@                           qmgr_northside_out_timing  { -ip_transit 0.110 -top_transit 0.050 -op_transit 0.300 }
#@ 
#@                           qmgr_sched_regbus_timing   { -ip_transit 0.205 -top_transit 0.050 -op_transit 0.205 }
#@                           sched_to_qmgr_reset_timing { -ip_transit 0.205 -top_transit 0.050 -op_transit 0.205 }
#@                             
#@                           timing            {
#@                                               subchip_test_input_stuff
#@                                               subchip_mbist_timing
#@                                               
#@                                               set_ram_clocks_advance_for_synthesis                0.050
#@                                             # set_ram_clocks_uncertainty_for_synthesis            0.233
#@                                               set_ram_response_register_uncertainty_for_synthesis 0.150 *BUFSTATUS_Q4SS*
#@                                               set_ram_response_register_uncertainty_for_synthesis 0.150 *BUFPTR_Q4SS*
#@                                               # Excluding QHT_WW because it is using a registered output ram (Q-type) instead of an external response register
#@                                               set_ram_response_register_uncertainty_for_synthesis 0.150 *QHT_RR*
#@                                               set_ram_response_register_uncertainty_for_synthesis 0.150 *QHT_WR*
#@                                               set_ram_response_register_uncertainty_for_synthesis 0.150 *QHT_RW*
#@                                               
#@                                               #if {! [exists_and_true postlayout_timing] } {
#@                                               #    check_mapped [fixpath "MEMS/BUFSTATUS_Q4S_0/B0/U/U/B0_S0/read_data_a_reg_0"]
#@                                               #    set_clock_uncertainty 0.160 [get_pins  [fixpath "MEMS/BUF*_Q4S_*/B*/U/U/B*_S0/read_data_a_reg_*/$phi"] -setup -filter "pin_direction==in"]
#@                                               #    set_clock_uncertainty 0.160 [get_pins  [fixpath "MEMS/QHT_*_Q4S*/B*/response2_a_reg*/$phi"           ] -setup -filter "pin_direction==in"]
#@                                               #}
#@ 
#@                                               group_path -name no_input_group   -from   [all_inputs]
#@                                               group_path -name no_output_group  -to     [all_outputs]
#@                                               
#@                                               group_path -name ram_bufptr_req     -to     [get_cells [fixpath "MEMS/BUFPTR*/*/*/*/U/U/*/U/U"]]
#@                                               group_path -name ram_bufptr_resp    -from   [get_cells [fixpath "MEMS/BUFPTR*/*/*/*/U/U/*/U/U"]]
#@                                               group_path -name ram_bufstatus_req  -to     [get_cells [fixpath "MEMS/BUFSTATUS*/*/*/*/U/U/*/U/U"]]
#@                                               group_path -name ram_bufstatus_resp -from   [get_cells [fixpath "MEMS/BUFSTATUS*/*/*/*/U/U/*/U/U"]]
#@                                               
#@                                               group_path -name ram_qht_req     -to     [get_cells [fixpath "MEMS/QHT*/*/*/*/*/U/U"]]
#@                                               group_path -name ram_qht_resp    -from   [get_cells [fixpath "MEMS/QHT*/*/*/*/*/U/U"]]
#@ 
#@                                               do_set_input_delay  {raw_core_reset*}         -comment "reset input"      -group from_raw_inputs      -args [get_block_info queue_manager_top sched_to_qmgr_reset_timing]
#@                                               do_set_output_delay {dmbuf_reset_out}         -comment "reset output"     -group qmgr_to_dmfe_reset   -args [get_block_info dmfe_buffer_top dmbuf_south_reset_timing] 
#@ 
#@                                               do_set_input_delay  {raw_regbus_request*}     -comment "regbus input"     -group from_raw_inputs      -args [get_block_info queue_manager_top qmgr_sched_regbus_timing]
#@                                               do_set_output_delay {regbus_response*   }     -comment "regbus output"    -group to_outputs           -args [get_block_info queue_manager_top qmgr_sched_regbus_timing]
#@ 
#@                                               # d0
#@                                               do_set_input_delay  {raw_datapath_to_qmgr_0*} -comment "d0 inputs"        -group d0_inputs            -args [get_block_info queue_manager_top qmgr_northside_in_timing]
#@                                               do_set_output_delay {qmgr_to_datapath_0*}     -comment "d0 outputs"       -group d0_outputs           -args [get_block_info queue_manager_top qmgr_northside_out_timing]
#@ 
#@                                               # d1
#@                                               do_set_input_delay  {raw_datapath_to_qmgr_1*} -comment "d1 inputs"        -group d1_inputs            -args [get_block_info dmfe_buffer_top dmbuf_southside_out_timing]  
#@                                               do_set_output_delay {qmgr_to_datapath_1*}     -comment "d1 outputs"       -group d1_outputs           -args [get_block_info dmfe_buffer_top dmbuf_southside_in_timing]   
#@ 
#@                                               # Sched
#@                                               do_set_input_delay  {raw_sched_to_qmgr*}      -comment "sched inputs"     -group sched_inputs         -args [get_block_info queue_manager_top sched_to_qmgr_timing]   
#@                                               do_set_output_delay {qmgr_to_sched*}          -comment "sched outputs"    -group sched_outputs        -args [get_block_info queue_manager_top qmgr_to_sched_timing]   
#@ 
#@                                               # Sslave
#@                                               do_set_input_delay  {raw_sslave_to_qmgr*}     -comment "sslave inputs"    -group sslave_inputs        -args [get_block_info queue_manager_top sslave_to_qmgr_timing]  
#@                                               do_set_output_delay {qmgr_to_sslave*}         -comment "sslave outputs"   -group sslave_outputs       -args [get_block_info queue_manager_top qmgr_to_sslave_timing]  
#@ 
#@                                               # Wslave
#@                                               do_set_input_delay  {raw_wslave_to_qmgr*}     -comment "wslave inputs"    -group wslave_inputs        -args [get_block_info queue_manager_top wslave_to_qmgr_timing]  
#@                                               do_set_output_delay {qmgr_to_wslave*}         -comment "wslave outputs"   -group wslave_outputs       -args [get_block_info queue_manager_top qmgr_to_wslave_timing]  
#@                                               
#@                                               #Feedthroughs
#@                                               do_set_input_delay {  raw_d0_to_d1*
#@                                                                     raw_db0_to_db1*
#@                                                                     raw_sched_to_d1*
#@                                                                     raw_ecp_to_d1*
#@                                                                  } -comment "Northside feedthrough inputs"   -args [get_block_info queue_manager_top qmgr_northside_in_timing]  -group northside_feedthrough_inputs
#@                                               
#@                                               do_set_output_delay { d0_to_d1_out*
#@                                                                     db0_to_db1_out*
#@                                                                     sched_to_d1_out*
#@                                                                     ecp_to_d1_out*
#@                                                                     dmfe_buffer_regbus_request*
#@                                                                   } -comment "Southside feedthrough outputs" -args [get_block_info dmfe_buffer_top dmbuf_southside_in_timing]   -group southside_feedthrough_outputs
#@                                               
#@                                               do_set_input_delay {  raw_d1_to_d0*
#@                                                                     raw_db1_to_db0*
#@                                                                     raw_d1_to_sched*
#@                                                                     raw_d1_to_ecp*
#@                                                                     raw_dmfe_buffer_regbus_response*
#@                                                                     raw_t5_to_sched*
#@                                                                  } -comment "Southside feedthrough inputs"   -args [get_block_info dmfe_buffer_top dmbuf_southside_out_timing]  -group southside_feedthrough_inputs
#@                                         
#@                                               do_set_output_delay { d1_to_d0_out*
#@                                                                     db1_to_db0_out*
#@                                                                     d1_to_sched_out*
#@                                                                     d1_to_ecp_out*
#@                                                                     t5_to_sched_out*
#@                                                                   } -comment "Northside feedthrough outputs" -args [get_block_info queue_manager_top qmgr_northside_out_timing] -group northside_feedthrough_outputs
#@                                               
#@                                             }
#@                         physical_compile_incr {
#@                                                 compile_ultra -spg -incremental -no_seq_output_inversion
#@                                             }
#@                           compile           {
#@                                               set_boundary_optimization [get_designs qht_*_q4s_or_reduce_l1] false
#@                                               set_boundary_optimization [get_designs qht_*_q4s_or_reduce_l2] false
#@                                               eval [get_block_info default compile]
#@                                             }
#@                           uniquification_prefix Q_
#@                           top_level_path        Q/
#@                         }
#@     queue_manager       { timing            {
#@                                               eval [get_block_info default timing]
#@                                               
#@                                               set_input_delay 0.15 sched_to_qmgr* -clock core_clock
#@                                               set_input_delay 0.20 ram_responses* -clock core_clock
#@                                               
#@                                               set args [list -skew 0 -op_transit 0 -op_ff 0.150 -ip_transit 0.400 -ip_ff 0.050]
#@                                                                                             
#@                                               do_set_output_delay {ram_requests_rd*} -args $args -op_logic 0.0
#@                                               do_set_output_delay {ram_requests_wr*} -args $args -op_logic 0.0
#@                                               do_set_output_delay {ram_requests_rd*QHT*} -skew 0  -op_logic 0.120 -op_transit 0 -op_ff 0.150 -ip_transit 0.315
#@                                             }
#@                         }
#@     write_request_fifo  {
#@                         }
#@     feedthrough         { #             { Generic controls for feedthroughs }
#@                           timing        {
#@                                             global x_loads
#@                                             echoed {set_load [expr 3 * $x_loads(16)] [all_outputs]}
#@                                             set_max_delay 0.040 -from [all_inputs] -to [all_outputs]
#@                                         }
#@                         }
#@     qmgr_test           { 
#@                           #subblocks          { QHT_RR1_Q4S_RAM_avago BUFSTATUS_Q4S_RAM_inner_avago }
#@                           #physical_subblocks { QHT_RR1_Q4S_RAM_avago BUFSTATUS_Q4S_RAM_inner_avago }
#@                           timing        {
#@                                               eval [get_block_info default timing]
#@                                               # set additional clock uncert on ecc results regs if ! $running_physical_compiler ???
#@                                               # set_input_delay  0.2 [all_inputs]  -clock core_clock
#@                                               # set_output_delay 0.2 [all_outputs] -clock core_clock
#@                                               set_multicycle_path 2 -from [remove_from_collection [get_ports *inp*] [get_ports *inp*QHT_RR_RD_ADDR*]]
#@                                               set_multicycle_path 2 -to [get_ports *outp*]
#@                                               # set_clock_uncertainty 0.160 [get_pins [fixpath "MEMS/BUFSTATUS_Q4S_*/B*/U/U/B*_S0/read_data_a_reg_* $phi"]]
#@                                               # set_clock_uncertainty 0.160 [get_pins [fixpath "MEMS/QHT_RR1_Q4S*/B*/response2_a_reg* $phi"]]
#@                                         }                                                          
#@                         }
#@     feedthrough_T_BUFSTATUS_Q4S_RAM_REQUEST {
#@                             map_effort    medium
#@                         }
#@ 
#@     BUFSTATUS_Q4SS_RAM_avago   {
#@                             subblocks   { feedthrough_T_BUFSTATUS_Q4S_RAM_REQUEST }
#@                             timing      {
#@                                             #eval [get_block_info default timing]
#@                                             subchip_test_input_stuff
#@                                             subchip_mbist_timing
#@                                             
#@                                             set_input_delay  0.080 [all_inputs]  -clock core_clock
#@                                             set_output_delay 0.010 [all_outputs] -clock core_clock
#@                                             
#@                                             group_path -name to_column_response_reg -to [get_cells [fixpath "B*/response2_reg_*"]]
#@                                             group_path -name to_rams   -to   [get_cells [fixpath "B*/U/B*/U/U/B0_S0/U/U"]]
#@                                             group_path -name from_rams -from [get_cells [fixpath "B*/U/B*/U/U/B0_S0/U/U"]]
#@                                         }
#@                         }
#@     BUFSTATUS_Q4S_RAM_avago {
#@                           subblocks   { feedthrough_T_BUFSTATUS_Q4S_RAM_REQUEST }
#@                           #block_abstraction 1
#@                           timing        {
#@                                             #eval [get_block_info default timing]
#@                                             subchip_test_input_stuff
#@                                             subchip_mbist_timing
#@                                             
#@                                             set_input_delay  0.150 [get_ports *request*]  -clock core_clock
#@                                             set_output_delay 0.050 [get_ports *response*] -clock core_clock
#@ 
#@                                             group_path -name to_rams   -through [get_pins [fixpath "B*/U/U/B0_S0/U/U *"] -filter "@direction==in"]
#@                                             group_path -name from_rams -through [get_pins [fixpath "B*/U/U/B0_S0/U/U Q*"]]
#@                                         }
#@                     }
#@                     
#@     BUFPTR_Q4S_RAM_inner_avago {
#@                           #block_abstraction 1
#@                           timing        {
#@                                               eval [get_block_info default timing]
#@                                               set_input_delay  0.67 [all_inputs]  -clock core_clock
#@                                               set_output_delay 0.66 [all_outputs] -clock core_clock
#@                                               # set_clock_uncertainty 0.160 [get_pins [fixpath "U/U/B*_S0/read_data_a_reg_* $phi "]]
#@                                         }
#@                     }
#@     BUFSTATUS_Q4S_RAM_inner_avago {
#@                           #block_abstraction 1
#@                           timing        {
#@                                               eval [get_block_info default timing]
#@                                               set_input_delay  0.67 [all_inputs]  -clock core_clock
#@                                               set_output_delay 0.66 [all_outputs] -clock core_clock
#@                                               # set_clock_uncertainty 0.160 [get_pins [fixpath "U/U/B*_S0/read_data_a_reg_* $phi"]]
#@                                         }
#@                     }
#@                     
#@     QHT_RR1_Q4S_RAM_avago {
#@                           #block_abstraction 1
#@                           timing        {
#@                                               eval [get_block_info default timing]
#@                                               # set_clock_uncertainty 0.160 [get_pins [fixpath "B*/response2_a_reg* $phi"]]
#@                                               do_set_input_delay  request*  -op_transit 0.1                   -ip_logic 0.175  -ip_transit 0.455  -ip_ff 0.175
#@                                               do_set_output_delay response* -op_transit 0.35 -op_logic 0.19   -ip_logic 0.3    -ip_transit 0     
#@                                         }
#@                         compile         {
#@                                               set_boundary_optimization [get_designs qht_*_q4s_or_reduce_l1] false
#@                                               set_boundary_optimization [get_designs qht_*_q4s_or_reduce_l2] false
#@                                               eval [get_block_info default compile]
#@                                         }
#@                         }
#@     QHT_WW_Q4S_RAM_avago {
#@                           timing        {     eval [get_block_info QHT_RR1_Q4S_RAM_avago timing]  }
#@                          }
#@     QHT_WR_Q4S_RAM_avago {
#@                           timing        {     eval [get_block_info QHT_RR1_Q4S_RAM_avago timing]  }
#@                         }
#@     QHT_RW_Q4S_RAM_avago {
#@                           timing        {     eval [get_block_info QHT_RR1_Q4S_RAM_avago timing]  }
#@                         }
#@     QHT_RR2_Q4S_RAM_avago {
#@                           timing        {     eval [get_block_info QHT_RR1_Q4S_RAM_avago timing]  }
#@                         }
#@ 
#@     # {Scheduler_plus_top subchip}
#@ 
#@     scheduler_plus_top { subblocks              { scheduler_wslave_top scheduler_slave_top scheduler_top}
#@                          mbist_block_timing     { core_clock 6 }
#@ 
#@                          sched_plus_to_ecp_timing  {  }
#@                          ecp_to_sched_plus_timing  {  }
#@                          sched_plus_to_lcp_timing  {  }
#@                          lcp_to_sched_plus_timing  {  }
#@ 
#@                          timing          {
#@                                               subchip_test_input_stuff
#@                                               subchip_mbist_timing
#@                           
#@                                               group_path -name no_input_group  -from [all_inputs]
#@                                               group_path -name no_output_group -to   [all_outputs]
#@                                               
#@                                               # This includes raw_core_reset - timed to FFs in reset resync - need more margin for PC?
#@                                               
#@                                                   # do_set_input_delay {raw_*}
#@                                                   
#@                                                                                                 
#@                                               # block to block communication
#@ 
#@                                                   do_set_input_delay  {raw_qmgr_to_sslave*} -comment "raw inputs from Q to sslave"  -args [get_block_info queue_manager_top qmgr_to_sslave_timing] -group qmgr_to_sslave_inputs
#@                                                   do_set_output_delay {sslave_to_qmgr*}     -comment "sslave outputs to Q"          -args [get_block_info queue_manager_top sslave_to_qmgr_timing] -group sslave_to_qmgr_outputs
#@ 
#@                                                   do_set_input_delay  {raw_qmgr_to_wslave*} -comment "raw inputs from Q to wslave"  -args [get_block_info queue_manager_top qmgr_to_wslave_timing] -group qmgr_to_wslave_inputs
#@                                                   do_set_output_delay {wslave_to_qmgr*}     -comment "wslave outs to Q"             -args [get_block_info queue_manager_top wslave_to_qmgr_timing] -group wslave_to_qmgr_outputs
#@                                                   
#@                                                   do_set_input_delay  {raw_qmgr_to_sched*} -comment "raw inputs from Q to sched"  -args [get_block_info queue_manager_top qmgr_to_sched_timing] -group qmgr_to_sched_inputs
#@                                                   do_set_output_delay {sched_to_qmgr*}     -comment "sched outs to Q"             -args [get_block_info queue_manager_top sched_to_qmgr_timing] -group sched_to_qmgr_outputs
#@                                                   
#@                                               #reset
#@                                                   do_set_output_delay {dmbuf_reset_out }   -comment "sched to dmfe reset" -args [get_block_info dmfe_buffer_top dmbuf_south_reset_timing ] -group sched_to_dmfe_reset
#@                                                   do_set_output_delay {qmgr_reset_out}     -comment "sched to qmgr reset" -args [get_block_info queue_manager_top sched_to_qmgr_reset_timing] -group sched_to_qmgr_reset
#@                                                   
#@                                               # to datapath
#@                                                   do_set_input_delay  {raw_datapath_to_sched_0*} -comment "D0 inputs"      -args [get_block_info dmfe_buffer_top dmbuf_southside_out_timing]   -group D0_inputs
#@                                                   do_set_output_delay {sched_to_datapath_0*}     -comment "D0 ouptuts"     -args [get_block_info dmfe_buffer_top dmbuf_southside_in_timing]   -group D0_ouptuts
#@                                                   # do_set_output_delay {sched_to_datapath_0*}     -comment "sched outs to D0"      -args {-op_transit 0.330 -ip_transit 0.170 -top_transit 0.060 } -group sched_to_datapath_0
#@                                                   
#@                                                   do_set_input_delay  {raw_datapath_to_sched_1*} -comment "D1 inputs"      -args [get_block_info queue_manager_top qmgr_southside_out_timing]   -group D1_inputs
#@                                                   do_set_output_delay {sched_to_datapath_1*}     -comment "D1 outputs"     -args [get_block_info queue_manager_top qmgr_southside_in_timing]   -group D1_ouptuts
#@                                                   
#@                                               # to dmfe_core
#@                                                 do_set_input_delay  {raw_fcx2_to_sched* raw_lcp40g_response*} -args [get_block_info dmfe_core dmfe_core_to_sched_timing]
#@                                                 do_set_output_delay {lcp40g_request_out*}                     -args [get_block_info dmfe_core sched_to_dmfe_core_timing]
#@                                                     
#@                                               #ecp
#@                                                   do_set_input_delay  {raw_regbus_request* raw_ecp_to_datapath* raw_ecp_to_sched* raw_core_reset} -args [get_block_info  scheduler_plus_top  ecp_to_sched_plus_timing]
#@                                                   do_set_output_delay {regbus_response*    datapath_to_ecp_out*                                 } -args [get_block_info  scheduler_plus_top  sched_plus_to_ecp_timing]
#@ 
#@                                               #qmgr regbus  
#@                                                   do_set_input_delay  {raw_qmgr_regbus_response*} -args [get_block_info queue_manager_top qmgr_sched_regbus_timing]
#@                                                   do_set_output_delay {qmgr_regbus_request*     } -args [get_block_info queue_manager_top qmgr_sched_regbus_timing]
#@                                                   
#@                                               #Feedthroughs
#@                                               do_set_input_delay {  raw_d1_to_d0*
#@                                                                     raw_db1_to_db0*
#@                                                                     raw_qmgr_to_d0*
#@                                                                     raw_datapath_to_ecp_1*
#@                                                                     raw_t5_to_sched*
#@                                                                  } -comment "Northside feedthrough inputs"      -args [get_block_info queue_manager_top qmgr_southside_out_timing]   -group northside_feedthrough_inputs
#@                                     
#@                                               do_set_input_delay {  raw_d0_to_d1*
#@                                                                     raw_db0_to_db1*
#@                                                                     raw_d0_to_qmgr*
#@                                                                     raw_datapath_to_ecp_0*
#@                                                                     raw_dmfe_buffer_regbus_response*
#@                                                                  } -comment "Southside feedthrough inputs"      -args [get_block_info dmfe_buffer_top dmbuf_southside_out_timing]   -group southside_feedthrough_inputs
#@                                                                  
#@                                               do_set_output_delay { d0_to_d1_out*
#@                                                                     db0_to_db1_out*
#@                                                                     d0_to_qmgr_out*
#@                                                                     ecp_to_datapath_out_1*
#@                                                                   } -comment "Northside feedthrough outputs"    -args [get_block_info queue_manager_top qmgr_southside_in_timing]  -group northside_feedthrough_outputs
#@                                               
#@                                               do_set_output_delay { d1_to_d0_out*
#@                                                                     db1_to_db0_out*
#@                                                                     qmgr_to_d0_out*
#@                                                                     ecp_to_datapath_out_0*
#@                                                                     dmfe_buffer_regbus_request*
#@                                                                   } -comment "Southside feedthrough outputs"    -args [get_block_info dmfe_buffer_top dmbuf_southside_in_timing]  -group southside_feedthrough_outputs
#@                                                                   
#@                                               do_set_input_delay  {raw_lcp40g_request* } -args [get_block_info scheduler_plus_top lcp_to_sched_plus_timing]
#@                                               do_set_output_delay {lcp40g_response_out*} -args [get_block_info scheduler_plus_top sched_plus_to_lcp_timing]
#@                                                   
#@                                                   
#@                                               # NB: This group_path for VOQ1 read path doesn't work with flop implementation
#@                                               # group_path -name through_voq1_ram -through [get_pins [fixpath "S/MEMS/VOQ1/response*"]]
#@ 
#@                                               # To/From qmgr
#@ 
#@                                                   # do_set_input_delay  {raw_qmgr*}       -comment "raw inputs from Q"  -args [get_block_info queue_manager_top qmgr_to_sched_timing] -group qmgr_inputs_to_sched
#@                                                   # do_set_output_delay {sched_to_qmgr*}  -comment "outputs to Q"       -args [get_block_info queue_manager_top sched_to_qmgr_timing] -group sched_to_qmgr_outputs
#@                                                
#@ 
#@                                          }
#@                            uniquification_prefix SVW_
#@                            top_level_path        SVW/
#@                        }
#@     
#@     # {Scheduler_slave_top subchip}
#@ 
#@     scheduler_slave_top { subblocks         { scheduler_slave }
#@                           mbist_block_timing { core_clock 6 }
#@                           timing            {
#@                                               subchip_test_input_stuff
#@                                               subchip_mbist_timing
#@                           
#@                                               group_path -name no_input_group  -from [all_inputs]
#@                                               group_path -name no_output_group -to   [all_outputs]
#@                                               
#@                                               do_set_input_delay {raw_core_reset} -comment "raw_core_reset"
#@ 
#@                                               do_set_input_delay  {raw_qmgr*}       -comment "raw inputs from Q"  -args [get_block_info queue_manager_top qmgr_to_sslave_timing] -group qmgr_inputs
#@                                               do_set_output_delay {sslave_to_qmgr*} -comment "outputs to Q"       -args [get_block_info queue_manager_top sslave_to_qmgr_timing] -group qmgr_outputs
#@ 
#@                                               do_set_input_delay {raw_sched*}        -comment "raw_inputs from S" 
#@                                               do_set_output_delay {sslave_to_sched*} -comment "outputs to S"
#@ 
#@                                               # do_set_input_delay {raw_stats_to_d0*}  -comment "feedthrough inputs " 
#@                                               # do_set_output_delay {stats_to_d0_out*} -comment "feedthrough outputs"
#@                                               
#@                                               # group_path -name from_qlbconfig -from [get_cells [fixpath "V/SMEMS/QLBCONFIG/U/$BS_SS_U"]]
#@                                               # group_path -name from_qlbstate  -from [get_cells [fixpath "V/SMEMS/QLBSTATE/U/$BS_SS_U"]]
#@                                               # group_path -name to_qlbconfig   -to   [get_cells [fixpath "V/SMEMS/QLBCONFIG/U/$BS_SS_U"]]
#@                                               # group_path -name to_qlbstate    -to   [get_cells [fixpath "V/SMEMS/QLBSTATE/U/$BS_SS_U"]]
#@ 
#@                                            }
#@                            post_incremental   { scheduler_slave }
#@                            compile2           { global compile_implementation_selection
#@                                                 set compile_implementation_selection false
#@                                                 compile -inc -scan -map_effort high -area_effort high
#@                                                 compile -inc -scan -map_effort high -area_effort none
#@                                                 set compile_implementation_selection true
#@                                                 
#@                                                 # uniquify after compile
#@                                                 set uniquify_naming_style "[get_block_info $design_name uniquification_prefix]%s_%d"
#@                                                 uniquify -cell [get_cells -hierarchical -filter "ref_name=~ungroup*"]
#@                                               }
#@                            uniquification_prefix V_
#@                            top_level_path        V/
#@                         }
#@     scheduler_slave     { timing            {
#@                                               eval [get_block_info default timing]
#@                                               
#@                                               do_set_output_delay {lb_adjust_ack}      -op_transit 0.30 -op_logic 0.25 -ip_transit 0
#@                                               do_set_input_delay {ram_response*}       -ip_logic 0.55 -ip_ff 0.05 -ip_transit 0 -op_transit 0 -skew 0
#@ 
#@                                            #  set_input_delay 0.080 [get_ports qmgr_to_sslave_LAST_INDEX*] -clock core_clock
#@                                            #  do_set_output_delay {sslave_to_qmgr*}   -comment "outputs to Q" -args [get_block_info queue_manager_top sslave_to_qmgr_timing] -group qmgr_outputs
#@                                             }
#@                          #compile_tighter    0.050
#@                         }
#@ 
#@     scheduler_wslave_top { subblocks         { scheduler_wred_slave }
#@                           inp_timing         { -op_transit 0.420 -ip_transit 0.150 }
#@                           mbist_block_timing { core_clock 6 }
#@                           timing            {
#@                                               subchip_test_input_stuff
#@                                               subchip_mbist_timing
#@                           
#@                                               group_path -name no_input_group  -from [all_inputs]
#@                                               group_path -name no_output_group -to   [all_outputs]
#@                                               
#@                                               do_set_input_delay {raw_core_reset} -comment "raw_core_reset"
#@ 
#@                                               do_set_input_delay  {raw_qmgr*}       -comment "raw inputs from Q"  -args [get_block_info queue_manager_top qmgr_to_wslave_timing] -group qmgr_inputs
#@                                               do_set_output_delay {wslave_to_qmgr*} -comment "outs to Q"          -args [get_block_info queue_manager_top wslave_to_qmgr_timing] -group qmgr_outputs
#@ 
#@                                               do_set_input_delay  {raw_sched*}       -comment "raw_inputs from S" -args [get_block_info scheduler_wslave_top inp_timing]  -group sched_inputs
#@                                               do_set_output_delay {wslave_to_sched*} -comment "outputs to S"
#@                                            }
#@                            uniquification_prefix W_
#@                            top_level_path        W/
#@                         }
#@     scheduler_wred_slave { timing           {
#@                                               eval [get_block_info default timing]
#@                                                
#@                                               set_input_delay  -clock core_clock 0.35 [get_ports ram_response*]
#@                                               set_output_delay -clock core_clock 0.35 [get_ports ram_request*]
#@                                             }
#@                           ##post_ungroup      { ungroup_* }
#@                         }
#@                         
#@     # {Scheduler_top subchip}
#@ 
#@     scheduler_top       { subblocks         { scheduler voq_controller VOQ1_RAM_rtl}
#@                           timing            {
#@                                               subchip_test_input_stuff
#@                                               subchip_mbist_timing
#@                                               
#@                                               group_path -name no_input_group  -from [all_inputs]
#@                                               group_path -name no_output_group -to   [all_outputs]
#@ 
#@                                               # This includes raw_core_reset - timed to FFs in reset resync - need more margin for PC?
#@                                               
#@                                                   do_set_input_delay {raw_*}
#@ 
#@                                               # Resets out
#@ 
#@                                                 # do_set_output_delay {sslave_reset_out wslave_reset_out}
#@ 
#@                                               # To/From qmgr
#@ 
#@                                                   do_set_input_delay  {raw_qmgr*}       -comment "raw inputs from Q"  -args [get_block_info queue_manager_top qmgr_to_sched_timing] -group qmgr_inputs
#@                                                   do_set_output_delay {sched_to_qmgr*}  -comment "outputs to Q"       -args [get_block_info queue_manager_top sched_to_qmgr_timing] -group qmgr_outputs
#@                                                   
#@                                                   do_set_input_delay  {raw_regbus_request*}
#@                                                   do_set_output_delay {regbus_response*}
#@                                                   
#@ 
#@                                               # to sslave
#@                                               
#@                                                   do_set_output_delay {sched_to_sslave*}
#@                                                   do_set_output_delay {sched_to_wslave*}  -comment "outputs to W" -args [get_block_info scheduler_wslave_top inp_timing]  -group wslave_outputs
#@ 
#@                                               # to/from fcx2
#@ 
#@                                                   do_set_input_delay {raw_fcx2_to_sched*}
#@                                                   # do_set_output_delay {sched_to_fcx2*}
#@                                                   
#@                                               # to datapath
#@                                               
#@                                                   do_set_output_delay {sched_to_datapath*}
#@                                                   
#@                                               # NB: This group_path for VOQ1 read path doesn't work with flop implementation
#@                                               # group_path -name through_voq1_ram -through [get_pins [fixpath "S/MEMS/VOQ1/response*"]]
#@                                            }
#@                           compile2         {
#@                                              eval [get_block_info default compile2_auto] 
#@                                            }
#@                           uniquification_prefix S_
#@                           top_level_path        S/
#@                         }
#@ 
#@     VOQ1_RAM_rtl        { timing            {
#@                                               eval [get_block_info default timing]
#@                                               set_input_delay  -clock core_clock 0.400 [get_ports request*] 
#@                                               set_input_delay  -clock core_clock 0.600 [get_ports request_b_WR_DATA_PARITY] 
#@                                               set_output_delay -clock core_clock 0.250 [get_ports response*]
#@                                             }
#@                         }
#@ 
#@     scheduler           { timing            {
#@                                               eval [get_block_info default timing]
#@                                               set_input_delay 0.100 -clock core_clock qmgr*
#@                                               set_input_delay 0.100 -clock core_clock sslave*
#@                                               set_input_delay 0.200 -clock core_clock ram_response*
#@                                               set_input_delay 0.150 -clock core_clock ram_responses_VOQ_*
#@                                               set_input_delay 0.550 -clock core_clock ram_responses_VOQ1*
#@                                             }
#@                          compile2           {
#@                                               eval [get_block_info default compile2_auto] 
#@                                             }
#@                        }
#@                         
#@     voq_controller      { subblocks         { voq_super_cluster voq_resolver}
#@                           timing            { # some slackish outputs
#@                                               eval [get_block_info default timing]
#@                                               do_set_output_delay {cpu_response*}
#@ 
#@                                               # and some tighter ones
#@                                               do_set_output_delay {next_voq*} -op_transit 0.15
#@                                             }
#@                         }
#@ 
#@     voq_super_cluster  { subblocks         { voq_cluster }
#@                           timing            { # no mickey mouse timing here, but do need to find the reset tree..
#@                                               mickey_mouse_reset_tree_input_stuff
#@ 
#@                                               do_set_output_delay {voq_request*} -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.0
#@                                               do_set_output_delay {selection*}   -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.32
#@                                               do_set_output_delay {muxed_voq muxed_cfg} -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.32
#@                                               
#@                                               do_set_input_delay {global*}          -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.350
#@                                               do_set_input_delay {credits_decoded*} -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.350
#@                                               do_set_input_delay {clear_priority*}  -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.330
#@                                               do_set_input_delay {set_priority*}    -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.350
#@                                               do_set_input_delay {backpressure*}    -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.330
#@                                               do_set_input_delay {*broadside*}      -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.330
#@                                               
#@                                               # lb signals are registered at cluster level. here just a small amount of fanout.
#@                                               do_set_input_delay {lb_adjust* lb_increment* global_LB_ADJUST* global_LB_INCREMENT*} -skew 0  -ip_logic 0.1 -ip_transit 0
#@                                             }
#@                         }
#@                         
#@     voq_cluster         { subblocks         { voq_one }
#@                           timing            { # no mickey mouse timing here, but do need to find the reset tree..
#@                                               mickey_mouse_reset_tree_input_stuff
#@ 
#@                                               do_set_output_delay {voq_request*} -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.0
#@                                               do_set_output_delay {selection*}   -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.26
#@                                               
#@                                               do_set_input_delay {global*}          -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.300
#@                                               do_set_input_delay {credits_decoded*} -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.270
#@                                               do_set_input_delay {clear_priority*}  -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.240
#@                                               do_set_input_delay {set_priority*}    -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.290
#@                                               do_set_input_delay {backpressure*}    -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.240
#@                                               do_set_input_delay {*broadside*}      -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.240
#@                                               
#@                                               # lb signals are straight onto registers
#@                                               do_set_input_delay {lb_adjust* lb_increment* global_LB_ADJUST* global_LB_INCREMENT*} -skew 0 -ip_logic 0 -ip_transit 0
#@                                             }
#@                         }
#@     voq_one             { timing            {
#@                                               eval [get_block_info default timing]
#@                                               remove_output_delay [all_outputs]
#@                                               
#@                                               do_set_output_delay {request}    -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.0
#@                                               do_set_output_delay {selection*} -skew 0 -ip_transit 0 -op_transit 0 -top_transit 0 -op_logic 0.20
#@                                               
#@                                               do_set_input_delay {global*}         -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.250
#@                                               do_set_input_delay {credit_update*}  -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.250
#@                                               do_set_input_delay {clear_priority*} -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.230
#@                                               do_set_input_delay {set_priority*}   -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.280
#@                                               do_set_input_delay {backpressure*}   -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.230
#@                                               do_set_input_delay {*broadside*}     -skew 0 -ip_transit 0 -op_transit 0 -ip_logic 0.230
#@ 
#@                                               # lb signals are registered at cluster level, so just need time for fanout here ...
#@                                               set_input_delay [expr [lfirst $ff_delay(wc)] + 0.10] -clock core_clock [get_ports global_LB_INCREMENT*]
#@                                               set_input_delay [expr [lfirst $ff_delay(wc)] + 0.10] -clock core_clock [get_ports global_LB_ADJUST*]
#@                                               set_input_delay [expr [lfirst $ff_delay(wc)] + 0.05] -clock core_clock [get_ports {lb_adjust lb_increment}]
#@                                             }
#@                         }
#@                         
#@     voq_resolver        { timing            {
#@                                               eval [get_block_info default timing]
#@ 
#@                                               set_input_delay 0.67 [get_ports {selection*}] -clock core_clock
#@                                               group_path -name from_selection -from [get_ports {selection*}]
#@ 
#@                                               set_input_delay 0.62 [get_ports {voq_requests*}] -clock core_clock
#@                                               group_path -name from_voq_requests        -from [get_ports {voq_requests*}]
#@ 
#@                                               set_input_delay 0.57 [get_ports {voq_flow_control_ok*}] -clock core_clock
#@                                               group_path -name from_voq_flow_control_ok -from [get_ports {voq_flow_control_ok*}]
#@                                               
#@                                               set_input_delay 0.30 [get_ports {config*}]   -clock core_clock
#@                                               group_path -name from_config -from [get_ports {config*}]
#@                                               
#@                                             }
#@                         }
#@                         
#@     # {ECP_TOP subchip}
#@                                               
#@     ecp_top             { subblocks         { spork_wrap
#@                                               dma_engine
#@                                               int_controller
#@                                               q6chip_event_counter
#@                                             }
#@                           #compile           {
#@                           #                    # force selection of CLA adder for this logic - in this section because we don't want this constraint in the SDC.
#@                           #                    set_max_delay 0.65 -from  [get_cells REGIF/REGIF/reg_request*ADDR*] -to [get_cells REGIF/REGIF/reg_request*ADDR*]
#@                           # 
#@                           #                    eval [get_block_info default compile]
#@                           #                  }
#@ 
#@                           LE_to_LE_timing   { -op_transit 0.100 -ip_transit 0.100 -top_transit 0.250 }
#@                           timing            {
#@                                               subchip_test_input_stuff
#@                                               subchip_mbist_timing
#@                                               
#@                                               eval [get_block_info spork_wrap special_ram_uncertainties]
#@ 
#@                                               # core_clock - "Standard" inputs and outputs
#@                                               set sched_in_ports_list {raw_from_datapath*
#@                                                                        raw_regbus_response*
#@                                                                       }
#@                                               set lcp_in_ports_list  {raw_core_reset
#@                                                                       raw_lcp40g_slave_req*
#@                                                                       raw_lcp40g_master_response*
#@                                                                      }
#@                                               set extra_in_ports_list {raw_from_xpl2*
#@                                                                       }
#@                                               do_set_input_delay $sched_in_ports_list -comment "standard x1 inputs - sched" -args [get_block_info scheduler_plus_top sched_plus_to_ecp_timing] -group "x1_inputs - sched"
#@                                               do_set_input_delay $lcp_in_ports_list   -comment "standard x1 inputs - lcp"   -args [get_block_info ecp_top            LE_to_LE_timing         ] -group "x1_inputs - lcp"
#@                                               do_set_input_delay $extra_in_ports_list -comment "standard x1 inputs - extra"                                                                    -group "x1_inputs - extra"
#@                                               
#@                                               set sched_out_ports_list {to_datapath_* 
#@                                                                         to_scheduler_* 
#@                                                                         regbus_request*
#@                                                                         sched_reset_out
#@                                                                        }
#@                                               set extra_out_ports_list {
#@                                                                         to_xpl2*
#@                                                                        }
#@                                               set lcp_out_ports_list  {lcp40g_slave_resp*
#@                                                                        lcp40g_master_request*
#@                                                                       }
#@                                               do_set_output_delay $sched_out_ports_list -comment "standard x1 outputs - sched" -args [get_block_info scheduler_plus_top ecp_to_sched_plus_timing] -group "x1_outputs - sched"
#@                                               do_set_output_delay $lcp_out_ports_list   -comment "standard x1 outputs - lcp"   -args [get_block_info ecp_top           LE_to_LE_timing   ]        -group "x1_outputs - lcp"
#@                                               do_set_output_delay $extra_out_ports_list -comment "standard x1 outputs - extra"                                                                    -group "x1_outputs - extra"
#@ 
#@                                               # Async primary inputs - sampled onto core_clock, not timing critical
#@                                               
#@                                               # This is an async transfer (uses a resync_) but this tight constraint works fine at subchip level                                              
#@                                               do_set_input_delay {a_gpio_from_pins_*} -comment "async primary inputs" -skew 0.0 -ip_transit 0.240 -group "async_primary_inputs"
#@ 
#@                                               # Primary outputs - off core_clock, not time critical 
#@                                               do_set_output_delay {gpio_output_enables_* gpio_to_pins_*} -comment "primary outputs" -skew 0.0 -op_transit 0.240 -group "primary_outputs"
#@                                           
#@                                               group_path -name "from_rams" -from [get_cells [fixpath ECPCOM/SPORK_*/U*/B*/U/U]]
#@                                               group_path -name "to_rams"   -to   [get_cells [fixpath ECPCOM/SPORK_*/U*/B*/U/U]]
#@ 
#@                                            }
#@                           post_incremental  { spork_wrap dma_engine timer_generator_NUM_TIMERS32 lcp40g_master_access regbus_interface }
#@ 
#@                           check_avago_grid  {check_avago_grid -loose}
#@                           uniquification_prefix E_
#@                           top_level_path        E/
#@                         }
#@     spork_wrap          { special_ram_uncertainties  {
#@                                               # NB: Is there somewhere more global we could put this ?
#@                                               #     Or do we need it to be done for each design ?
#@                                               set_ram_clocks_advance_for_synthesis                 0.050
#@                                               set_ram_clocks_uncertainty_for_synthesis             0.175
#@                                               set_ram_response_register_uncertainty_for_synthesis  0.175
#@                                             }
#@                           timing            {   
#@                                                 eval [get_block_info default timing]
#@                                                 eval $block_info(special_ram_uncertainties)
#@                                                 set_input_delay 0 -clock core_clock ecp_num*
#@                                                 do_set_output_delay {ext_ack_DATA*} -op_logic 0.300 -op_transit 0.0 -ip_transit 0.0 -ip_logic 0.200
#@                                             }
#@                           compile           { suppressed RTDC-47 { eval [get_block_info default compile] } }
#@                          #compile2          { 
#@                                                 global compile_implementation_selection
#@                                                 set compile_implementation_selection false
#@                                                 
#@                                                 set_critical_range 0.150 [current_design]
#@                                                 compile -inc -map_effort high -area_effort none -power_effort none
#@                                             }
#@                         }
#@     int_controller      { subblocks         {or_block int_setclear_block}
#@                           post_ungroup      {or_block int_setclear_block*}
#@                         }
#@     or_block            { timing            { mickey_mouse_input_timing
#@                                             }
#@                           compile           { 
#@                                               set_resource_allocation none
#@                                               compile -map_effort high -area_effort high 
#@                                             }
#@                           scan_methodology  full_scan
#@                           scan_style        combinational
#@                         }
#@     int_setclear_block  { timing            { mickey_mouse_input_timing
#@                                               mickey_mouse_reset_tree_input_stuff
#@                                             } 
#@                         }
#@ 
#@     q6chip_event_counter { #subblocks        { counter }
#@                            ##post_ungroup     { counter }
#@                          }
#@     counter              {
#@                            timing           { eval [get_block_info default timing]
#@                                               set_input_delay 0.45 clear -clock core_clock
#@                                               remove_output_delay [all_outputs]
#@                                             }
#@                            compile          {
#@                                               eval [get_block_info default no_constraint_compile]
#@                                             }
#@                            compile2         {
#@                                               eval [get_block_info default compile2_for_no_constraint_compile]
#@                                             }
#@                          }
#@                         
#@     dma_engine          { subblocks         { dma_engine_event_generator }
#@                         }
#@ 
#@     aldl_structural         {
#@                             lib             pqx6
#@                             elab            {
#@                                                 global source_dir
#@                                                 set makfile   [open $source_dir/common/vendors/broadcom/brcm3_pqx6/brcm3_pqx6.mak]
#@                                                 set fname {}
#@                                                 while { ![eof $makfile] } {
#@                                                     gets $makfile line
#@                                                     if { [regexp {directory (.*)} $line dummy d] } {
#@                                                         set dir $d
#@                                                         # puts ">> $dir";
#@                                                     }
#@                                                     if { [regexp {file (q6chip_compile_aldl_structural.v)} $line dummy file] } {
#@                                                         set fname $source_dir/$dir/$file
#@                                                         break
#@                                                     }
#@                                                     # puts $line
#@                                                 }
#@                                                 if { $fname ne {} } {
#@                                                     read_file -format verilog $fname
#@                                                 } else {
#@                                                     elaborate -lib $block_info(lib) $ver
#@                                                 }
#@                                             }
#@                             compile         { }
#@                             timing          { }
#@                             check_avago_grid {check_avago_grid -no_power_grid_requirement}
#@                             }
#@                             
#@     aldl_wrapper_with_bist_monitor {
#@                             lib             pqx6
#@                             default_clock   dll_bist_clock
#@                             generics        { NUM_ROWS 4 }
#@                             clock_portnames { core_clock   monitor_clock_in
#@                                               fcx_clock_0  clock_in
#@                                             }
#@                             timing          {
#@                                              eval [get_block_info default timing]
#@                                              set_false_path -from core_clock -to dll_bist_clock
#@                                              
#@                                              my_set_ideal_net "\[get_nets \[all_connected \[get_ports bypass_clock_in\] \] \]"
#@                                              
#@                                              echoed {configure_aldl_with_bist      {} 350}
#@                                              
#@                                              # Prevent any buffers being inserted here
#@                                              # mickey_mouse_vdd_stuff aldl_vdd
#@                                              
#@                                              set_input_delay 0.3 dll_bist_config* -clock dll_bist_clock
#@                                              set_input_delay 0.3 dll_bist_control* -clock dll_bist_clock
#@                                              do_set_output_delay {dll_bist_status*} -ip_transit 0 -op_transit 0 -skew 0 -ip_ff 0 -op_logic 0.4
#@                                              
#@                                              # set_false_path -to U/MONITOR_no_scan_reg_dont_touch
#@                                              remove_output_delay clock_out
#@                                              
#@                                             }
#@                             clock_gating    disabled
#@                             }
#@ 
#@     fcx2_receiver_fcx   {lib                pqx6
#@                          subblocks          { aldl_wrapper_with_bist_monitor }
#@                          default_clock      fcx_clock_0
#@                          clock_portnames    { fcx_clock_0 fcx_clock }
#@                          timing             { 
#@                                                 eval [get_block_info default timing]
#@                                                 
#@                                                 my_set_ideal_net "\[get_nets \[all_connected \[get_ports {sdl_test_clock}\] \] \]"
#@                                                 
#@                                                 configure_aldl_with_bist [fixpath SDELAY/] [get_clocks fcx_clock_0] 0.25 -120
#@                                                 
#@                                                 set_input_delay  0.5 a_config_* -clock dll_bist_clock
#@                                                 
#@                                                 set_output_delay 0.5 monitor_sample
#@                                                 set_output_delay 0.5 dll_bist_status_*
#@                                                 
#@                                                 do_set_output_delay {fcx_fcx2core_*} -clock_name fcx_clock_0 -op_transit 0.0 -phase_error 0.5
#@                                             }
#@                          clock_gating       disabled
#@                         }
#@ 
#@     fcx2_framer         { lib               pqx6
#@                           generics         { NUM_FCX2_SLOTS_PER_CLK 2 }
#@                         }
#@                         
#@     fcx3_data_recovery  { lib               pqx6
#@                           generics          { G_BITS_PER_CLK 1
#@                                             }
#@                           clock_portnames   { fcxref_clock      clock
#@                                               core_clock        no_core_clock_present
#@                                             }
#@                           clock_gating      disabled
#@                         }
#@                         
#@     fcx3_gearbox        { lib               pqx6
#@                           default_clock     fcxref_clock
#@                           clock_portnames   { fcxref_clock clock }
#@                         }
#@ 
#@     fcx2_rx_common      { lib               pqx6
#@                           generics          { NUM_STREAMS       8
#@                                               LAST_CAPTURE_SLOT 1023
#@                                             }
#@                           subblocks         { aldl_wrapper_with_bist_monitor }
#@                           timing            { 
#@                                                 eval [get_block_info default timing]
#@                                                 my_set_ideal_net "\[get_nets \[all_connected \[get_ports {sdl_test_clock}\] \] \]"
#@                                                 for {set i 0} {$i<=7} {incr i} {
#@                                                     configure_aldl_with_bist [fixpath RCVFCX_$i/SDELAY/] [get_clocks fcx_clock_$i] 0.25 -120
#@                                                 }
#@                                                 eval [get_block_info fcx3_oversampler timing]
#@                                                 set_input_delay 0.25 dll_bist_config* -clock dll_bist_clock
#@                                                 set_input_delay 0.25 dll_bist_control* -clock dll_bist_clock
#@                                                 do_set_output_delay {dll_bist_status*} -ip_transit 0 -op_transit 0 -skew 0 -ip_ff 0 -op_logic 0.4 -clock_name dll_bist_clock
#@                                             }
#@                           clock_gating      disabled
#@                         }
#@                         
#@     fcx2_top            { subblocks         { aldl_wrapper_with_bist_monitor
#@                                               fcx2_framer
#@                                               fcx3_data_recovery
#@                                             }
#@                           default_clock     core_clock
#@                           fixed_netnames    {
#@                                               COMMON/FCX3/SMPL/CLKBUF_0/U/i               { COMMON/FCX3/SMPL/dclock_0 COMMON/FCX3/SMPL/CLKBUF_0/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_1/U/i               { COMMON/FCX3/SMPL/dclock_1 COMMON/FCX3/SMPL/CLKBUF_1/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_2/U/i               { COMMON/FCX3/SMPL/dclock_2 COMMON/FCX3/SMPL/CLKBUF_2/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_3/U/i               { COMMON/FCX3/SMPL/dclock_3 COMMON/FCX3/SMPL/CLKBUF_3/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_4/U/i               { COMMON/FCX3/SMPL/dclock_4 COMMON/FCX3/SMPL/CLKBUF_4/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_5/U/i               { COMMON/FCX3/SMPL/dclock_5 COMMON/FCX3/SMPL/CLKBUF_5/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_6/U/i               { COMMON/FCX3/SMPL/dclock_6 COMMON/FCX3/SMPL/CLKBUF_6/clock_in }
#@                                               COMMON/FCX3/SMPL/CLKBUF_7/U/i               { COMMON/FCX3/SMPL/dclock_7 COMMON/FCX3/SMPL/CLKBUF_7/clock_in }
#@                                               
#@                                               COMMON/FCX3/SMPL/CLKBUF_0/U/o               { COMMON/FCX3/SMPL/buffered_dclock0 COMMON/FCX3/SMPL/CLKBUF_0/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_1/U/o               { COMMON/FCX3/SMPL/buffered_dclock1 COMMON/FCX3/SMPL/CLKBUF_1/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_2/U/o               { COMMON/FCX3/SMPL/buffered_dclock2 COMMON/FCX3/SMPL/CLKBUF_2/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_3/U/o               { COMMON/FCX3/SMPL/buffered_dclock3 COMMON/FCX3/SMPL/CLKBUF_3/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_4/U/o               { COMMON/FCX3/SMPL/buffered_dclock4 COMMON/FCX3/SMPL/CLKBUF_4/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_5/U/o               { COMMON/FCX3/SMPL/buffered_dclock5 COMMON/FCX3/SMPL/CLKBUF_5/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_6/U/o               { COMMON/FCX3/SMPL/buffered_dclock6 COMMON/FCX3/SMPL/CLKBUF_6/clock_out }
#@                                               COMMON/FCX3/SMPL/CLKBUF_7/U/o               { COMMON/FCX3/SMPL/buffered_dclock7 COMMON/FCX3/SMPL/CLKBUF_7/clock_out }
#@                                             }
#@                           fcx_regbus_timing     { -ip_transit 0.015 -op_transit 0.015 -top_transit 0.420 }
#@                           timing            {
#@                                                 subchip_mbist_timing
#@                                                 subchip_test_input_stuff
#@                                                 
#@                                                 eval [get_block_info fcx3_oversampler timing]
#@                                                 
#@                                                 eval [get_block_info fcx2_top fcx2_timing]
#@                                                 
#@                                                 # fcx clock and fcxref clock resets
#@                                                 
#@                                                 for {set i 0} {$i<=7} {incr i} {
#@                                                     do_set_input_delay "raw_fcx_resets_$i" -clock_name fcx_clock_$i
#@                                                 }
#@                                                 do_set_input_delay "raw_fcxref_resets" -ip_transit 0.2 -op_transit 0.0 -clock_name fcxref_clock
#@                                                                                                 
#@                                                 # to/from rest of chip                                               
#@                                             
#@                                                 do_set_output_delay {config_ext*}               -clock_name core_clock
#@                                                 do_set_input_delay  {a_pll_status*}             -clock_name core_clock
#@                                                 
#@                                                 # dmfe_core
#@ 
#@                                                 do_set_input_delay  {raw_regbus_request* raw_core_reset} -args [get_block_info fcx2_top fcx_regbus_timing]
#@                                                 do_set_output_delay {regbus_response* to_scheduler*}     -args [get_block_info fcx2_top fcx_regbus_timing]
#@ 
#@                                             }
#@                                             
#@                           fcx2_timing       {
#@                                               
#@                                               set fcx2_top F
#@                                               set fcx_buffers M/U_fcx_buffers
#@                                               if { $design_name == {P6} } {
#@                                                   set mode top
#@                                                   set fcx2_top Q/F
#@                                                   set fcx_buffers Q/M/U_fcx_buffers
#@                                               } elseif { $design_name == [chip_top_name] } {
#@                                                   set mode top
#@                                               } else {
#@                                                   set mode subchip
#@                                               }
#@                                               set num 8
#@ 
#@                                               # delay lines
#@                                               
#@                                                 for {set i 0} {$i<$num} {incr i} {
#@                                                     configure_aldl_with_bist [fixpath $fcx2_top/COMMON/RCVFCX_$i/SDELAY/] [get_clocks fcx_clock_$i] 0.25 -60
#@                                                 }
#@                                                 
#@                                               # Primary I/Os
#@                                                 
#@                                                 set FCX [expr {($mode == "top") ? "FCX" : "fcx_in"}]
#@                                                 
#@                                                 # The load on the clock pins are slightly higher due to the clock mux
#@                                                 # We do not want a buffer before this
#@                                                 global x_loads
#@                                                 set_max_capacitance [expr $x_loads(8) * 20] [get_ports ${FCX}_*]
#@ 
#@                                                 for {set i 0} {$i<$num} {incr i} {
#@                                                     # data signal
#@                                                     set data ${FCX}_[expr $i * 2 + 1]
#@                                                     # sync signal
#@                                                     switch [expr $i % 3] {
#@                                                     0   { set sync ${FCX}_[expr $i*2+2] }
#@                                                     1   { set sync {}}
#@                                                     2   { set sync ${FCX}_[expr $i*2-1] }
#@                                                     }
#@                                                     set fcx "\[get_ports \{$data $sync\}\]"
#@                                                     if { $mode == {top}  } {
#@                                                         set through "-through \[get_pins [fixpath "${fcx_buffers}/U_FCX_*/U/U *_SE_RCV_DATA"]\]"
#@                                                     } else {
#@                                                         set through ""
#@                                                     }
#@                                                     echoed "set_input_delay 0 $fcx -clock vrt_ref0_fcx_clock_$i -add_delay"
#@                                                     echoed "set_multicycle_path 0 -start -setup -from $fcx $through"
#@                                                     echoed "set_multicycle_path 0 -start -hold  -from $fcx $through"
#@                                                 }
#@                                                 set_clock_uncertainty -from [get_clocks vrt_ref0_fcx_clock_*] -to [get_clocks fcx_clock_*] \
#@                                                                       [expr {(($mode == "top") ? 0.300 : 0.370)}]
#@                                                 
#@                                                 for {set i 0} {$i < 3} {incr i} {
#@                                                     set l [expr 3*$i]
#@                                                     set m [expr 3*$i+1]
#@                                                     set u [expr 3*$i+2]
#@                                                     # suppress clock-data into wrong clock 
#@                                                     set_false_path -from [get_clocks "fcx_clock_$m"]                                    \
#@                                                                    -to   [get_clocks "fcx_clock_$l"]
#@                                                     set_false_path -from [get_clocks "vrt_ref0_fcx_clock_$m"]                           \
#@                                                                    -to   [get_clocks "fcx_clock_$l"]
#@                                                                    
#@                                                     if { $u < 8 } {
#@                                                         # suppress data into wrong clock -- u > 7 doesn't exist
#@                                                         set_false_path -from [get_clocks "vrt_ref0_fcx_clock_$m"]                       \
#@                                                                        -to   [get_clocks "fcx_clock_$u"]
#@                                                         set_false_path -from [get_clocks "vrt_ref0_fcx_clock_$u"]                       \
#@                                                                        -to   [get_clocks "fcx_clock_$m"]
#@                                                     }
#@                                                     
#@                                                     # suppress clock-data into monitor flop
#@                                                     set_false_path -from [get_clocks "vrt_ref0_fcx_clock_$l"]                           \
#@                                                                    -to   [get_clocks "core_clock"]
#@                                                 }
#@                                                 
#@                                                 set_false_path -from [get_clocks "fcx_clock_* vrt_ref0_fcx_clock_*"] -to [get_clocks "fcxref_clock_*"]
#@                                                 
#@                                                 set_false_path -from [get_ports ${FCX}*]         -to [get_clocks sdl_test_clock]
#@                                                 set_false_path -from [get_clocks fcx_clock*]     -to [get_clocks sdl_test_clock]
#@                                                 set_false_path -from [get_clocks sdl_test_clock] -to [get_clocks {fcx_clock* core_clock}] 
#@                                                 
#@                                               # And some custom derating on the primary i/o cells
#@                                                 
#@                                                 if { $mode == {top} } {
#@                                                     additional_ocv_derate setup {-cell_delay -early 1.0 [get_cells [fixpath M/U_fcx_buffers/U_FCX_*/U/U]]}
#@                                                     additional_ocv_derate setup {-cell_delay -late  1.0 [get_cells [fixpath M/U_fcx_buffers/U_FCX_*/U/U]]}
#@                                                 }
#@                                             }
#@                           timing_reports    {
#@                                                 alias rtx report_timing  -trans -nosplit -sig 3 -path full_clock_expanded
#@                                                 set timing_remove_clock_reconvergence_pessimism true
#@ 
#@                                                 set cellname {COMMON/FCX3/SMPL}
#@                                                 set s 1
#@                                                 set l {0 0 1}
#@                                                 
#@                                                     if { [get_object_name [current_design]] == [chip_top_name] } {
#@                                                         set cellname "F/$cellname"
#@                                                     }
#@                                                     set cellname [fixpath $cellname]
#@                                                     
#@                                                     # First the actual sampling regs
#@                                                     
#@                                                     map_vendor_pin_names
#@                                                     
#@                                                     for {set s 0} {$s < 8} {incr s} {
#@                                                         # Port to sample regs
#@                                                         rtx -to [fixpath $cellname/RESYNC_$s/U_0_dont_touch_*/$d]
#@                                                         # Sample regs onwards
#@                                                         rtx -through [fixpath $cellname/RESYNC_$s/U_0_dont_touch_*/$q] -delay max 
#@                                                         rtx -through [fixpath $cellname/RESYNC_$s/U_0_dont_touch_*/$q] -delay min 
#@                                                     }
#@                                                     
#@                                                     # Then more transfers
#@                                                     
#@                                                     set regs [get_cells -hier *reg* -filter "full_name =~ $cellname*"]
#@                                                     puts "Total regs in $cellname = [sizeof_collection $regs]"
#@                                                     
#@                                                     foreach l { {0 0 1} {1 0 7} } {
#@                                                         set stage [lfirst $l]
#@                                                         set start [lindex $l 1]
#@                                                         set end   [lindex $l 2]
#@                                                         # And the second transfers
#@                                                         for {set s $start} {$s <= $end} {incr s} {
#@                                                             set regs [remove_from_collection $regs [get_cells [fixpath "$cellname/d${stage}_sampled_reg_${s}_*"]]]
#@                                                             rtx -through [fixpath $cellname/d${stage}_sampled_reg_${s}_*/$q] -delay max
#@                                                             rtx -through [fixpath $cellname/d${stage}_sampled_reg_${s}_*/$q] -delay min
#@                                                         }
#@                                                     }
#@                                                     set regs [remove_from_collection $regs [get_cells * -hier -filter "full_name =~ $cellname*SDELAY*"]]
#@                                                     set regs [remove_from_collection $regs [get_cells [fixpath $cellname/d3_sampled_reg*]]]
#@                                                     set regs [remove_from_collection $regs [get_cells [fixpath $cellname/data_out_reg*]]]
#@                                                     set regs [remove_from_collection $regs [get_cells [fixpath $cellname/*mask*_reg*]]]
#@                                                     
#@                                                     puts "Remaining regs in $cellname = [sizeof_collection $regs]"
#@                                                     
#@                                                 
#@                                             }
#@                           top_level_path    F/
#@                           uniquification_prefix F_
#@                           clock_gating      disabled
#@                         }
#@                         
#@     fcx3_oversampler     {lib               pqx6
#@                           subblocks         { aldl_wrapper_with_bist_monitor }
#@                           default_clock     fcxref_clock
#@                           generics          { NUM_STREAMS 8 }
#@                           clock_portnames   { fcxref_clock_raw      clock_raw
#@                                               fcxref_clock          clock
#@                                               core_clock            no_core_clock_present
#@                                             }
#@                           timing            {
#@                                                 set cellname_suffix {}
#@                                                 set aldl_type       with_bist
#@                                                 
#@                                                 if { $design_name == {P6} } {
#@                                                     set mode top
#@                                                     set cellname    Q/F/COMMON/FCX3/SMPL/
#@                                                     set fcx_buffers Q/M/U_fcx_buffers
#@                                                 } elseif { $design_name == [chip_top_name] } {
#@                                                     set mode top
#@                                                     set cellname    F/COMMON/FCX3/SMPL/
#@                                                     set fcx_buffers M/U_fcx_buffers
#@                                                 } elseif { $design_name == "fcx2_top" } {
#@                                                     set mode subchip
#@                                                     set cellname {COMMON/FCX3/SMPL/}
#@                                                 } elseif { [string match "fcx2_rx_common*" $design_name] } {
#@                                                     set mode other
#@                                                     set cellname {FCX3/SMPL/}
#@                                                 } else {
#@                                                     set mode other
#@                                                     # e.g. fcx3_oversampler, fcx3_oversampler_alt
#@                                                     set cellname {}
#@                                                     
#@                                                     if { $design_name == "fcx3_oversampler_alt" } {
#@                                                         # fcx3_oversampler_alt
#@                                                         set cellname_suffix ALDL
#@                                                         set aldl_type       simple
#@                                                     }
#@                                                     
#@                                                     mickey_mouse_test_input_stuff
#@                                                     mickey_mouse_input_timing
#@                                                     mickey_mouse_output_timing
#@                                                     
#@                                                     set_max_delay  1.0 -from [get_ports a_config_DELAY_LINE_*]
#@                                                     set_min_delay -1.0 -from [get_ports a_config_DELAY_LINE_*]
#@                                                     
#@                                                     set test_ports [get_ports sdl_func_clock_sel]
#@                                                     set_max_delay  2.0 -from $test_ports
#@                                                     set_min_delay -2.0 -from $test_ports
#@                                                 }
#@                                                 
#@                                                 
#@                                                     # create generated clocks
#@                                                     
#@                                                     # fcxref_clocks need to correlate with cellnames 
#@                                                     
#@                                                     if { $mode == "top" } {
#@                                                         if { [get_cells [fixpath ${cellname}*]] == {} } {
#@                                                             puts "Warn\ing: '$cellname' appears to be missing - skipping all fcx3_oversampler config"
#@                                                             return
#@                                                         }
#@                                                         set src_clock [get_clocks fcxref_clock]
#@                                                     } else {
#@                                                         set src_clock [get_clocks fcxref_clock_raw]
#@                                                     }
#@                                                     set clock [get_clocks fcxref_clock]
#@                                                     
#@                                                     set source_pin [get_attribute $src_clock sources]
#@                                                     if { [sizeof_collection $source_pin] > 1 } {
#@                                                         set source_pin [filter_collection $source_pin "(full_name =~ *raw* || full_name =~ *o_aux_clkout_div2_p)"]
#@                                                     }
#@                                                     
#@                                                     map_vendor_pin_names
#@                                                     
#@                                                     foreach clk { {ovs 0} } {
#@                                                         set name "fcxref_clock_[lfirst $clk]"
#@                                                         create_generated_clock -name            $name                           \
#@                                                                                -divide_by       1                               \
#@                                                                                -master_clock    $src_clock                      \
#@                                                                                -source          $source_pin                     \
#@                                                                                -add                                             \
#@                                                                 [fixpaths "${cellname}SDELAY_0/U/ALDL/SRCMUX_dont_touch/$ck0     \
#@                                                                            ${cellname}SDELAY_1/U/ALDL/SRCMUX_dont_touch/$ck0"]
#@                                                         set_propagated_clock $name
#@                                                         set_clock_uncertainty 0.200 [get_clocks $name]
#@                                                         set_clock_uncertainty 0.200 -from $name -to $clock
#@                                                     }
#@                                                     
#@                                                     # Basic 8 phases: SDELAY_0:   0 250 500 750 ( 0, 90, 180, 270 degrees)
#@                                                     #                 SDELAY_1: 125 375 625 875 (45,135, 225, 315 degrees)
#@                                                     # offset by 100 (due to input buffer delay)
#@                                                     
#@                                                     configure_aldl_${aldl_type} [fixpath ${cellname}SDELAY_0/${cellname_suffix}] $src_clock {0.000 0.250 0.500 0.750} 100.0
#@                                                     configure_aldl_${aldl_type} [fixpath ${cellname}SDELAY_1/${cellname_suffix}] $src_clock {0.125 0.375 0.625 0.875} 100.0
#@                                                     
#@                                                     check_mapped [fixpath ${cellname}d1_sampled_reg_0_0]
#@                                                     
#@                                                     foreach grp {0 1} {
#@                                                         set_multicycle_path 0 -setup -from    [get_clocks $name]                                                \
#@                                                                                      -through [get_cells [fixpath ${cellname}RESYNC_${grp}/U_0_dont_touch_*]]   \
#@                                                                                      -to      [get_pins [fixpath ${cellname}d0_sampled_reg_${grp}_*/$d]]
#@                                                     }
#@                                                     foreach grp {2 3} {
#@                                                         # For these two (only) we can adjust the hold uncertainty
#@                                                         global analysis_type
#@                                                         if { [regexp bc $analysis_type]} {
#@                                                             set_clock_uncertainty 0.060 -hold [fixpath ${cellname}d1_sampled_reg_${grp}_*/$phi]
#@                                                         } else {
#@                                                             set_clock_uncertainty 0.100 -hold [fixpath ${cellname}d1_sampled_reg_${grp}_*/$phi]
#@                                                         }
#@                                                     }
#@                                                     
#@                                                     global running_design_compiler_topographical
#@                                                     if { $running_design_compiler_topographical } {
#@                                                         set net_path [fixpath ${cellname}CLKINV*/U]
#@                                                         echoed "remove_ideal_network ${net_path}/$o"
#@                                                     }
#@                                                     
#@                                                     if { $cellname != {} } {
#@                                                         set_false_path -from [get_clocks fcxref_clock_ovs] -to [get_clocks {fcx_clock_*}]
#@                                                     }
#@ 
#@                                                 
#@                                                 unset source_pin
#@                                                 # and some interclock paths
#@                                                 set_false_path -from [get_clocks fcxref_clock* ] -to [get_clocks sdl_test_clock]
#@                                                 set_false_path -from [get_clocks sdl_test_clock] -to [get_clocks fcxref_clock* ]
#@                                                 
#@                                                 suppressed {SEL-004 UID-95} {
#@                                                     # Half a baud period
#@                                                     set del 0.5
#@                                                     if { $mode == "top" } {
#@                                                         set ip_ports [get_ports "FCX*"]
#@                                                         # Correct for input delay of FCX signals to fcx2_top  block
#@                                                         # SPONG: might need to be different for bc 
#@                                                         set del [expr $del - 0.3]
#@                                                     } else {
#@                                                         set ip_ports [get_ports "fcx_diff_in* data_in*"]
#@                                                     }
#@                                                     set_input_delay $del $ip_ports -clock fcxref_clock_ovs -add_delay
#@                                                 }
#@                                                 
#@                                                 if { $mode != "top" } {
#@                                                     set_multicycle_path -from $ip_ports -hold 1
#@                                                 } else {
#@                                                     set_multicycle_path -from $ip_ports -hold 1 -through [get_pins [fixpath "${fcx_buffers}/U_FCX_*/U/U DIFF_RCV_DATA_P"]]
#@                                                 }
#@ 
#@                                                 if  { $mode != "top" } {
#@                                                     # The load on the clock pins are slightly higher due to the clock mux
#@                                                     # We do not want a buffer before this
#@                                                     global x_loads
#@                                                     set_max_capacitance [expr $x_loads(8) * 2] $ip_ports
#@                                                 
#@                                                     my_set_ideal_net "\[get_nets \[all_connected \[get_ports {sdl_test_clock}\] \] \]"
#@                                                 }
#@                                             }
#@                           clock_gating      disabled
#@                         }
#@                         
#@     fcx3_oversampler_alt {
#@                           default_clock     fcxref_clock
#@                           clock_portnames   { fcxref_clock      clock*
#@                                               core_clock        no_core_clock_present}
#@                           fixed_netnames    {
#@                                               CLKBUF_0/U/A               { dclock_0 CLKBUF_0/clock_in }
#@                                               CLKBUF_1/U/A               { dclock_1 CLKBUF_1/clock_in }
#@                                               CLKBUF_2/U/A               { dclock_2 CLKBUF_2/clock_in }
#@                                               CLKBUF_3/U/A               { dclock_3 CLKBUF_3/clock_in }
#@                                               CLKBUF_4/U/A               { dclock_4 CLKBUF_4/clock_in }
#@                                               CLKBUF_5/U/A               { dclock_5 CLKBUF_5/clock_in }
#@                                               CLKBUF_6/U/A               { dclock_6 CLKBUF_6/clock_in }
#@                                               CLKBUF_7/U/A               { dclock_7 CLKBUF_7/clock_in }
#@ 
#@                                               CLKBUF_0/U/Q               { buffered_dclock2 CLKBUF_0/clock_out }
#@                                               CLKBUF_1/U/Q               { buffered_dclock2 CLKBUF_1/clock_out }
#@                                               CLKBUF_2/U/Q               { buffered_dclock2 CLKBUF_2/clock_out }
#@                                               CLKBUF_3/U/Q               { buffered_dclock3 CLKBUF_3/clock_out }
#@                                               CLKBUF_4/U/Q               { buffered_dclock3 CLKBUF_4/clock_out }
#@                                               CLKBUF_5/U/Q               { buffered_dclock3 CLKBUF_5/clock_out }
#@                                               CLKBUF_6/U/Q               { buffered_dclock6 CLKBUF_6/clock_out }
#@                                               CLKBUF_7/U/Q               { buffered_dclock7 CLKBUF_7/clock_out }
#@                                             }                             
#@                           timing            { eval [get_block_info fcx3_oversampler timing] }
#@                           clock_gating      disabled
#@                         }
#@                         
#@     # {lcp_TOP subchip}
#@     
#@     lcp_top                     { timing        {
#@     
#@                                                 map_vendor_pin_names
#@                                                 set lcptop {L/}
#@                                                   
#@                                                 # lcpref_clock primary inputs (actually both resynchronised)
#@                                                 
#@                                                     if { $design_name == "lcp_top" } {
#@                                                         subchip_test_input_stuff
#@                                                         my_set_ideal_net "\[get_nets \[all_connected \[get_ports lcp_test_clock\] \] \]"
#@                                                     }
#@                                                     
#@                                                     if { $design_name == "lcp_top" } {
#@                                                         set ports [get_ports {lcp_request_ERR lcp_wide_mode}]
#@                                                         remove_input_delay $ports
#@                                                         set_max_delay  2.0 -from $ports
#@                                                         set_min_delay -2.0 -from $ports
#@                                                     } else {
#@                                                         set ports [get_ports {LCPOUTERR LCPWIDEMODE}]
#@                                                         remove_input_delay $ports
#@                                                         set_max_delay 15.0 -from $ports
#@                                                         set_min_delay -3.0 -from $ports
#@                                                     }
#@ 
#@                                                 # lcpref_clock primary outputs
#@                                                   
#@                                                     if { $design_name == "lcp_top" } {
#@                                                        #do_set_output_delay {lcp_response_*} -comment "primary out lcp40g" -args $lcpref_args -op_transit 0.110 -ip_transit 0.8 -ip_ff 0.0 -group "lcpref_primary_outputs"
#@                                                         do_set_output_delay {lcp_response_*} -comment "primary out lcp40g" -op_transit 0.0 -clock_name lcpref_clock -group "lcpref_primary_outputs"
#@                                                     } else {
#@                                                         set_max_delay 4.0 -to [get_ports LCPOUTAD_*]
#@                                                         set_max_delay 4.0 -to [get_ports LCPINERR]
#@                                                         set_max_delay 4.0 -to [get_ports LCPOUT*CLK]
#@                                                     }
#@ 
#@                                                 # lcprx_clock (propagated)
#@                                                                                                     
#@                                                     if { $design_name == "lcp_top" } {
#@                                                         set lcprx_input_clock_uncertainty 0.050
#@                                                         set lcprx_p_to_n_uncertainty      0.300
#@                                                     } else {
#@                                                         set lcprx_input_clock_uncertainty 0.000
#@                                                         set lcprx_p_to_n_uncertainty      0.250
#@                                                         # this because the period at top level is very relaxed
#@                                                     }
#@ 
#@                                                     set_clock_uncertainty $lcprx_input_clock_uncertainty -from vrt_ref0_lcprx_clock   -to lcprx_clock
#@                                                     set_clock_uncertainty $lcprx_input_clock_uncertainty -from vrt_ref0_lcprx_p_clock -to lcprx_p_clock
#@                                                     set_clock_uncertainty $lcprx_p_to_n_uncertainty      -from lcprx_clock            -to lcprx_p_clock
#@                                                     set_clock_uncertainty $lcprx_p_to_n_uncertainty      -from lcprx_p_clock          -to lcprx_clock
#@                                                     
#@                                                     # Note calculated propogated tree latency is this value + 60 ps per CTUN, ie. we are guessing 120 ps for buffered_n_clock
#@                                                     # n_clock -> buffered_n_clock
#@                                                     # set_cts_delay {0.060 0.030} [fixpath "${lcptop}LCP40G/fe/NCLKBUFIN/U/$o"]
#@                                                     # p_clock -> buffered_p_clock
#@                                                     # set_cts_delay {0.060 0.030} [fixpath "${lcptop}LCP40G/fe/PCLKBUFIN/U/$o"]
#@                                                     # buffered_n_clock -> 'late' lcprx_clock (yes, buffer ref des is inappropriate)
#@                                                     
#@                                                     # CTS DELAY BELOW is a complete guess for Q6
#@                                                     set_cts_delay {0.060 0.040} [fixpath "${lcptop}LCP40G/fe/PCLKBUFMAIN/U/$o"]
#@                                                     
#@                                                     # lcprx_clock, lcprx_p_clock primary inputs - specify setup/hold
#@                                                     # And set expected input transit similar to clock input transit - for DC use only
#@                                                     
#@                                                     if { $design_name == "lcp_top" } {
#@                                                         do_source_set_input_delay {lcp_request_AD_?} ref0_lcprx_clock   {0.0 0.0} {0.100 0.100} 0.0 "lcp_input_n_clock"
#@                                                         do_source_set_input_delay {lcp_request_AD_?} ref0_lcprx_p_clock {0.0 0.0} {0.100 0.100} 0.0 "lcp_input_p_clock" {} -add
#@                                                     } else {
#@                                                         do_source_set_input_delay {LCPINAD_?}        ref0_lcprx_clock   {0.0 0.0} {0.125 0.125} 0.0 "lcp_input_n_clock"
#@                                                         do_source_set_input_delay {LCPINAD_?}        ref0_lcprx_p_clock {0.0 0.0} {0.125 0.125} 0.0 "lcp_input_p_clock" {} -add
#@                                                     }
#@ 
#@                                                     # This ensures vrt_lcprx_ input delays time only to the correct lcprx_ capture clocks (which is why this interface has vrt_ clocks with latency set 0)
#@                                                     set_false_path -from [get_clocks vrt_ref0_lcprx_clock]   -to [get_clocks lcprx_p_clock]  
#@                                                     set_false_path -from [get_clocks vrt_ref0_lcprx_p_clock] -to [get_clocks lcprx_clock]
#@ 
#@                                                 # Strictly a true ASYNC input
#@                                             
#@                                                     # Note -add since this there is already an lcpref_clock constraint on this input
#@                                                   
#@                                                     if { $design_name == "lcp_top" } {
#@                                                         set_input_delay 0.5 [get_ports async_reset]  -clock virtual_lcpref_clock
#@                                                         set_max_delay 1.1 -from [get_ports async_reset]
#@                                                         set_min_delay 0   -from [get_ports async_reset]
#@                                                     } else {
#@                                                         set_input_delay 0 [get_ports Z_RESET] -clock virtual_lcpref_clock
#@                                                         set_max_delay  1.0 -from [get_ports Z_RESET]
#@                                                         set_max_delay 15.0 -from [get_ports Z_RESET] -through [fixpath {M/U_misc_buffers Z_RESET_z}]
#@                                                         set_max_delay 20.0 -from [get_ports Z_RESET] -through [fixpath {M/U_misc_buffers Z_RESET_nj_z}]
#@                                                     }
#@ 
#@                                                 # gp_regs async inputs, outputs - not time critical - to be fixed up in q2 by async retime and improved script
#@                                               
#@                                                     if { $design_name == "lcp_top" } {
#@                                               
#@                                                         # at 600 or 800MHz we just can't meet timing here in a single cycle anymore. but since these are async, MCP should be okay.
#@                                                         # MCP is a timing exception so still need a bogus output/input delay constraint.
#@ 
#@                                                         set ports {a_gp_regs_in* sbus_master_resp* jtag_id*}
#@                                                         set_input_delay     0 -clock [get_clocks {virtual_lcpref_clock}] $ports
#@                                                         set_multicycle_path 2 -setup -from [get_ports $ports]
#@                                                         set_multicycle_path 2 -hold  -from [get_ports $ports]
#@ 
#@                                                         set ports {lcpref_gp_regs_out* sbus_master_req*}
#@                                                         set_output_delay    0 -clock [get_clocks {virtual_lcpref_clock}] $ports
#@                                                         set_multicycle_path 2 -setup -to [get_ports $ports]
#@                                                         set_multicycle_path 2 -hold -to [get_ports $ports]
#@                                                     
#@                                                     }
#@                                                     
#@                                                 # Core signals
#@                                                 
#@                                                     if { $design_name == "lcp_top" } {
#@                                                         do_set_input_delay  {raw_core_lcp40g_slave_resp_0_* raw_core_lcp40g_master_request* A_core_reset*} -args [get_block_info ecp_top LE_to_LE_timing]
#@                                                         do_set_output_delay {core_lcp40g_slave_req_0_*      core_lcp40g_master_response*  core_reset_out*}  -args [get_block_info ecp_top LE_to_LE_timing]
#@ 
#@                                                         do_set_input_delay  {raw_core_lcp40g_slave_resp_1_* } -args [get_block_info scheduler_plus_top sched_plus_to_lcp_timing]
#@                                                         do_set_output_delay {core_lcp40g_slave_req_1_*      } -args [get_block_info scheduler_plus_top lcp_to_sched_plus_timing]
#@                                                       # do_set_output_delay core_lcp40g_master_response_RESP_TGL -op_ff 0.140 -op_transit 
#@                                                     }
#@                                                     
#@                                                 }
#@                                   map_effort  high
#@                                   top_level_path        L/
#@                                   uniquification_prefix L_
#@                                   clock_gating          disabled
#@                                 }
#@     
#@     # {Statistics_block subchip}
#@     
#@     statistics_block            { special_ram_uncertainties  {
#@                                                       set_ram_clocks_advance_for_synthesis                 0.050
#@                                                     }
#@                                   timing            {
#@                                                       subchip_test_input_stuff
#@                                                       subchip_mbist_timing
#@ 
#@                                                       #disable_memoir_power_gating_paths
#@                                                       eval $block_info(special_ram_uncertainties)
#@ 
#@                                                       group_path -name no_input_group  -from [all_inputs]
#@                                                       group_path -name no_output_group -to   [all_outputs]
#@ 
#@                                                       # This includes raw_reset - timed to FFs in reset resync - need more margin for PC?
#@                                                       do_set_input_delay  {raw_*}            -comment "raw_ inputs"
#@ 
#@                                                       do_set_output_delay {core_resets_out*} -comment "core resets"
#@                                                     # do_set_output_delay {northbound_out*}  -comment "northbound feedthrough outputs"
#@ 
#@                                                         do_set_output_delay {data_out*}        -comment "data_out"
#@                                                     #   do_set_output_delay {southbound_out*}  -comment "southbound feedthrough outputs"
#@ 
#@                                                       # These ports are tied off at top level
#@                                                       set_max_delay  2.0 -from [get_ports {block_num* last_block* src_data_in*}]
#@                                                       set_min_delay -2.0 -from [get_ports {block_num* last_block* src_data_in*}]
#@                                                     }
#@                                   uniquification_prefix T_
#@                                   top_level_path    {T*/}
#@                                 }
#@ 
#@ 
#@     statistics_block_x2         { subblocks         { statistics_block }
#@ 
#@                                   stats_feedthrough_timing {}
#@                                   stats_data_timing  { -ip_transit 0.100                    -op_transit 0.100 }
#@                                   stats_shunt_timing { -ip_transit 0.180 -top_transit 0.090 -op_transit 0.180 }
#@ 
#@                                   timing            {
#@                                                       subchip_test_input_stuff
#@                                                       subchip_mbist_timing
#@ 
#@                                                       eval [get_block_info statistics_block special_ram_uncertainties]
#@ 
#@                                                       set_max_delay  0.350 -from [get_ports async_reset]
#@                                                       set_min_delay -0.350 -from [get_ports async_reset]
#@ 
#@                                                       do_set_output_delay {core_reset_out}
#@ 
#@                                                       set ports {block_num* last_block src_data_in*}
#@                                                       set_cmp_for_block_config_port $ports 
#@ 
#@                                                       do_set_input_delay  {raw_data_in*               } -args [get_block_info statistics_block_x2 stats_data_timing]
#@                                                       do_set_output_delay {data_out* alt_response_out*} -args [get_block_info statistics_block_x2 stats_data_timing]
#@ 
#@                                                       do_set_input_delay  {raw_ss_data_in*}             -args [get_block_info statistics_block_x2 stats_shunt_timing]
#@                                                       do_set_output_delay {ss_data_out*   }             -args [get_block_info statistics_block_x2 stats_shunt_timing]  
#@             
#@                                                     # do_set_input_delay  {raw_eastbound*}              -args [get_block_info statistics_block_x2 stats_feedthrough_timing]
#@                                                     # do_set_output_delay {eastbound_out*}              -args [get_block_info statistics_block_x2 stats_feedthrough_timing]
#@ 
#@                                                     }
#@                                   top_level_path    {T*/}
#@                                 }
#@ 
#@     statistics_core             { subblocks         { statistics_addr_calc
#@                                                     }
#@                                   timing            { 
#@                                                       eval [get_block_info default timing]
#@                                                       set_input_delay  0.70 -clock core_clock regbus_request*
#@                                                     }
#@                                 }
#@                               
#@     # {DMFE_BUFFER subchip}
#@     
#@     dmfe_buffer         {   subblocks         { }
#@                             timing            {
#@                                                 eval [get_block_info default timing]
#@                                                 
#@                                                 set_input_delay     -clock core_clock 0.220 [get_ports raw_ram_responses_*]
#@                                                 
#@                                                 do_set_output_delay {ram_requests_out_DMFE_RDQ_B_WR_DATA_ECC_*} -op_transit 0.000 -op_logic 0.150
#@                                                 
#@                                                 do_set_output_delay {ram_requests_out_DMFE_BUF_*_WR_DATA*}      -op_transit 0.000 -op_logic 0.250
#@                                                 
#@                                               }
#@                         }
#@                         
#@     dmfe_buffer_top     {   subblocks       { dmfe_buffer }
#@ 
#@                             dmbuf_horizontal_timing     {}
#@                             dmbuf_northside_timing      { -ip_transit 0.152 -top_transit 0.040 -op_transit 0.258 }
#@                             dmbuf_southside_in_timing   { -ip_transit 0.320 -top_transit 0.065 -op_transit 0.075 }
#@                             dmbuf_southside_out_timing  { -ip_transit 0.075 -top_transit 0.065 -op_transit 0.320 }
#@   
#@                             dmbuf_south_reset_timing    { -ip_transit 0.100 -top_transit 0.085 -op_transit 0.230 }
#@                             dmbuf_north_reset_timing    { -ip_transit 0.100 -top_transit 0.050 -op_transit 0.100 }
#@ 
#@                             dmfe_core_to_dmbuf_timing   { -ip_transit 0.410                    -op_transit 0.050 }
#@                             dmbuf_to_dmfe_core_timing   { -ip_transit 0.050                    -op_transit 0.410 }
#@   
#@                             dp_to_dmbuf_timing          { -ip_transit 0.300                    -op_transit 0.160 }
#@                             dmbuf_to_dp_timing          { -ip_transit 0.160                    -op_transit 0.300 }
#@ 
#@                             special_ram_uncertainties  {
#@                                                       set_ram_clocks_advance_for_synthesis                 0.075
#@                                             }
#@                             timing          { 
#@                                             # All simple subchips should normally use these few ...
#@                                           
#@                                                 subchip_test_input_stuff
#@                                                 subchip_mbist_timing
#@                                                 eval $block_info(special_ram_uncertainties)
#@                                                 
#@                                             # ... and often this one ...
#@                                                                           
#@                                                 # disable_memoir_211hd_cka_ckb_paths
#@                                                 
#@                                             # Then we need the block specific functional i/o constraints 
#@                                             # (Every functional port must be constrained)
#@ 
#@                                                 #resets
#@                                                 do_set_input_delay  {raw_core_reset_south}  -args [get_block_info dmfe_buffer_top dmbuf_south_reset_timing]
#@                                                 do_set_input_delay  {raw_core_reset_north}  -args [get_block_info dmfe_buffer_top dmbuf_north_reset_timing]
#@                                                 do_set_output_delay {dmbuf_reset_out }      -args [get_block_info dmfe_buffer_top dmbuf_north_reset_timing]
#@ 
#@                                                 #dmfe core
#@                                                 do_set_input_delay  {raw_from_dmfe_0_* raw_from_dmfe_1_* raw_from_dmfe_2_* raw_from_dmfe_3_* raw_dmfe_regbus_response* } -args [get_block_info dmfe_buffer_top dmfe_core_to_dmbuf_timing]
#@                                                 do_set_output_delay {to_dmfe_0_*       to_dmfe_1_*       to_dmfe_2_*       to_dmfe_3_*       dmfe_regbus_request*      } -args [get_block_info dmfe_buffer_top dmbuf_to_dmfe_core_timing]
#@ 
#@                                                 do_set_input_delay  {raw_lcp40g_request*  } -args [get_block_info dmfe_buffer_top dmbuf_horizontal_timing]
#@                                                 do_set_output_delay {lcp40g_response_out* } -args [get_block_info dmfe_buffer_top dmbuf_horizontal_timing]
#@ 
#@                                                 #datapath
#@                                                 do_set_input_delay  {raw_from_dm_* } -args [get_block_info dmfe_buffer_top dp_to_dmbuf_timing]
#@                                                 do_set_output_delay {to_dm_*       } -args [get_block_info dmfe_buffer_top dmbuf_to_dp_timing]
#@ 
#@                                                 # if { [suppressed {UID-95 SEL-004 SEL-005} {get_ports raw_from_dmfe_4_*}] != {} } {
#@                                                 #     # Remote dmfes
#@                                                 #     do_set_input_delay  {raw_from_dmfe_4_* raw_from_dmfe_5_* raw_from_dmfe_6_* raw_from_dmfe_7_* } -args [get_block_info dmfe_buffer_top dp_to_dmbuf_remote_timing]
#@                                                 #     do_set_output_delay {to_dmfe_4_*       to_dmfe_5_*       to_dmfe_6_*       to_dmfe_7*        } -args [get_block_info dmfe_buffer_top dmbuf_to_dp_remote_timing]
#@                                                 # }
#@ 
#@                                                 do_set_output_delay {dm_regbus_request*      lcp40g_request_out*  datapath_reset_out} -args [get_block_info dmfe_buffer_top dmbuf_horizontal_timing]
#@                                                 do_set_input_delay  {raw_dm_regbus_response* raw_lcp40g_response*                   } -args [get_block_info dmfe_buffer_top dmbuf_horizontal_timing]
#@ 
#@                                                 #vertical
#@                                                 do_set_input_delay  {raw_from_dmbuf_north*                            } -args [get_block_info dmfe_buffer_top dmbuf_northside_timing]
#@                                                 do_set_output_delay {to_dmbuf_north*                                  } -args [get_block_info dmfe_buffer_top dmbuf_northside_timing]
#@ 
#@                                                 do_set_input_delay  {raw_from_dmbuf_south* raw_regbus_request_south* } -args [get_block_info dmfe_buffer_top dmbuf_southside_in_timing]
#@                                                 do_set_output_delay {to_dmbuf_south*        regbus_response_south*   } -args [get_block_info dmfe_buffer_top dmbuf_southside_out_timing]
#@                                                 
#@                                                 eval [get_block_info dmfe_buffer_top more_timing]
#@                                             }
#@                           more_timing       {
#@                                                 # SPONG: Need a top level version of this code too.
#@                                                 set ports {alt_ft_mode base_torrent local_index}
#@                                                 set_cmp_for_block_config_port $ports 
#@                                             }
#@                           physical_compile  {
#@                                                 set suppress_dmfe_buffer_top_multicycle_paths false
#@                                                 eval [get_block_info dmfe_buffer_top more_timing]
#@                                                 compile_ultra -spg -incremental -no_seq_output_inversion
#@                                             }
#@                           physical_compile_incr  {
#@                                                 compile_ultra -spg -incremental -no_seq_output_inversion
#@                                                 write -hierarchy -format $format -output ${output_file_base}-INTERMEDIATE.$format
#@                                                 compile_ultra -spg -incremental -no_seq_output_inversion
#@                                             }
#@                           uniquification_prefix C_
#@                           top_level_path        {C*/}
#@                         }
#@ 
#@     dm_slice_controller {   subblocks         { dm_slice_sequencer dm_slice_scheduler }
#@                             timing            {
#@                                                 eval [get_block_info default timing]
#@                                                 disable_memoir_211hd_cka_ckb_paths
#@                                                 
#@                                                 set_output_delay 0.3 to_dm_DM_SCHED_STATUS* -clock core_clock
#@                                               
#@                                               }
#@                            #post_ungroup      { ungroup_* }
#@                         }
#@ 
#@     dm_slice_scheduler  {
#@                         }
#@     dm_slice_sequencer  {
#@                         }
#@ 
#@     # {Datapath subchip}
#@     
#@     dm_output_controller_element {
#@                            timing         {   eval [get_block_info default timing]
#@                                               set_input_delay  -clock core_clock 0.55 [all_inputs] 
#@                                           }
#@     
#@                          }
#@     dm_output_controller_cluster {
#@                            subblocks      { dm_output_controller_element
#@                                           }
#@                            timing         {   eval [get_block_info default timing]
#@                                               set_input_delay  -clock core_clock 0.45 [all_inputs] 
#@                                           }
#@                          }
#@     dm_output_controller { subblocks      { dm_output_controller_cluster
#@                                           }
#@                            timing          {
#@                                             eval [get_block_info default timing]
#@                                             set_input_delay  -clock core_clock 0.35 in_rbuf_data*
#@                                             set_input_delay  -clock core_clock 0.35 in_rbuf_avail_xslices*
#@                                             set_input_delay  -clock core_clock 0.35 in_slice_rd_bp_xslices*
#@                                           }
#@                          #post_ungroup    { ungroup_* }
#@                          #compile2        {
#@                                             # Annoyingly the Designware parity generators in the ECC blocks do not generate balanced trees 
#@                                             # We get good results by compiling those hard. But as they don't exist prior to this block's main
#@                                             # compile, we have to mess around _after_ the first compile.
#@                                           
#@                                             set dname [get_object_name [current_design]]
#@                                             set designs [map_collection d [get_designs ${dname}*par_gen*] { get_object_name $d }]
#@                                             foreach des $designs {
#@                                                 current_design $des
#@                                                 source timing.tcl
#@                                                 set_max_delay 0.37 [all_outputs]
#@                                                 compile -map_effort high -area_effort high
#@                                             }
#@                                             current_design $dname
#@                                             link
#@                                             eval [get_block_info default compile2_auto]
#@                                           }
#@                         }
#@ 
#@     dm_input_controller { #compile2       { eval [get_block_info dm_output_controller compile2] }
#@                           timing          {
#@                                             eval [get_block_info default timing]
#@                                             set_input_delay  -clock core_clock 0.35 in_release_wbuf_xslices*
#@                                             set_input_delay  -clock core_clock 0.35 in_slice_wr_bp_xslices*
#@                                           }
#@                         }
#@                         
#@     dm_top              { subblocks       { dm_input_controller
#@                                             dm_output_controller
#@                                             dm_address_translator
#@                                           }
#@                           timing          {
#@                                             eval [get_block_info default timing]
#@                                             set_input_delay  -clock core_clock 0.35 from_dmsc*
#@                                           }
#@                         }
#@     
#@     input_resegmenter_top { subblocks     {input_resegmenter 
#@                                           }
#@                            post_ungroup   {input_resegmenter
#@                                           }
#@                             timing        {
#@                                             eval [get_block_info default timing]
#@                                           }
#@                                           }
#@     
#@     datapath            { subblocks       {
#@                                             frame_source_mux
#@                                             input_resegmenter_top
#@                                             dm_top
#@                                             output_resegmenter
#@                                             datapath_regbank
#@                                             statistics_core
#@                                             dm_slice_controller
#@                                           }
#@                           DP_to_DMSC_timing { -top_transit 0.080 -op_transit 0.200 -ip_transit 0.200 -ip_logic 0.050}
#@                           DMSC_to_DP_timing { -top_transit 0.080 -ip_transit 0.200 }
#@                           P_Block_Timings   { -top_transit 0.300 -ip_transit 0.080 -op_transit 0.080}
#@                           mbist_block_timing { core_clock 10 }
#@                           timing          {
#@                                             subchip_test_input_stuff
#@                                             subchip_mbist_timing
#@                                           
#@                                             # Static ports with mcp regs inside
#@                                             
#@                                             set ports {torrent_index}
#@                                             set_cmp_for_block_config_port $ports 
#@ 
#@                                                 set_input_delay 0 {disable_mem2mem_paths} -clock [virtual? core_clock]
#@                                                 set_multicycle_path 3 -setup -hold -from {disable_mem2mem_paths}
#@                                                 
#@                                             # All these inputs get the core_clock default input delay:
#@                                                  
#@                                                 do_set_input_delay {raw_from_qmgr*
#@                                                                     raw_from_ecp*   
#@                                                                     raw_from_d1_to_d0*  
#@                                                                     raw_from_d0_to_d1*  
#@                                                                     raw_from_scheduler*
#@                                                                     } -comment "SVW/Q to D0" -args [get_block_info dmfe_buffer_top dmbuf_southside_in_timing] -group SVW_to_D0
#@                                                 
#@                                                 do_set_output_delay { to_ecp*
#@                                                                       to_qmgr*
#@                                                                       to_scheduler*
#@                                                                       t5_to_sched_out*
#@                                                                       d1_to_d0_out*
#@                                                                       d0_to_d1_out*
#@                                                                  } -comment "D0 to SVW/Q"      -args [get_block_info dmfe_buffer_top dmbuf_southside_out_timing]   -group D0_to_SVW
#@                                                                  
#@                                                 set stats_input_ports_list  {
#@                                                                             raw_from_stats*
#@                                                                            }
#@                                               
#@                                                 set control_wing_input_ports {raw_from_xpl2_rx*
#@                                                                               raw_lcp40g_response_*
#@                                                                               }
#@                                                 set dmbuf_input_ports_slow_list  {
#@                                                                             raw_core_reset      
#@                                                                             raw_regbus_request*
#@                                                                             raw_lcp40g_request*
#@                                                                            }
#@ 
#@                                                 set dmbuf_input_ports_timings {
#@                                                                             raw_from_dmfe_*
#@                                                                             }
#@                                                                             
#@                                                 set t5_chip_ingres_input_ports {
#@                                                                                 raw_t5_to_sched*  
#@                                                                                 raw_from_xpl2_tx*
#@                                                                              }
#@                                                                              
#@                                                 # set dmbuf_input_ports_to_remote_dmfe {
#@                                                 #                                     raw_to_remote_dmfe*
#@                                                 #                                     }
#@                                                 # and the following                   raw_from_remote_dmfe*
#@                                                 #                                     to_remote_dmfe*
#@                                                 #set remote_dmfe_to_dmbuf_output {
#@                                                 #                                from_remote_dmfe*  
#@                                                 #                                }
#@                                                  
#@                                                 do_set_input_delay $t5_chip_ingres_input_ports   -comment "t5 ingress input ports" -args [get_block_info datapath P_Block_Timings]              -group "t5 ingress input ports"                        
#@                                                 do_set_input_delay $stats_input_ports_list       -comment "standard raw_ in - stats" -args [get_block_info datapath P_Block_Timings]              -group "x1_inputs - stats"
#@                                                 do_set_input_delay $control_wing_input_ports     -comment "control wing input ports" -args [get_block_info datapath P_Block_Timings]              -group "control wing input ports"
#@                                                 do_set_input_delay $dmbuf_input_ports_timings    -comment "dmbuf raw inputs" -args [get_block_info dmfe_buffer_top dmbuf_to_dp_timing]            -group "dmbuf_inputs"
#@                                                 do_set_input_delay $dmbuf_input_ports_slow_list  -comment "dmbuf raw inputs slow" -args [get_block_info dmfe_buffer_top dmbuf_horizontal_timing]     -group "dmbuf_inputs slow"
#@ 
#@                                             # All these outputs get the core_clock default output delay
#@                                             
#@                                                 set stats_output_ports_list  {
#@                                                                              to_stats*
#@                                                                              stats_reset_out
#@                                                                             }
#@                                                 set control_wing_output_ports {
#@                                                                                to_xpl2_rx*
#@                                                                                lcp40g_request_out*
#@                                                                               }
#@                                                 set t5_chip_ingres_output_ports {
#@                                                                                 to_xpl2_tx*
#@                                                                                 }
#@                                                 set dmbuf_output_ports     {
#@                                                                              to_dmfe_*                                                  
#@                                                                             }
#@                                                                             
#@                                                 set dmbuf_output_ports_slow_list { 
#@                                                                              regbus_response* 
#@                                                                              lcp40g_response_out*
#@                                                                             }                                                
#@                                                                             
#@                                                 do_set_output_delay $stats_output_ports_list       -comment "standard out - stats"  -args [get_block_info datapath P_Block_Timings]             -group "x1_outputs - stats"
#@                                                 do_set_output_delay $t5_chip_ingres_output_ports   -comment "t5 ingress output ports" -args [get_block_info datapath P_Block_Timings]             -group "t5 ingress output ports"
#@                                                 do_set_output_delay $control_wing_output_ports     -comment "control wing output ports"  -args  [get_block_info datapath P_Block_Timings]      -group "control wing output ports"
#@                                                 do_set_output_delay $dmbuf_output_ports            -comment "to dmbuf"     -args [get_block_info dmfe_buffer_top dp_to_dmbuf_timing]          -group "to_dmbuf outputs"
#@                                                 do_set_output_delay $dmbuf_output_ports_slow_list  -comment "to dmbuf"     -args [get_block_info dmfe_buffer_top dmbuf_horizontal_timing]     -group "to_dmbuf outputs slow"
#@                                                 
#@                                             # Memory paths
#@ 
#@                                                 disable_memoir_211hd_cka_ckb_paths
#@                                                                                           
#@                                                 group_path -name fuflet_read_data    -from [get_cells [fixpath "D*/OUTRESEG/RAMS/FUFLET*/$BS_SS_U" ]] \
#@                                                                                      -to   [get_cells [fixpath  {OUTRESEG/RAMS/read_data_b*_reg*}]]
#@                                                 group_path -name queuenext_read_data -from [get_pins  [fixpath  "D*/OUTRESEG/QUEUENEXT*/$BS_SS_U CK"]]
#@                                                 group_path -name bufinfo_read_data   -from [get_cells [fixpath "D*/OUTRESEG/BUFINFO/$BS_SS_U"]]
#@                                                 group_path -name voqinfo_read_data   -from [get_cells [fixpath "D*/OUTRESEG/VOQINFO/$BS_SS_U"]]
#@                                             }
#@                           physical_compile  {
#@                             set placer_max_cell_density_threshold 0.17
#@                             eval [get_block_info default physical_compile]
#@                           }
#@                           uniquification_prefix D_
#@                           top_level_path        D*/
#@                         }
#@                         
#@     output_resegmenter  {
#@                          #post_ungroup      { ungroup_* }
#@                           timing            {
#@                                                 eval [get_block_info default timing]
#@                                                 group_path -name queuenext_read_data -from [get_cells "QUEUENEXT*/$BS_SS_U"]
#@                                             }
#@                         }
#@ 
#@     frame_source_mux    {
#@                            #compile_tighter     0.200
#@                         }
#@                         
#@     # {Misc subchip}
#@ 
#@     lcp_buffers         { timing {} }
#@     misc_buffers        { timing {} }
#@     fcx_buffers         { timing {} }
#@     
#@     misc                {
#@                           #subblocks         { misc_buffers lcp_buffers} 
#@                           default_clock     lcpref_clock
#@                           timing            { # same as top level timing for the moment
#@                                               eval [get_block_info default timing]
#@                                               set_drive 0 [all_inputs]
#@                                               remove_output_delay [all_outputs]
#@                                             }
#@                           compile           { # this dont_touch is to work around a bug in 2003.06
#@                                               # (feedthrough signals that need a type conversion)
#@                                               dont_touch_network [find pin TC/LCPOUTERR_in]
#@                                               eval [get_block_info default compile]
#@                                             }
#@                         }
#@                         
#@     lcp40g_logic_no_core  { lib             lcp40g
#@                            default_clock    lcpref_clock
#@                            generics         { SLAVE_CREDITS  4
#@                                               MASTER_CREDITS 4
#@                                               LCP_REGS_SIZE  4096
#@                                               EXTRA_METASTABILITY 1
#@                                             }
#@                            clock_gating     disabled
#@                          }
#@                          
#@     lcp40g_registers     { lib              pqx6
#@                            default_clock    lcpref_clock
#@                            generics         { GP_OUTS             1856
#@                                               GP_INS              448
#@                                               NUM_MDIO_CHANNELS   11
#@                                               EXTRA_METASTABILITY 1
#@                                             }
#@                             clock_gating    disabled
#@                          }
#@ 
#@     sdram_sys_top        { lib              nwest2e
#@                            nwest_useful     {   
#@                                                 proc get_nwest_top {} { 
#@                                                     return sdram_sys_top 
#@                                                 }
#@                                                 
#@                                                 proc get_nwest_root {} {
#@                                                     global env
#@                                                   # set tmp [exec grep -e {setenv \+NWEST_ROOT} ../src/common/vendors/nwest/hbm2_controller/nwest_hbm2.mak]
#@                                                     set tmp [exec grep -e {setenv} ../src/common/vendors/nwest/hbm2e_controller/nwest_hbm2e.mak]
#@                                                     set tmp [split $tmp "\n"]
#@                                                     foreach t $tmp {
#@                                                         regexp {#setenv +(NWEST_ROOT.*) +(.*)} $t dummy var val
#@                                                         set env($var) $val
#@                                                     }
#@                                                     set tmp $env(NWEST_ROOT)
#@                                                     while { [regexp {\$([A-Za-z0-9_]+)} $tmp dummy var] } {
#@                                                         regsub "\\\$$var" $tmp $env($var) tmp
#@                                                     }
#@                                                     return $tmp
#@                                                 }
#@                                                 
#@                                                 proc get_nwest_ver {} {
#@                                                     return [filename [get_nwest_root]]
#@                                                 }
#@                                                 
#@                                                 proc get_nwest_pre_elab_ddc {} {
#@                                                     return [get_nwest_root]/syn/latest/results/[chip_name]_elab_[get_nwest_top].ddc
#@                                                 }
#@                                                 
#@                                                 proc get_nwest_src_dir {} {
#@                                                     global env
#@                                                     return $env(HOME)/project/nwest/srceval/[get_nwest_ver]/rtl
#@                                                 }
#@                                                 
#@                                             }
#@                          XXX_generics       {
#@                                                 DSIZE                           256
#@                                                 APB_PSEL_WIDTH                    1
#@                                                 NUMBER_OF_RANKS                   8
#@                                                 TAG_WIDTH                        13
#@                                                 BURST_SIZE_WIDTH                  4
#@                                                 ADDR_WIDTH                       36
#@                                                 DFI_DATA_PHASE_WIDTH_PHY        256
#@                                                 DFI_DATA_ENABLE_WIDTH_PHY        16
#@                                                 DFI_CONTROL_WIDTH                 1
#@                                                 DFI_CHIP_SELECT_WIDTH             1
#@                                                 DFI_DM_PHASE_WIDTH_PHY           32
#@                                                 AXI_SLAVE_ID_WIDTH                4
#@                                                 AXI_ADDR_WIDTH                   40
#@                                                 AXI_LEN_WIDTH                     4
#@                                                 AXI_DATA_WIDTH                  256
#@                                             }
#@                         XXX_elab            {
#@                                                 get_license [list HDL-Compiler]
#@                                                 
#@                                                 eval [get_block_info sdram_sys_top nwest_useful]
#@                                                 
#@                                                 set src_dir   [get_nwest_src_dir]
#@                                                 set lib       nwest
#@                                                 set nwest_top [get_nwest_top]
#@ 
#@                                                 # W.....g:  .../fastsdram.v:11976: Statement unreachable (Branch condition impossible to meet).  (VER-61) (2 off)
#@                                                 # W.....g:  .../fastsdram.v:5739: 'Case' statement is full and has only one nontrivial branch; it will be inlined. (ELAB-335) (2 off)
#@                                                 # W.....g:  .../mem_test.v:441: DEFAULT branch of CASE statement cannot be reached. (ELAB-311)
#@                                                 # W.....g:  .../mem_test_analyzer.v:255: signed to unsigned conversion occurs. (VER-318)
#@                                                 # W.....g:  .../openrank.v:840: A unnamed generate block with an LRM-defined name 'genblk1' is detected, which is incompatible with Verilog standard 2001 or 1995. (VER-944)
#@                                                 
#@                                                 suppress_message {VER-318 VER-61 VER-944 ELAB-311 ELAB-335}
#@                                                 
#@                                                 foreach fname [glob $src_dir/*.v] {
#@                                                     echoed "analyze -format verilog -define SYNTHESIS -lib nwest $fname"
#@                                                 }
#@                                              #  foreach fname [glob -nocomplain $src_dir/hacked/*.v] {
#@                                              #      echoed "analyze -format verilog -define SYNTHESIS -lib nwest $fname"
#@                                              #  }
#@                                                 
#@                                                 # Method 1
#@                                                 
#@                                                 elaborate -lib nwest $nwest_top
#@                                                 current_design [designname $nwest_top]
#@                                                 link
#@                                                 
#@                                                 # Method 2
#@ 
#@                                                 # elaborate -lib nwest $nwest_top -parameters [elab_parameters $nwest_top]
#@                                                 # current_design [designname $nwest_top]
#@                                                 # link
#@ 
#@                                                 # Method 2r
#@ 
#@                                                 # elaborate -lib nwest $nwest_top -parameters [elab_parameters $nwest_top]
#@                                                 # rename_design [designname $nwest_top] $nwest_top
#@                                                 # current_design $nwest_top
#@                                                 # link
#@                                                 # And something to change the behaviour of designname function
#@ 
#@                                                 # Method 3
#@ 
#@                                                 # elaborate -lib q6chip nwest_hbm_x2_controller_channel
#@                                                 # current_design [designname $nwest_top]
#@                                                 # link
#@ 
#@                                                 # Method 3r
#@ 
#@                                                 # elaborate -lib nwest $nwest_top -parameters [elab_parameters $nwest_top]
#@                                                 # rename_design [designname $nwest_top] $nwest_top
#@                                                 # current_design $nwest_top
#@                                                 # link
#@                                                 # And something to chnange the behaviour of designname function
#@ 
#@                                             }
#@                          }
#@ 
#@     nwest_hbm_x2_controller_channel {
#@     
#@                             default_clock   dram_div2_clock
#@                             
#@                             clock_portnames {
#@                                               dram_div2_clock       dfi_clock
#@                                               csr_clock             csr_clock
#@                                             }
#@                             XXX_elab        {
#@                                             
#@                                             #  First get the nwest top level
#@                             
#@                                                 eval [get_block_info sdram_sys_top nwest_useful]
#@ 
#@                                                 set nwest_top      [get_nwest_top]
#@                                                 set local_elab_ddc ${results_dir}/[chip_name]_elab_${nwest_top}.$format
#@                                                 
#@                                                 set src_dir        [get_nwest_src_dir]
#@                                                 
#@                                                 set pre_elab_ddc   [get_nwest_pre_elab_ddc]
#@                                                 
#@                                                 if { 0 && [sizeof_collection [suppressed {UID-109} {get_designs [designname $nwest_top]}]] != 0} {
#@                                                 
#@                                                     puts "Elab $nwest_top: local design already exists"
#@                                                     
#@                                                 } elseif { 0 && [file readable $local_elab_ddc] } {
#@                                                 
#@                                                     puts "Elab $nwest_top: local elaborated file '$local_elab_ddc' already exists"
#@                                                     read_file -format $format $local_elab_ddc
#@                                                     
#@                                                 } elseif { 0 && [file readable $src_dir] } {
#@                                                 
#@                                                     puts "Elab $nwest_top: src '$src_dir' readable. Will analyze and elaborate that"
#@                                                     eval [get_block_info sdram_sys_top elab]
#@                                                     write -format ddc -output $output_file_base-$nwest_top-ELABORATED.$format -hier [designname $nwest_top]
#@                                                     
#@                                                 } elseif { [file readable $pre_elab_ddc] } {
#@                                                 
#@                                                     puts "Elab $nwest_top: using shared pre_elaborated ddc"
#@                                                     read_file -format $format $pre_elab_ddc
#@                                                     
#@                                                     if { [designname $nwest_top] != "$nwest_top" } {
#@                                                         rename_design [designname $nwest_top] $nwest_top
#@                                                     }
#@                                                     current_design $nwest_top
#@                                                     link
#@                                                     
#@                                                 } else {
#@                                                     die "Elab $nwest_top: Can't find any nwest controller"
#@                                                 }
#@                                                 
#@                                             # And now for our wrapper
#@                                                 
#@                                                 echoed "elaborate -library $block_info(lib) $ver"
#@ 
#@                                             }
#@                                             
#@                             timing          {
#@                                               # subchip_mbist_timing
#@                                                 mickey_mouse_test_input_stuff
#@                                                 mickey_mouse_reset_tree_input_stuff
#@                                               # mickey_mouse_input_timing
#@                                               # mickey_mouse_output_timing
#@ 
#@                                                 # core side connections - straight from/to regs
#@                                                 
#@                                                 set_input_delay     0.22 -clock dram_div2_clock [get_ports {psin* }]
#@                                                 set_output_delay    0.62 -clock dram_div2_clock [get_ports {psout*}]
#@                                                 
#@                                                 # Phy side connections - as much as we can afford
#@                                                 
#@                                                 set_input_delay     0.52 -clock dram_div2_clock [get_ports {dfi_phy_to_ctrl*}]
#@                                                 set_output_delay    0.55 -clock dram_div2_clock [get_ports {dfi_ctrl_to_phy* reset_n_ext}]
#@                                                 
#@                                             }
#@                             map_effort      high
#@                             compile         {
#@                                                # W.....g: At pin 'CHCTRL/.../..timer_ld_reg_0/phi' clock 'dram_div2_clock' does not have the needed 'rise' edge.  (TIM-250)
#@                                                suppress_message TIM-250
#@                                                eval [get_block_info default compile]
#@                                             }
#@                             compile2        {
#@                                                 ungroup -all -flatten
#@                                                 
#@                                                 global compile_implementation_selection
#@                                                 set compile_implementation_selection false
#@                                                 
#@                                                 compile -inc -scan -map_effort high    
#@                                                 compile -inc -scan -map_effort medium    
#@                                                 compile -inc -scan -map_effort medium
#@                                                 
#@                                                 set compile_implementation_selection true
#@ 
#@                                             }
#@                         }
#@ 
#@     dmfe_nwest_wrapper {
#@                            #subblocks       { nwest_hbm_x2_controller_channel }
#@                             
#@                            #clock_gating    disabled
#@                             default_clock   dram_div2_clock
#@                             
#@                             timing          {
#@                                               # subchip_mbist_timing
#@                                                 mickey_mouse_test_input_stuff
#@                                                 mickey_mouse_reset_tree_input_stuff 
#@                                               # mickey_mouse_input_timing
#@                                               # mickey_mouse_output_timing
#@ 
#@                                                 # core side connections - straight from/to regs
#@                                                 
#@                                                 set_input_delay     0.300 -clock dram_div2_clock [get_ports {a_config*}]
#@                                                 
#@                                                 set_input_delay     0.150 -clock dram_div2_clock [get_ports {psin* pbus_request*}]
#@                                                 set_input_delay     0.080 -clock dram_div2_clock [get_ports {psin*_L_DATAIN_*}]
#@                                                 set_input_delay     0.300 -clock dram_div2_clock [get_ports {psin*_L_R_REQ}]
#@                                                 set_output_delay    0.550 -clock dram_div2_clock [get_ports {psout* status* pbus_response*}]
#@                                                 set_output_delay    0.650 -clock dram_div2_clock [get_ports {psout*_L_BUSY}]
#@                                                 set_output_delay    0.430 -clock dram_div2_clock [get_ports {psout*_L_D_REQ}]
#@                                                 
#@                                                 # Phy side connections - as much as we can afford
#@                                                 
#@                                                 set_input_delay     0.800 -clock dram_div2_clock [get_ports {dfi_phy_to_ctrl*}]
#@                                                 set_output_delay    0.800 -clock dram_div2_clock [get_ports {dfi_ctrl_to_phy* reset_n_ext}]
#@                                                 
#@                                                 # Phy Fifo constraints
#@                                                 
#@                                              #  # PHY clock stuff
#@                                              #   
#@                                              #   # collect per channel/per clock port names
#@                                              #   foreach dw {0 1 2 3} {
#@                                              #       set dw_in_ports_${dw} {}
#@                                              #       for {set i [expr $dw * 32]} {$i < [expr ($dw + 1) * 32]} {incr i} { 
#@                                              #           set j [expr $i + 128]
#@                                              #           append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_W*_${i}"]
#@                                              #           append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_W*_${j}"]
#@                                              #       }
#@                                              #       
#@                                              #       for {set i [expr $dw * 4]} {$i < [expr ($dw + 1) * 4]} {incr i} { 
#@                                              #           append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_DBI_BYTE_DISABLE_${i}"]
#@                                              #       }
#@                                              #       
#@                                              #       for {set i [expr $dw * 4]} {$i < [expr ($dw + 1) * 4]} {incr i} { 
#@                                              #           set j [expr $i + 16]
#@                                              #           append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_MASK_W?_${i} dfi_phy_to_ctrl_RDDATA_DBI_W?_${i}"]
#@                                              #           append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_MASK_W?_${j} dfi_phy_to_ctrl_RDDATA_DBI_W?_${j}"]
#@                                              #       }
#@                                              #               
#@                                              #       set i $dw
#@                                              #       set j [expr $i + 4]
#@                                              #       append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_PAR_W?_${i}"]
#@                                              #       append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_PAR_W?_${j}"]
#@                                              #       
#@                                              #       set i $dw
#@                                              #       append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_VALID_W*_${i}"]
#@                                              #       append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_RDDATA_VALID_PAR_W*_${i}"]
#@                                              #       append_to_collection dw_in_ports_${dw} [get_ports "dfi_phy_to_ctrl_DERR_P*_${i}"]
#@                                              #   }
#@                                              #   set aw_in_ports [get_ports "dfi_phy_to_ctrl_AERR_* dfi_phy_to_ctrl_INIT_COMPLETE"]
#@                                              #   
#@                                              #   for {set dw 0} {$dw < 4} {incr dw} {
#@                                              #       set dw_out_ports_${dw} {}
#@                                              #       for {set i [expr $dw * 32]} {$i < [expr ($dw + 1) * 32]} {incr i} { 
#@                                              #           set j [expr $i + 128]
#@                                              #           append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_WRDATA_P?_${i}"]
#@                                              #           append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_WRDATA_P?_${j}"]
#@                                              #       }
#@                                              #       
#@                                              #       for {set i [expr $dw * 4]} {$i < [expr ($dw + 1) * 4]} {incr i} { 
#@                                              #           set j [expr $i + 16]
#@                                              #           append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_WRDATA_MASK_P?_${i} dfi_ctrl_to_phy_WRDATA_DBI_P?_${i}"]
#@                                              #           append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_WRDATA_MASK_P?_${i} dfi_ctrl_to_phy_WRDATA_DBI_P?_${j}"]
#@                                              #       }
#@                                              #       
#@                                              #       set i $dw
#@                                              #       set j [expr $i + 4]
#@                                              #       append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_WRDATA_PAR_P?_${i}"]
#@                                              #       append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_WRDATA_PAR_P?_${j}"]
#@                                              #       
#@                                              #       set i $dw
#@                                              #       append_to_collection dw_out_ports_${dw} [get_ports "dfi_ctrl_to_phy_??DATA_EN_P*_${i}"]
#@                                              #   }
#@                                              #   set aw_out_ports [get_ports "dfi_ctrl_to_phy_CKE* dfi_ctrl_to_phy_COL* dfi_ctrl_to_phy_ROW*"]
#@                                              #       
#@                                              #   # apply constraints to port groups
#@                                              #   # aw ports
#@                                              #   set_input_delay   0.25 -add -clock phy_fifo_clks_4 [set aw_in_ports]
#@                                              #   set_output_delay  0.50 -add -clock phy_fifo_clks_4 [set aw_out_ports]
#@                                              #
#@                                              #   # dw ports
#@                                              #   foreach dw {0 1 2 3} {
#@                                              #       set_input_delay   0.25 -add -clock phy_fifo_clks_${dw} [set dw_in_ports_${dw}]
#@                                              #       set_output_delay  0.50 -add -clock phy_fifo_clks_${dw} [set dw_out_ports_${dw}]
#@                                              #   }
#@                                              #   
#@                                              #   # false path the fifo crossings, to/from the dram_div2_clock - SPONG make them multicycle ??
#@                                              #   set_false_path -from [get_clocks phy_fifo_clks_*] -to [get_clocks dram_div2_clock]
#@                                              #   set_false_path -from [get_clocks dram_div2_clock] -to [get_clocks phy_fifo_clks_*]
#@                                              #   
#@                                              #   ## increase setup/hold uncertainty between phy clocks for reset resync 
#@                                              #   foreach constraint { {0.300 -setup} {0.300 -hold} } {
#@                                              #       # forwards only - note: phy_fifo_clks_4 is the aw clock in the middle
#@                                              #       echoed "set_clock_uncertainty $constraint -from phy_fifo_clks_0 -to phy_fifo_clks_1"
#@                                              #       echoed "set_clock_uncertainty $constraint -from phy_fifo_clks_1 -to phy_fifo_clks_4"
#@                                              #       echoed "set_clock_uncertainty $constraint -from phy_fifo_clks_4 -to phy_fifo_clks_2"
#@                                              #       echoed "set_clock_uncertainty $constraint -from phy_fifo_clks_2 -to phy_fifo_clks_3"
#@                                              #   }
#@                                              
#@                                             }
#@                             compile         {
#@                                               eval [get_block_info default compile]
#@                                               change_names_of_clashing_cells
#@                                             }
#@                         }
#@     dmfe_scheduler          {
#@                               default_clock     dram_div2_clock
#@                               compile_tighter   0.020
#@                               compile2          {# skip the second compile}
#@                              #elab              {
#@                                                     setenv SYNTHESIS 1
#@                                                     analyze -format vhdl -work q6chip ../src/q6chip/src/dm/dmfe_scheduler.vhd 
#@                                                     echoed "elaborate -library $block_info(lib) dmfe_scheduler"
#@                                                 }
#@                             }
#@     dmfe_sequencer          {
#@                               default_clock     dram_div2_clock
#@                               timing            {
#@                                                   eval [get_block_info default timing]
#@                                                   set_input_delay  0.47 [get_ports {from_ctrlr*}]                  -clock dram_div2_clock 
#@                                                     
#@                                                   do_set_output_delay   [get_ports {to_ctrlr*}]  -op_logic 0.030 -clock_name dram_div2_clock -op_transit 0
#@                                                   
#@                                                   # exceptions for paths that have a little logic and fanout after final registers
#@                                                   
#@                                                   do_set_output_delay   [get_ports {to_ctrlr*_L_ADDR* }]    -op_logic 0.050 -clock_name dram_div2_clock -op_transit 0
#@                                                   
#@                                                   # exceptions for from_ctrl_* to to_ctrlr* combinatorial paths
#@ 
#@                                                   do_set_output_delay   [get_ports {to_ctrlr*_L_SBREF_REQ}] -op_logic 0.430 -clock_name dram_div2_clock -op_transit 0
#@                                                   do_set_output_delay   [get_ports {to_ctrlr*_L_W_REQ}]     -op_logic 0.430 -clock_name dram_div2_clock -op_transit 0
#@                                                   do_set_output_delay   [get_ports {to_ctrlr*_L_R_REQ}]     -op_logic 0.430 -clock_name dram_div2_clock -op_transit 0
#@                                                   
#@                                                   # exceptions for mem_response_* to to_ctrl combinatorial paths
#@                                                   
#@                                                   do_set_output_delay   [get_ports {to_ctrlr*_L_*DATAIN_*}]  -op_logic 0.090 -clock_name dram_div2_clock -op_transit 0
#@                                                   
#@                                                   set uncert [lfirst [get_clock_param dram_div2_clock setup_uncertainty $block_info(block_name)]]
#@                                                   set_input_delay  0.00                      [get_ports {from_ctrlr*_ACTIVATE_READY*}] -clock dram_div2_clock
#@                                                   set_output_delay 0.00                      [get_ports {bank_activate_ready*}]        -clock dram_div2_clock
#@                                                   set_max_delay    [expr 0.030+$uncert]  -to [get_ports {bank_activate_ready*}]
#@ 
#@                                                 }
#@                             }
#@     dmfe_quad_read_reassembler {
#@                               default_clock     dram_div2_clock
#@                             }
#@     dmfe_quad_pseudochannel {
#@     
#@                             subblocks           {dmfe_sequencer dmfe_scheduler dmfe_quad_read_reassembler}
#@                             mbist_block_timing  { dram_div2_clock 5 }
#@                             
#@                             timing              {
#@                                                     subchip_mbist_timing
#@                                                     mickey_mouse_test_input_stuff
#@                                                     mickey_mouse_reset_tree_input_stuff
#@                                                     mickey_mouse_input_timing
#@                                                     mickey_mouse_output_timing
#@                             
#@                                                   # Memory controller side (our outputs are registered very shortly after going into the memory controller, it seems)
#@                                                   
#@                                                     do_set_output_delay   [get_ports {dram_div2_to_ctrlr*}]             -op_logic 0.200 -clock_name dram_div2_clock -op_transit 0
#@                                                     do_set_output_delay   [get_ports {dram_div2_to_ctrlr*_L_SBREF_REQ}] -op_logic 0.450 -clock_name dram_div2_clock -op_transit 0
#@                                                     do_set_output_delay   [get_ports {dram_div2_to_ctrlr*_L_W_REQ}]     -op_logic 0.450 -clock_name dram_div2_clock -op_transit 0
#@                                                     do_set_output_delay   [get_ports {dram_div2_to_ctrlr*_L_R_REQ}]     -op_logic 0.450 -clock_name dram_div2_clock -op_transit 0
#@ 
#@                                                     set_input_delay  0.47 [get_ports {dram_div2_from_ctrlr*}]                  -clock dram_div2_clock 
#@                                                     set_input_delay  0.30 [get_ports {dram_div2_from_ctrlr_*ACTIVATE_READY*} ] -clock dram_div2_clock
#@                                                   
#@                                                   # And the block config signals
#@                                                   
#@                                                     set_input_delay   0.3       [get_ports statics_CORE*   ] -clock core_clock
#@                                                     set_input_delay   1.0       [get_ports statics_A_*     ] -clock core_clock
#@                                                     set_max_delay     5.0 -from [get_ports statics_STATIC* ]
#@ 
#@                                                   # And a core side override - this one gets re-registered outside
#@                                                     set_output_delay  0.25 [get_ports core_to_dm_dbus_RESPONSE_CREDIT_RETURN_PCHAN_2] -clock core_clock
#@                                             }
#@                         } 
#@ 
#@     dmfe_0              { 
#@                          #subblocks           { dmfe_core dmfe_spreader_0 }
#@                           ilm_block_names     { [list dmfe_core dmfe_spreader_0] }
#@                           
#@                           mbist_block_timing  { dram_div2_clock 5 }
#@                           map_effort          medium
#@                           elab                {
#@                                                 eval [get_block_info top elab]
#@                                               }
#@ 
#@                           timing              { 
#@                           
#@                                                  #subchip_mbist_timing
#@                                                  #mickey_mouse_test_input_stuff
#@                                                  #mickey_mouse_reset_tree_input_stuff
#@                                                  #mickey_mouse_input_timing
#@                                                  #mickey_mouse_output_timing
#@                                                  
#@                                                  # explicit pull in asynpaths file
#@                                                  #source ../results/q6chip_prefloorplan_dmfe.async_false_paths.tcl
#@                           
#@                                               }
#@                           uniquification_prefix NOT_DMFE_
#@                           top_level_path        NOT_DMFE*/
#@                         }
#@                         
#@     dmfe_spreader_0       {
#@                           timing              {
#@                                                 do_set_input_delay  {raw_from_dm_*   } -args [get_block_info  dmfe_buffer_top dmbuf_to_dmfe_core_timing]
#@                                                 do_set_output_delay {to_dmfe_*       } -args [get_block_info  dmfe_buffer_top dmbuf_to_dmfe_core_timing]
#@ 
#@                                                 do_set_input_delay  {raw_from_dmfe_* } -args [get_block_info  dmfe_buffer_top dmfe_core_to_dmbuf_timing]
#@                                                 do_set_output_delay {to_dm_*         } -args [get_block_info  dmfe_buffer_top dmfe_core_to_dmbuf_timing]
#@                                                             
#@                                               }
#@                         }
#@ 
#@     dmfe_spreader_1       {
#@                           timing              { 
#@                                                 eval [get_block_info dmfe_spreader_0 timing]
#@                                               }
#@                         }
#@     dmfe_core           { 
#@                           subblocks           {dmfe_quad_pseudochannel dmfe_nwest_wrapper}
#@                           mbist_block_timing  { dram_div2_clock_0 5 }
#@                           map_effort          medium
#@ 
#@                           dmfe_core_to_sched_timing { -ip_transit 0.300 -top_transit 0.140 -op_transit 0.020 }
#@                           sched_to_dmfe_core_timing { -ip_transit 0.020 -top_transit 0.140 -op_transit 0.300 }
#@                           
#@                           dmfe_core_bis_to_jochen   {                                      -op_transit 0.100 }
#@                           jochen_to_dmfe_core_bis   { -ip_transit 0.100                                      }
#@                           
#@                           timing              { 
#@                                                 puts "dmfe core timing, called for design $design_name"
#@                                                 
#@                                                 if { [regexp "dmfe_core" $design_name] } {
#@                                                     set dmfe_core_path {}
#@                                                 } else {
#@                                                     set dmfe_core_path {DMFE*/CORE/}
#@                                                 }
#@                                                     
#@                                                 if { [regexp "dmfe_core" $design_name] } {
#@                                                 
#@                                                     # At block level consider a_reset to be synchronous...
#@                                                     do_set_input_delay  {a_reset}           -op_transit 0 -ip_transit 0.300 -op_transit 0.0
#@                                                     
#@                                                     subchip_test_input_stuff
#@                                                     subchip_mbist_timing
#@                                                     # The mbist ports are all timed relative to the mbist clock (dram_div2_clock_0, see above)
#@                                                     # But the output test isolation flops on mbist_status_* are clocked by core_clock, so we
#@                                                     # need some relaxation here
#@                                                     set_multicycle_path 2 -to [get_ports {mbist_status_BUSY mbist_status_FLAGS*}]
#@                                                     set_multicycle_path 3 -to [get_ports {mbist_status_BUSY mbist_status_FLAGS*}] -hold
#@                                                     
#@                                                   # Phy side connections
#@ 
#@                                                     group_path -name fromphydata -from [get_ports dram_phy2ctrl*]
#@                                                     group_path -name tophydata   -to   [get_ports dram_ctrl2phy*]
#@                                                 
#@                                                     set dram_div2_clocks         {0}
#@                                                     set dfi_fifo_clks            {0}
#@                                                     set channels                 {0 1 2 3}
#@                                                     set channels_by_clock        {{0 1 2 3}}
#@                                                     set channels_by_dfi_fifo_clk {{0 1 2 3}}
#@                                                     if { [regexp dmfe_core_full $design_name] } {
#@                                                         set dram_div2_clocks         {0 1 2 3}
#@                                                         set dfi_fifo_clks            {0 1 2 3}
#@                                                         set channels                 {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15}
#@                                                         set channels_by_clock        {{0 4 8 12} {1 5 9 13} {2 6 10 14} {3 7 11 15}}
#@                                                         set channels_by_dfi_fifo_clk {{0 4 8 12} {1 5 9 13} {2 6 10 14} {3 7 11 15}}
#@                                                     }
#@                                                 
#@                                                     foreach c $dram_div2_clocks chs $channels_by_clock {
#@                                                         foreach ch $chs {
#@                                                             set_input_delay  0.800 -clock virtual_dram_div2_clock_$c [get_ports "dram_phy2ctrl_${ch}_*"]
#@                                                             set_output_delay 0.800 -clock virtual_dram_div2_clock_$c [get_ports "dram_ctrl2phy_${ch}_*"]
#@                                                         }
#@                                                     }
#@                                                    
#@                                                   # Core side connections
#@                                                     do_set_input_delay  {raw_dmfe_index* raw_dmfe_subindex*} -op_transit 0 -ip_transit 0.400
#@ 
#@                                                     if { [regexp "dmfe_core_bis" $design_name] } {
#@                                                     
#@                                                         # dmfe_core_bis only
#@                                                     
#@                                                         do_set_input_delay   [get_ports raw_from_dm_*] -args [get_block_info dmfe_core jochen_to_dmfe_core_bis]
#@                                                         do_set_output_delay  [get_ports to_dm_*      ] -args [get_block_info dmfe_core dmfe_core_bis_to_jochen]
#@                                                         
#@                                                         # assume unconnected ports are dont care for timing, otherwise apply reset_path to/from these
#@                                                         # inputs  reset_path -from [get_ports "raw_from_dm_0_COMMON_26..39 raw_from_dm_?_DBUS_?_CONTROL_49..63  raw_from_dm_?_DBUS_?_CONTROL_DISABLE_NEXT"]
#@                                                         # outputs reset_path -to   [get_ports "to_dm_?_DBUS_?_CONTROL_19..63 to_dm_?_DBUS_?_CONTROL_DISABLE_NEXT to_dm_0_COMMON_* to_dm_1_COMMON_38..39"]
#@                          
#@                                                     }
#@                                                     
#@                                                     if { $design_name eq "dmfe_core_full" } {
#@                                                     
#@                                                         do_set_input_delay  {raw_lcp40g_response*             } -args [get_block_info  dmfe_buffer_top dmbuf_horizontal_timing]
#@                                                         do_set_output_delay {lcp40g_request_out*              } -args [get_block_info  dmfe_buffer_top dmbuf_horizontal_timing]
#@ 
#@                                                         #400 microns up scheduler
#@                                                         do_set_input_delay  {raw_lcp40g_request* }                    -args [get_block_info dmfe_core sched_to_dmfe_core_timing]
#@                                                         do_set_output_delay {lcp40g_response_out* fcx2_to_sched_out*} -args [get_block_info dmfe_core dmfe_core_to_sched_timing]
#@ 
#@                                                         #fcx
#@                                                         do_set_input_delay  {raw_fcx2_regbus_response* raw_fcx2_to_sched*} -args [get_block_info fcx2_top fcx_regbus_timing]
#@                                                         do_set_output_delay {fcx2_regbus_request*      fcx2_reset_out    } -args [get_block_info fcx2_top fcx_regbus_timing]
#@                                                     
#@                                                         # Regbus and main to/from _dm
#@                                                     
#@                                                         do_set_input_delay  {raw_from_dm* raw_regbus_request* } -args [get_block_info  dmfe_buffer_top dmbuf_to_dmfe_core_timing]
#@                                                         do_set_output_delay {to_dm*       regbus_response*    } -args [get_block_info  dmfe_buffer_top dmfe_core_to_dmbuf_timing]
#@                                                     }
#@                                                     
#@                                                     if { $design_name eq "dmfe_core" } {
#@                                                         
#@                                                         # N/S interconnections
#@                                                         
#@                                                         do_set_input_delay  {raw_pbus_write_ack_in_*  raw_regbus_in*}
#@                                                         do_set_output_delay {core_pbus_write_ack_out* regbus_out*   }
#@                                                         
#@                                                         # Main to/from _dm
#@                                                     
#@                                                         do_set_input_delay  {raw_from_dm* } -args [get_block_info  dmfe_buffer_top dmbuf_to_dmfe_core_timing]
#@                                                         do_set_output_delay {to_dm*       } -args [get_block_info  dmfe_buffer_top dmfe_core_to_dmbuf_timing]
#@                                                         
#@                                                     }
#@                                                         
#@                                                     # and these are common to both dmfe_core and dmfe_core_bis
#@                                                     
#@                                                     # Async signals 
#@                                                     # SPONG: Remove use too
#@                                                     # do_set_output_delay {pll_config*}                                              -op_transit 0.450 -ip_transit 0.0  
#@                                                     # do_set_input_delay  {a_pll_status*}                                            -op_transit 0.0   -ip_transit 0.45
#@                                                     
#@                                                     foreach clk $dram_div2_clocks {
#@                                                         do_set_input_delay  {dram_phy2ctrl_common_TEMP_* dram_phy2ctrl_common_CATTRIP} -op_transit 0.0   -ip_transit 0.50 -clock_name dram_div2_clock_$clk
#@                                                     }
#@ 
#@                                                     # these false paths are needed to constraint the dfi interface ins/outs to the correct clocks
#@                                                     # set_false_path -from [get_clocks virtual_dram_div2_clock_?]     -to [get_clocks DMFEA_C*_DFI_CLK_OUT*]
#@                                                     # set_false_path -from [get_clocks virtual_DMFEA_C*_DFI_CLK_OUT*] -to [get_clocks dram_div2_clock_?]
#@                                                     # set_false_path -from [get_clocks dram_div2_clock_?]             -to [get_clocks virtual_DMFEA_C*_DFI_CLK_OUT*]
#@                                                     # set_false_path -from [get_clocks DMFEA_C*_DFI_CLK_OUT*]         -to [get_clocks virtual_dram_div2_clock_?]
#@                                                     
#@                                                 }
#@                                             }
#@                           uniquification_prefix DMFE_
#@                           top_level_path        DMFE*/CORE/MINI*/
#@                           physical_compile  {
#@                                                 # echo "Hello world"
#@                                                 
#@                                                 # set cells [get_cells * -hier -filter {@ref_name==a16lvt16_ltchdnq_a1}]
#@                                                 # set_scan_element false $cells
#@                                                 # set_dont_touch $cells
#@                                                 # puts [get_object_name $cells]
#@ 
#@                                                 # echo "Goodbye world"
#@                                                 
#@                                                 eval [get_block_info default physical_compile]
#@ 
#@                                             }
#@                           ilm                 1
#@                         }
#@     dmfe_core_full     { 
#@                           subblocks           { dmfe_quad_pseudochannel dmfe_nwest_wrapper }
#@                           mbist_block_timing  { dram_div2_clock_0 5 }
#@                           map_effort          medium
#@                           timing              { 
#@                                                 eval [get_block_info dmfe_core timing]
#@                                               }
#@                           uniquification_prefix DMFEF_
#@                           top_level_path        DMFE*/CORE/
#@                           physical_compile    {
#@                                                 eval [get_block_info dmfe_core physical_compile]
#@                                               }
#@                           ilm                 1
#@                         }
#@ 
#@     xpl_serdes_x16       {
#@                           timing          {
#@                                             remove_attribute [all_inputs] max_capacitance
#@                                             remove_attribute [all_inputs] max_fanout
#@ 
#@                                             # Primary Inputs (and "almost primary" inputs)
#@                           
#@                                             set primary_inputs [get_ports "XPLRXDATA* xplrefclk*"]
#@                                             
#@                                             set_drive 0      $primary_inputs
#@                                             set_dont_touch   [all_connected $primary_inputs]
#@                                             
#@                                             # Other inputs 
#@                                             
#@                                             set inputs [remove_from_collection [all_inputs] $primary_inputs]
#@                                             eval "set_driving_cell $x_driving_cell_params(4) $inputs"
#@                                             
#@                                             # Primary outputs
#@                                             
#@                                             set primary_outputs [get_ports XPLTXDATA*]
#@                                             set_load  0         $primary_outputs
#@                                             set_dont_touch      [all_connected $primary_outputs]
#@ 
#@                                           }
#@                           clock_gating    disabled
#@                           compile         { #use_avago_top_cells
#@                                             eval [get_block_info default compile]
#@                                           }
#@                         }
#@     dmfe_serdes         {
#@                           timing          {
#@                                            # Remarkably this one gets away with no constraints, and still compiles with virtuall no added cells.
#@                                            # but we should probably do somethign safer than just rely on that
#@                                           }
#@                           compile         { #use_avago_top_cells
#@                                             eval [get_block_info default compile]
#@                                           }
#@                         }
#@     test_ctrl_elway     {
#@                           clock_portnames { core_clock no_core_clock_present
#@                                           }
#@                           timing          {}
#@                           compile         { #use_avago_top_cells
#@                                             eval [get_block_info default compile]
#@                                           }
#@                           clock_gating    disabled
#@                         }
#@     #sensor              {
#@                           elab            { 
#@                                             # W.....g: .../sensor.vhs:78: Floating pin 'sensor_remote_b_in[7] of cell U_SENSOR' connected to ground. (ELAB-294)
#@                                             suppressed ELAB-294 {
#@                                                 echoed "elaborate -library $block_info(lib) $ver"
#@                                             }
#@                                             foreach_in_collection p [get_pins */sensor_remote_*_in_*] {
#@                                                 set pinname [get_object_name $p]
#@                                                 set net     [get_nets -of_object $p]
#@                                                 set netname [get_object_name $net]
#@                                                 echo "$pinname $netname"
#@                                                 if { [regexp {\*Logic0\*} $netname] } {
#@                                                     echoed "  disconnect_net \[get_nets $netname\] \[get_pins $pinname\]"
#@                                                     set new_netname dont_touch_not_connected_[file tail $pinname]
#@                                                     echoed "  create_net $new_netname"
#@                                                     echoed "  connect_net \[get_nets $new_netname\] \[get_pins $pinname\]"
#@                                                 }
#@                                             }
#@                                           }
#@                           compile         {
#@                                            # Do nothing. Elaborated design is already mapped.
#@                                           }
#@                         }
#@     top                 { designname      q6core
#@                           ilm_block_names { [set ilm_block_names] }
#@                           subblocks       { test_ctrl_elway }
#@                           fixed_netnames  {
#@                                                 Q/core_clock                core_clock
#@                                           }
#@                          #timing          { 
#@                                           }
#@                           elab            {
#@                                             global ilm_design_names
#@                                             global suppress_errors
#@                                             lappend suppress_errors LINK-1
#@                                             
#@                                             foreach ilm_design_name $ilm_design_names {
#@                                                 echoed "create_design $ilm_design_name"
#@                                             }
#@                                             set_dont_touch [get_designs $ilm_design_names]
#@                                             
#@                                             echoed "elaborate -library [get_block_info $ver lib] [designname $ver]"
#@                                             
#@                                             foreach ilm_design_name $ilm_design_names {
#@                                                   foreach_in_collection cell [get_cells -hierarchical * -filter @ref_name==$ilm_design_name] {
#@                                                       lappend tmp_array([get_parent_ref_name $cell]) [get_attribute $cell name]
#@                                                   }
#@                                                   set previous_current_design [current_design]
#@                                                   foreach design_name [array names tmp_array] {
#@                                                       current_design $design_name
#@                                                       suppressed {UID-101} {
#@                                                           remove_attribute [get_cells $tmp_array($design_name)] hdl_library
#@                                                           remove_attribute [current_design] link_design_libraries
#@                                                     }
#@                                                   }
#@ 
#@                                                   current_design $previous_current_design
#@                                             }
#@                                             
#@                                           #  global output_file
#@                                           #  write -hierarchy -format $format -output $output_file [designname $version]
#@ 
#@                                           #  #################
#@                                           #  # There is no -map_effort low option
#@                                           #  compile -no_design_rule -area_effort low -map_effor medium
#@                                           #  global format
#@                                           #  set output_file $output_file_base-NC_COMPILE.$format
#@                                             
#@                                           }
#@                           clock_gating    disabled
#@                           compile_effort  medium
#@                           compile         {
#@                                             eval [get_block_info [chip_top_name] compile]
#@                                           }
#@                           compile_check_for_unmapped_logic 0
#@ 
#@                         }
#@ 
#@     test_ctrl_io_pad_brcm {
#@                           compile         {
#@                                             set tech_library_dont_use {LP14H_* *X0 *X24 *X28 *X32 *X36 *_BUSHLDX* *_TRIX*}
#@                                             eval [get_block_info default compile]
#@                                           }
#@                           compile_check_for_unmapped_logic 0
#@ 
#@                         }
#@                         
#@     # {TOP_LEVEL}
#@     
#@     q6core              { 
#@                           subblocks       { test_ctrl_elway }
#@                           timing          { 
#@                                             # First put some default timing on pins 
#@ 
#@                                             set_drive 0 [all_inputs]
#@                                             remove_input_delay [all_inputs]
#@                                             
#@                                             set_load 0 [all_outputs]
#@                                             remove_output_delay [all_outputs]
#@ 
#@                                             # suppress_message TIM-052
#@                                             if { $running_design_compiler || $running_physical_compiler } {
#@                                                 # Primary I/Os are the ones that dont have lower case letters in their names
#@                                                 set primary_ios [filter_collection [get_ports *] -regexp "@name !~ \".*\[a-z\].*\""]
#@                                                 set_dont_touch [fast_all_fandown $primary_ios -nets -include_hierarchy -levels 1]
#@                                             }
#@                                             
#@                                             global version
#@                                             if { [regexp {top$} $version] } {
#@                                                 echoed [get_block_info [chip_top_name] top_only_timing]
#@                                             } else {
#@                                                 echoed [get_block_info [chip_top_name] full_chip_timing]
#@                                                 echoed [get_block_info [chip_top_name] path_groups]
#@                                             }
#@                                             
#@                                           }
#@                           top_only_timing  {
#@                                             # W.....g: A non-unate path in clock network for clock 'core_clock' ... (TIM-052) (10 off)
#@                                             if { $running_design_compiler  } {
#@                                                 suppress_message TIM-052
#@                                             }
#@                                             # SPONG - is this true even in the Agere blocks?
#@                                             # Else need a list of all our static control clock muxes (which you can get by setting this var false)
#@                                             # set timing_disable_clock_gating_checks true
#@                                             
#@                                             # set_disable_timing {E/lcpref_gp_regs_out*}
#@                                             
#@                                             # configure the core clock divider
#@                                             # set_case_analysis 0 [get_pins T/qdr_clock_divider_bypass]
#@                                             # set_case_analysis 1 [get_pins T/qdr_clock_divider_reset]
#@                                             
#@                                             # Enable functional path through serdes test logic
#@                                             # Disable timing through test paths 
#@                                             # hopefully these propagate
#@                                             #  set_case_analysis 0 BRCMTESTMODE0 
#@                                             #  set_case_analysis 0 BRCMTESTMODE1 
#@                                             #  set_case_analysis 0 BRCMTESTMODE2 
#@                                             
#@                                             # group_path -name default_inputs  -from [all_inputs]
#@                                             # group_path -name default_outputs -to   [all_outputs]
#@                                             
#@                                             }
#@                           full_chip_timing {
#@                                                 # FULL_CHIP_TIMING
#@                                                 
#@                                                 map_vendor_pin_names
#@                                                 
#@                                                 suppressed {SEL-004 SEL-005} {
#@                                                     disable_memoir_211hd_cka_ckb_paths
#@                                                   # disable_memoir_power_gating_paths
#@                                                 }
#@                                                 
#@                                                 # LCP/FCX clocks and io timing as for fcx and lcp subchips
#@                                                 
#@                                                 echoed {eval [get_block_info fcx3_oversampler      timing]}
#@                                                 echoed {eval [get_block_info fcx2_top         fcx2_timing]}
#@                                                 echoed {eval [get_block_info lcp_top               timing]}
#@                                                 
#@                                                 # Fastest possible sbus_ctrl_clock is 500 MHz
#@                                                 # Fastest possible sbus_clock is 200 MHz (from sbus_ctrl_clock = 400 MHz = lcprefclock/2)
#@                                                 # (These do not occur at the same time)
#@                                                 
#@                                                 create_avago_sbus_ctrl_clock    sbus_ctrl_clock
#@                                                 create_all_avago_sbus_clocks    2.5 {8 2 2 2 2} 
#@                                                 
#@                                                 if { $design_name == {q6core} } {
#@                                                 
#@                                                     # We also have external sbus clocks
#@                                                     puts "create external avago sbus clocks:"
#@                                                     set scc_period         2.5
#@                                                     set sbus_clock_divider 2
#@                                                     set x ext
#@                                                     echoed "create_clock -period [expr $scc_period*$sbus_clock_divider] -waveform \{0 [expr $scc_period * ( $sbus_clock_divider / 2 )] \} -name sbus_clock_$x \[get_ports ext_sbus_in_CLK\]"
#@                                                     
#@                                                     echoed "  set_clock_uncertainty -setup 0.110 \[get_clocks sbus_clock_$x\]"
#@                                                     echoed "  set_clock_uncertainty -hold  0.040 \[get_clocks sbus_clock_$x\]"
#@                                                     echoed "  set_propagated_clock \[get_clock sbus_clock_$x\]"
#@                                                     
#@                                                     set_input_delay 0 [remove_from_collection [get_ports {ext_sbus_in_*}] {ext_sbus_in_CLK}] -clock sbus_clock_ext
#@ 
#@                                                     # SPONG: Implement this more generically somehow
#@                                                     if { [exists_and_true postlayout_netlist] } {
#@                                                         suppressed {SEL-004} {
#@                                                             source /work/msmallwo/syn/q6chip/syn/runs6/avago_200328_top/results/q6chip_compile_q6core.flat_false_paths.tcl
#@                                                         }
#@                                                     }
#@ 
#@                                                 }
#@ 
#@                                                 #################################################################################
#@                                                 # general top level fixes
#@                                                 
#@                                                 # stats a_reset - incorporated in lcpregs mcp paths below
#@                                                 
#@                                                 #set_multicycle_path 50 -setup -through [get_pins T*/async_reset]                                                
#@                                                 #set_multicycle_path 40 -hold  -through [get_pins T*/async_reset]                                                
#@                                              
#@                                                 # Async from/to the LCP40G regs
#@ 
#@                                                 #set_max_delay  14.0 -through [get_pins L/lcpref_gp_regs_out*]
#@                                                 #set_min_delay  -2.0 -through [get_pins L/lcpref_gp_regs_out*]
#@                                                 echoed "set_multicycle_path  50 -setup -start -through \[get_pins [fixpath L/lcpref_gp_regs_out*]\]"
#@                                                 echoed "set_multicycle_path  50 -hold         -through \[get_pins [fixpath L/lcpref_gp_regs_out*]\]"
#@                                                 
#@                                                 # GPIO 
#@                                                 
#@                                                 echoed "set_max_delay 15.0 -from \[get_ports GPIO_*] -through \[get_pins [fixpath E/a_gpio_from_pins*]\]"
#@                                                 echoed "set_min_delay -1.0 -from \[get_ports GPIO_*] -through \[get_pins [fixpath E/a_gpio_from_pins*]\]"
#@                                                 
#@                                                 set_max_delay 15.0 -to   [get_ports GPIO_*] -from [get_clocks core_clock]
#@                                                 set_min_delay -1.0 -to   [get_ports GPIO_*] -from [get_clocks core_clock]
#@                 
#@                                                 set_max_delay  6.0 -to   [get_ports FCX_*]
#@                                                 set_min_delay -1.0 -to   [get_ports FCX_*]
#@                                                 
#@                                                 #################################################################################
#@                                                 # Block level exceptions
#@                                                 
#@                                                 # SPONG: REMOVE THESE IF AT ALL POSSIBLE
#@                                                 
#@                                                 set ports {alt_ft_mode base_torrent local_index}
#@                                                 set num 3
#@                                                 foreach p $ports {
#@                                                     echoed "set_multicycle_path $num          -through \[get_pins [fixpath DMBUF*/U_*/${p}] \] -setup"
#@                                                     echoed "set_multicycle_path [expr $num-1] -through \[get_pins [fixpath DMBUF*/U_*/${p}] \] -hold"
#@                                                 }
#@                                                 
#@                                                 set num 5
#@                                                 echoed "set_multicycle_path $num          -setup -through \[get_pins [fixpath D*/torrent_index]\]"
#@                                                 echoed "set_multicycle_path [expr $num-1] -hold  -through \[get_pins [fixpath D*/torrent_index]\]"
#@                                                 
#@                                                 # Mbist
#@                                                 
#@                                                 set mbist_mcp 10
#@                                                 set mbist_status_endpoints "\[get_pins {*/mbist_status_reg*/d}\]"
#@                                                 echoed "    set_multicycle_path $mbist_mcp            -setup -to $mbist_status_endpoints"
#@                                                 echoed "    set_multicycle_path [expr $mbist_mcp - 1] -hold  -to $mbist_status_endpoints"
#@                                                 echoed "    group_path          -name to_mbist_status_cells  -to $mbist_status_endpoints"
#@                                                 
#@                                                 # HBM Phy setup
#@                                                 
#@                                                 setup_hbm_phy hbm_fifo_enabled 1
#@                                                 
#@                                                 # Additional Sbus bits level bits
#@ 
#@                                                 set_false_path -from [get_clocks ext_sbus_ctrl_clock] -to [get_clocks pmro_clock]
#@                                             #   set_false_path -from [get_clocks *sbus_clock*]        -to [get_clocks *spico_clock]
#@                                                 suppressed SEL-004 {
#@                                                   # set_false_path -through [get_pins {*sbus_master_U/i_sbm_ring*}]
#@                                                     set_false_path -through [get_pins {*sbus_master_U/TEST__* DMFE*/U_sbmstr/U_sbus_master/U/TEST__*}]
#@                                                 }
#@                                                 
#@                                                 set_false_path -from [get_clocks tap_dft_clock]   -to [get_clocks {*spico_clock *sbus_clock*}]
#@                                                 set_false_path -to   [get_clocks tap_dft_clock] -from [get_clocks {*spico_clock *sbus_clock*}]
#@                                                 
#@                                                 # set num_serdes 64
#@                                                 # set num_ssides  2
#@                                                 # set num_psides  2
#@                                                 # set num_torrs   2
#@                                                 # 
#@                                                 # set num_per_torr [expr $num_serdes   / $num_torrs ]
#@                                                 # set num_per_sside [expr $num_per_torr / $num_ssides ]
#@                                                 # set num_per_pside [expr $num_per_torr / $num_psides ]
#@                                                 # 
#@                                                 # for {set i 0} {$i < $num_serdes} {incr i} {
#@                                                 # 
#@                                                 #     set schan [expr $i % $num_per_sside ]
#@                                                 #     set sside [expr ($i / $num_per_sside) % $num_ssides]
#@                                                 #     set pchan [expr $i % $num_per_pside ]
#@                                                 #     set pside [expr ($i / $num_per_pside) % $num_psides]
#@                                                 #     if { $num_torrs > 1 } {
#@                                                 #        set torr [expr $i / $num_per_torr]
#@                                                 #     } else {
#@                                                 #        set torr ""
#@                                                 #     }                                                    
#@                                                 #     set baud_rate_multiplier 32
#@                                                 # 
#@                                                 #     # Serdes rx timing
#@                                                 # 
#@                                                 #     my_set_cell_mode {RX_FIFO_F64_PAM4 RX_F64_PAM4 PB_TX_F64_PAM4} [get_cells [fixpath X$torr/SERDES_$sside/CM4_$schan/U/U]]
#@                                                 #     set phase_shift_bauds 14
#@                                                 # 
#@                                                 #     create_avago_rx_launch_clock serdes_rx_launch_clock_$i serdes_rx_clock_$i $baud_rate_multiplier $phase_shift_bauds
#@                                                 #     
#@                                                 #     # Serdes Tx timing
#@                                                 # 
#@                                                 #     if { $num_torrs > 1 } {
#@                                                 #         set xpl_clock [get_clocks xpl_clock_[format %c [expr 97 + $torr]]]
#@                                                 #     } else {
#@                                                 #         set xpl_clock [get_clocks xpl_clock]
#@                                                 #     }
#@                                                 #     if { $num_psides > 1 } {
#@                                                 #         set pside "_$pside"
#@                                                 #     } else {
#@                                                 #         set pside ""
#@                                                 #     }
#@                                                 #     set pb_cellname [fixpath "X$torr/XPL2PHYS$pside/XPL2PHYS_$pchan/xpl_serdes_tx_code_reg_0_BEACON"]
#@                                                 # 
#@                                                 #     set setup_uncertainty_value [lindex {0.380 0.354} $torr]
#@                                                 #     set hold_uncertainty_value  [lindex {0.385 0.359} $torr]
#@                                                 #     set early_clock_edge 15
#@                                                 # 
#@                                                 #     create_avago_phase_beacon_clocks serdes_tx_$i $pb_cellname $xpl_clock $baud_rate_multiplier $early_clock_edge {} "$setup_uncertainty_value $hold_uncertainty_value"
#@                                                 # }
#@                                                 #
#@                                                 # foreach dmfe {A B} {
#@                                                 #   
#@                                                 #     set sbus_clock      sbus_clock_*
#@                                                 #     set dram_x2_clock   dram_x2_clock_[string tolower $dmfe]
#@                                                 #     set dram_clock      dram_clock_[string tolower $dmfe]
#@                                                 #     set dram_div2_clock dram_div2_clock_[string tolower $dmfe]
#@                                                 #     set dram_divn_clock dram_divn_clock_[string tolower $dmfe]
#@                                                 #     
#@                                                 #     # SPONG: There are all sorts of timing in the HBM phy that we don;t want to test here (yet)
#@                                                 #     
#@                                                 #     echoed "set_false_path -from \[get_clocks $dram_x2_clock\]"
#@                                                 #     echoed "set_false_path -to   \[get_clocks $dram_x2_clock\]"
#@                                                 #     
#@                                                 #     echoed "set_false_path -from \[get_clocks $dram_divn_clock\]"
#@                                                 #     echoed "set_false_path -to   \[get_clocks $dram_divn_clock\]"
#@                                                 #     
#@                                                 #     array set phy_clock_latency { wc 0.350 bc 0.200 }
#@                                                 #     regexp {wc|bc} $operating_conditions bcwc
#@                                                 #     set latency $phy_clock_latency($bcwc)
#@                                                 #      
#@                                                 #     if { ! [exists_and_true postlayout_netlist] } {
#@                                                 #         # We have to balance the ideal clocks on the dmfe_core
#@                                                 #         foreach pin {CLK_1500 CLK_2X CLK_DIV2 DFI_CLK} {
#@                                                 #             # set_annotated_delay -net -to [get_pins [fixpath "DMFE${dmfe}/PHY/U_hbm/U $pin"]] -0.5
#@                                                 #             echoed "set_clock_latency -$latency \[get_pins [fixpath "DMFE${dmfe}/PHY/U_hbm/U $pin"]\]"
#@                                                 #         }
#@                                                 #         # foreach pin { dram_clock dram_div2_clock } {
#@                                                 #         #     echoed "set_clock_latency $latency \[get_pins DMFE${dmfe}_CORE/$pin\]"
#@                                                 #         # }
#@                                                 #     }
#@                                                 #     
#@                                                 # }
#@ 
#@                                                 if { $design_name == {q6core} } {
#@                                                 
#@                                                     #################################################################################
#@                                                     # Q6 Core level i/os (to the rest of the P6)
#@                                                     
#@                                                     set q6_core_clock_outputs { datapath_to_xpl2_rx*
#@                                                                                 datapath_to_xpl2_tx*
#@                                                                                 ecp_to_xpl2*
#@                                                                                 fcx2_to_sched_out*
#@                                                                                 ext_stats_request_out*
#@                                                                                 ext_stats_response_out*
#@                                                                                 ext_lcp40g_request*
#@                                                                                }
#@                                                                                 # Also, stats_ft_eastbound_xpl_out* ?
#@                                                                                                                                 
#@                                                     do_set_output_delay $q6_core_clock_outputs -group "q6_core_clock_outputs"
#@                                                 
#@                                                     set q6_core_clock_inputs {  xpl2_to_datapath_tx*
#@                                                                                 xpl2_to_datapath_rx*
#@                                                                                 t5_to_sched*
#@                                                                                 xpl2_to_ecp*
#@                                                                                 ext_lcp40g_response*
#@                                                                                 ext_stats_request_in*
#@                                                                                 ext_stats_response_in*
#@                                                                                 }
#@                                                                                 # Also, stats_ft_eastbound_xpl_in* ?
#@                                                                             
#@                                                     do_set_input_delay $q6_core_clock_inputs -group "q6_core_clock_inputs"
#@                                                 
#@                                                     # 'Other' ports from q6core
#@                                                     # external sbus master connections (direct)
#@                                                     set_input_delay 0 ext_sbus_master_resp_0* -clock ext_sbus_ctrl_clock
#@                                                     set_output_delay 0 ext_sbus_master_req*   -clock ext_sbus_ctrl_clock
#@                                                 
#@                                                     # external sbus master connections (ring)
#@                                                     set_input_delay 0 [remove_from_collection [get_ports ext_sbm_ring_in*] [get_ports ext_sbm_ring_in_ack]]  -clock ext_sbus_ctrl_clock
#@                                                     set_input_delay 0 ext_sbm_ring_out_ack*   -clock ext_sbus_ctrl_clock
#@                                                     set_output_delay 0 [remove_from_collection [get_ports ext_sbm_ring_out*] [get_ports ext_sbm_ring_out_ack]] -clock ext_sbus_ctrl_clock
#@                                                     set_output_delay 0 ext_sbm_ring_in_ack*   -clock ext_sbus_ctrl_clock
#@                                                 
#@                                                     # external sbus slave connections (ring)
#@                                                     # port ext_sbus_in_CLK is removed as it is the clock source
#@                                                     set_input_delay 0 [remove_from_collection [get_ports ext_sbus_in*]     [get_ports ext_sbus_in_CLK]    ]  -clock sbus_clock_ext
#@                                                     set_input_delay 0 ext_sbus_stall_in*      -clock sbus_clock_ext
#@                                                     set_output_delay 0 ext_sbus_out*          -clock sbus_clock_ext
#@                                                     set_output_delay 0 ext_sbus_stall_out*    -clock sbus_clock_ext
#@                                                 
#@                                                 
#@                                                     # And gpregs - inputs have async xings, so almost anything is ok ...
#@                                                     set_input_delay  0 q6_gp_regs_in*         -clock lcpref_clock
#@                                                     set_input_delay  0 ext_gp_regs_in*        -clock lcpref_clock
#@                                                     # and outputs are really all mcp, and have resunc at the other end, but here we can ...
#@                                                     set_output_delay 0 q6_gp_regs_out*        -clock lcpref_clock
#@                                                     set_output_delay 0 ext_gp_regs_out*       -clock lcpref_clock
#@                                                 }
#@                                                 
#@                 #                            ############################################################################################
#@                 #                            # test / dlbist paths
#@                 #                            # fix setup/hold to ff_i10 flops - really async paths - lots of margin
#@                 #                            # set_multicycle_path 3 -setup -to [get_pins -hier ff_i10/D]
#@                 #                            # set_multicycle_path 3 -hold  -to [get_pins -hier ff_i10/D]
#@                 #                            
#@                                           }
#@                           path_groups     { 
#@                                             # path groups 
#@                                             # to/from datapath
#@                                             group_path -name D0_to_Q   -through [get_pins [fixpath "D0 *"]]     -through [get_pins [fixpath "Q *"]]
#@                                             group_path -name D1_to_T   -through [get_pins [fixpath "D1 *"]]     -through [get_pins [fixpath "T* *"]]
#@                                             
#@                                             group_path -name Q_to_D0   -through [get_pins [fixpath "Q *"]]      -through [get_pins [fixpath "D0 *"]]
#@                                             group_path -name T_to_D0   -through [get_pins [fixpath "T* *"]]     -through [get_pins [fixpath "D0 *"]]
#@                                             
#@                                             # foreach idx {0 1} {
#@                                             #     set xpins [fixpath X${idx}/XPL2TOP/*]
#@                                             #     group_path -name D${idx}_to_C${idx}_0  -through [get_pins [fixpath "D${idx} *"]]    -through [get_pins [fixpath "C${idx}_0 *"]]
#@                                             #     group_path -name C${idx}_0_to_D${idx}  -through [get_pins [fixpath "C${idx}_0 *"]]  -through [get_pins [fixpath "D${idx} *"]]
#@                                             #     
#@                                             #     group_path -name D${idx}_to_X${idx}    -through [get_pins [fixpath "D${idx} *"]]    -through [get_pins $xpins]
#@                                             #     group_path -name X${idx}_to_D${idx}    -through [get_pins $xpins                    -through [get_pins [fixpath "D${idx} *"]]
#@                                             # 
#@                                             #     group_path -name X${idx}_to_C${idx}_1  -through [get_pins $xpins                    -through [get_pins [fixpath "C${idx}_1 *"]]
#@                                             #     group_path -name C${idx}_1_to_X${idx}  -through [get_pins [fixpath "C${idx}_1 *"]]  -through [get_pins $xpins]
#@                                             #     
#@                                             # }
#@ 
#@                                             # to/from ecp
#@                                             group_path -name E_to_Q    -through [get_pins [fixpath "E *"]]     -through [get_pins [fixpath "Q *"]]
#@                                             group_path -name Q_to_E    -through [get_pins [fixpath "Q *"]]     -through [get_pins [fixpath "E *"]]
#@                                             
#@                                             # to/from Scheduler
#@ 
#@                                             group_path -name Q_to_S    -through [get_pins [fixpath "Q *"]]     -through [get_pins [fixpath "SVW *"]]
#@                                             group_path -name S_to_Q    -through [get_pins [fixpath "SVW *"]]   -through [get_pins [fixpath "Q *"]]
#@  
#@                                           # group_path -name Q_to_S    -through [get_pins [fixpath "Q *"]]     -through [get_pins [fixpath "S *"]]
#@                                           # group_path -name Q_to_V    -through [get_pins [fixpath "Q *"]]     -through [get_pins [fixpath "V *"]]
#@                                           # group_path -name Q_to_W    -through [get_pins [fixpath "Q *"]]     -through [get_pins [fixpath "W *"]]
#@                                            
#@                                           # group_path -name S_to_Q    -through [get_pins [fixpath "S *"]]     -through [get_pins [fixpath "Q *"]]
#@                                           # group_path -name S_to_V    -through [get_pins [fixpath "S *"]]     -through [get_pins [fixpath "V *"]]
#@                                           # group_path -name S_to_W    -through [get_pins [fixpath "S *"]]     -through [get_pins [fixpath "W *"]]
#@                                             
#@                                           # group_path -name V_to_Q    -through [get_pins [fixpath "V *"]]     -through [get_pins [fixpath "Q *"]]
#@                                           # group_path -name V_to_S    -through [get_pins [fixpath "V *"]]     -through [get_pins [fixpath "S *"]]
#@ 
#@                                           # group_path -name W_to_Q    -through [get_pins [fixpath "W *"]]     -through [get_pins [fixpath "Q *"]]
#@                                           # group_path -name W_to_S    -through [get_pins [fixpath "W *"]]     -through [get_pins [fixpath "S *"]]
#@ 
#@                                             # to/from DMFEs
#@                                             set dmfepins [fixpath DMFE*/CORE/*]
#@                                           # foreach blk {C0_0 C0_1 C1_0 C1_1} {
#@                                           #     group_path -name ${blk}_to_DMFE -through [get_pins [fixpath "$blk *"]]      -through [get_pins $dmfepins]
#@                                           #     group_path -name DMFE_to_${blk} -through [get_pins [fixpath "$dmfepins]   -through [get_pins $blk *"]]
#@                                           # }
#@                                           
#@                                           #  foreach dmfe {A B C D} {
#@                                           #      group_path -name fromphydata_$dmfe -through [get_pins [fixpath "DMFE${dmfe}/CORE dram_phy2ctrl*"]]
#@                                           #      group_path -name tophydata_$dmfe   -through [get_pins [fixpath "DMFE${dmfe}/CORE dram_ctrl2phy*"]]
#@                                           #  }
#@ 
#@                                           }
#@                                           
#@                           clock_gating    disabled
#@                           compile         {
#@                                           # dont_touch [all_connected [get_ports M/TC/core_pll_clock_out]]
#@                                           # dont_touch [all_connected [get_ports M/TC/clkobs*clock]]
#@                                           # dont_touch [all_connected [get_ports M/TC/clkobs*clk]]
#@                                             dont_touch [all_connected [get_ports M/TC/lcp_request*CLOCK]]
#@                                           # dont_touch [all_connected [get_ports M/TC/lcp_test_clock]]
#@ 
#@                                             set_dont_touch_network -no_propagate [get_pins L/lcp_response*]
#@                                           # set_dont_touch_network -no_propagate [get_pins M/U_lcp_buffers/U_COREREFCLKP/U/U/CLK*]
#@                                           # set_dont_touch_network -no_propagate [get_pins X*/U_xpl_buffers/U_XPLREFCLKP/U/U/CLK*]
#@ 
#@                                           # set_compile_directives [get_cells * -hier -filter "@ref_name==sd16sbus_master_03_wrapper"] -constant_propagation false
#@                                             set_compile_directives [get_cells * -hier -filter "@ref_name==test_ctrl_elway"] -constant_propagation false
#@                                             
#@                                           # use_avago_top_cells
#@                                             eval [get_block_info default compile]
#@                                           }
#@                           top_level_path  {}
#@                         }
#@     P6              { 
#@                           timing          {
#@                                             # Mostly just as q6core ...
#@                           
#@                                             echoed [get_block_info [chip_top_name] timing]
#@                                             
#@                                             # And a handful of things for P6 level only
#@ 
#@                                             set_false_path -from [get_clocks ext_sbus_ctrl_clock] -to [get_clocks P_*RESCAL*/i_refclk_div*]
#@                                             set_false_path -from [get_clocks tap_dft_clock]  -through [get_pins -hier *PLL_U/o_*]
#@                                             
#@                                             set_false_path -through [get_pins P_SBUS_MASTER_0_U_sbus_master_U/sbus_interrupt_in] -to [get_clocks ext_spico_clock]
#@                                             
#@                                             # Now boring IOs
#@                                            
#@                                             # JTAG
#@                                             set_max_delay 30 -from [get_ports TCK]
#@                                             set_max_delay 30 -from [get_ports "TMS TRST_L TDI"]
#@                                             set_max_delay 10 -to   [get_ports TDO]
#@                                             
#@                                             # Also we can prevent a bunch of warn\ings in repblock, with this ..
#@                                             
#@                                             set clocks_known_to_have_no_uncertainty_set {P_SXPL_* P_SXPLB_* P_SSWF_*}
#@                                             
#@                                           }
#@                           top_level_path  {}
#@                         }
#@         
#@ 
#@     # {MISCELLANEOUS {no longer really used}}
#@                         
#@     spork_core          { lib               spork
#@                           timing            { 
#@                                               eval [get_block_info default timing]
#@                                               set_output_delay 0.60 [get_ports {cmd* probe_data* regfile_request_WRDATA*}]
#@                                             }
#@                          }
#@                          
#@     }
#@ 
#@ # Post test insertion wrapper around each block
#@ 
#@ puts "version = '$version'"
#@ 
#@ proc is_top_level ver {
#@     return [regexp {((compile_|prefloorplan_|floorplan_|pcompile_)top)|(^(top|q\dchip|q\dcore|P6))|((q\dchip|q\dcore|P6|dmfe_\d)$)} $ver]
#@     # covers top_xpl, top_ecp etc. also dmfe_0
#@ }
#@ 
#@ if { [is_top_level $version] } {
#@     lappend suppress_errors LINK-1
#@     suppress_message {LBR-1 LINK-5 UID-341}
#@ }
#@ 
#@ if { ( [is_top_level $version] || [regexp {fcx2_top} $version] ) && [regexp {bc$|bc_cold$} $analysis_type] } {
#@     puts "Want cold library cell for fcx2_top memories"
#@     set lib [lsearch -inline $link_library *PM7SC111HC1024X18R20211VTLUS11LLEBC*]
#@     if { ! [regexp {_t-40_} $lib] } {
#@         puts "Warn\ing: Special fcx2_top cold mem model not found for '$lib'"
#@     }
#@ }
#@ 
#@ ### block specific path fixes
#@ 
#@ 
#@ proc global_exists_and_true {varname} {
#@     global $varname
#@     return [exists_and_true $varname]
#@ }
#@ set debug_fixpaths [exists_and_true debug_fixpaths]
#@ 
#@ proc fixpath {path {strip 1}} {
#@ 
#@     global preflatten_netlist
#@     global ilm_block_names
#@ 
#@     global debug_fixpaths
#@     
#@     # Remove duplicate spaces
#@     regsub { +} $path { } path
#@     regsub { $} $path {} path
#@     
#@     if { [llength $path] == 2 } {
#@         set pinname [lsecond $path]
#@         set path    [lfirst $path]
#@         if { $debug_fixpaths } { puts "Explicit pinname ................................ : '' '$path' '$pinname'" }
#@     }
#@     
#@     set str {^(Q[_/])?(Q|SVW|T[_\/]T([0-9]+)|E|F|L|D.|C._.|X..(XPL2TOP|XPL2PHYS_.|U_xpl_pll)|DMFE..(CORE|PLL|PHY.U_hbm.U)|DMBUF..U_.|M.TC.(U_core_pll)|(M.U_.*buffers)|FCXREF_PLL|XYZ)(/| |$)}
#@ 
#@     if { ! [exists_and_true preflatten_netlist] } {
#@     
#@         if { $debug_fixpaths } { puts "Start Path Is ................................... : '$path'" }
#@         
#@         # now flatten paths
#@         
#@         # first remove leading subchip hierarchy if any
#@         
#@         set head {}
#@         if { [regexp $str $path head] } {
#@             regsub $str $path "" path
#@         
#@             if { $debug_fixpaths } { puts "Split Into   .................................... : '$head' '$path'" }
#@         
#@             # Next tidy the head (and move any trailing / to the path)
#@             regsub { $} $head {} head
#@             if { [regsub {/$} $head {} head] } {
#@                 set path /$path
#@             }
#@             if { ($path != {}) && ! [regexp {^/} $path] } {
#@                 set path /$path
#@             }
#@ 
#@             if { $debug_fixpaths } { puts "Corrected to .................................... : '$head' '$path'" }
#@         } else {
#@             if { $debug_fixpaths } { puts "No subchip hierarchy found ...................... : '$head' '$path'" }
#@         }
#@                 
#@         if { [info exists pinname] } {
#@         
#@             set cell_path $path
#@             if { $pinname != {} } {
#@                 set pinname  /$pinname
#@             }
#@             regsub {/$} $cell_path {} cell_path
#@             if { $debug_fixpaths } { puts "Explicit pinname ................................ : '$head' '$cell_path' '$pinname'" }
#@             
#@         } elseif {[regexp {^(A|B|C|D|E|F|G|H|CK[0-3]|CK_OUT|clk_.ll_fd._.|DivN|rx_fifo_clk|ADRR\[\*|ADRW\[\*|BWE\[\*|BIST_DONE\*|CLR_N|CK|CLK|phi|ck[0..3]|ck_out|CO|CI|CORE_MEM_RST|CORE_BIST_\*|COL_REDN_\*|D0|D1|D\[\*|d|o|i|i\d|MER|MEW|PRE_N|Q|QN|Q\[\*|q|ROW_REDN_\*|REDN_CLK_SEL|SE|SI|SEL1|SELD|sel[0..1]|TEST__\*|resetb)$} [filename $path]]} {
#@         
#@             # matches certain well known pin names and a few not quite so cell known ones:
#@             #    pad_refclkn is serdes clock pin
#@             
#@             set cell_path [dirname $path]
#@             set pinname  /[filename $path]
#@             if { $debug_fixpaths } { puts "Auto detected pinname  .......................... : '$head' '$cell_path' '$pinname'" }
#@             
#@         } else {
#@         
#@             # assume its a cell name
#@             
#@             set cell_path $path
#@             set pinname {}
#@             if { $debug_fixpaths } { puts "No pinname detected  ............................ : '$head' '$cell_path' '$pinname'" }
#@             
#@         }
#@         
#@         # Or add a special path prefix for P6 level analysis
#@         if { [get_object_name [current_design]] == {P6} } {
#@             if { $head != {} } {
#@                 if { ! [regexp {^Q[/_]} $head] } {
#@                     set head Q/$head
#@                 }
#@             } elseif { $path != {} } {
#@                 # Mostly we can assume the cell is top level, and thus (in the P6 case) wants to be prepended with the Q_, unless ...
#@                 if { ! [regexp {^P_} $cell_path] } {
#@                     set cell_path Q/$cell_path
#@                 }
#@             }
#@             if { $debug_fixpaths } { puts "Special P6 head adjustment ...................... : '$head' '$cell_path' '$pinname'" }
#@         }
#@         
#@         # and now remove unwanted /s, but leave the one on the front of cell_path (and the very occasional one on the end)
#@         regsub -all "/"  $head      "_" head
#@         
#@         regsub -all "/"  $cell_path "_" cell_path
#@         regsub -all {^_} $cell_path "/" cell_path
#@         regsub -all {_$} $cell_path "/" cell_path
#@        
#@         if { $debug_fixpaths } { puts "Replace all unwanted '/'s `...................... : '$head' '$cell_path' '$pinname'" }
#@         
#@         set path ${cell_path}
#@         
#@         # and back with its head
#@         set path "${head}${path}${pinname}"
#@         
#@         if { $debug_fixpaths } { puts "end path is ..................................... : '$path'" }
#@        
#@     } else {
#@     
#@         if { [info exists pinname] } {
#@             set path "$path/$pinname"
#@         }
#@         
#@         # Or add a special path prefix for P6 level analysis
#@         # if { ( [get_object_name [current_design]] == {P6} ) && ! [regexp "^Q/." $path] } {
#@         #     set path "Q/$path"
#@         # }
#@         
#@     }
#@     
#@     # Then Strip Off any leading pattern
#@     if { $strip } {
#@         if { [lsearch $ilm_block_names [get_object_name [current_design]]] != -1 } {
#@             regsub $str $path {} path
#@         }
#@     }
#@     
#@     # fix up xpl hierarchy
#@     
#@     if { ! [exists_and_true preflatten_netlist] } {
#@         regsub {^X(.)/XPL2TOP} $path {X\1_XPL2TOP} path
#@         regsub {^X(.)/XPL2PHYS_(.)} $path {X\1_XPL2PHYS_\2} path
#@         regsub {^X/U_q(.)_serdes_brcm/U_XPL_XGXS_(.)/XGXS_IP} $path {X_U_q\1_serdes_brcm_U_XPL_XGXS_\2_XGXS_IP} path
#@         regsub {^B_TEST/u_otpc} $path {B_TEST_u_otpc} path
#@     }
#@     
#@     # fix up xpl CTC hierarchy (that's inside the dmfe_core block, but nt ungrouped)
#@     # if { ! [exists_and_true preflatten_netlist] } {
#@     #     regsub {CTC_U_U_} $path {CTC_U_U/} path
#@     # }    
#@     
#@     # fix up fcx ALDL hierarchy (that's inside the fcx3_oversampler block, but nt ungrouped)
#@     # if { ! [exists_and_true preflatten_netlist] } {
#@     #     regsub {ALDL_ALDL_([0-9]+)_} $path {ALDL_ALDL_\1/} path
#@     # }    
#@     
#@     if { $debug_fixpaths } { puts "Final Path Is ................................... : '$path'" }
#@     return $path
#@ }
#@ 
#@ proc fixpaths {paths {strip 1}} {
#@ 
#@     set new {}
#@     foreach p $paths {
#@         lappend new [fixpath $p $strip]
#@     }
#@     return $new
#@ }
#@ 
#@ #############################################################
#@ #
#@ # Clocks
#@ #
#@ 
#@ # removed the following clocks from after scifm_clock (below)
#@ # dmfe_dll_bist_clock
#@ # stats_dll_bist_clock
#@ # ecp_dll_bist_clock
#@ # scif, scifm
#@ # xpltwc_clock
#@ 
#@ # clock info
#@ # clock_name > period                ns
#@ #             setup_uncertainty      > default|blockname > {prelayout postlayout_OCV} values
#@ #             hold unceratinty       ns
#@ #             vrt clock latency      > blockname         > wc bc values
#@ #             source latency         > blockname         > wc values > early - appleas even without OCV
#@ #                                                        > bc values > late
#@ #
#@ #    each source_pins pinlist contains {srcpin, drvpin/ideal, master_pin_for_generated_case}
#@ #    source pins are searched first and clocks added if found, otherwise try portnames
#@ 
#@ array unset clock_info
#@ 
#@ 
#@ set phy_fifo_clk_names { "C04_DW" "C04_DW" "C04_DW" "C04_DW"
#@                          "C15_DW" "C15_DW" "C15_DW" "C15_DW"
#@                          "C26_DW" "C26_DW" "C26_DW" "C26_DW"
#@                          "C37_DW" "C37_DW" "C37_DW" "C37_DW"
#@                          "C0145_AW" "C2367_AW" }
#@ 
#@ set phy_fifo_clk_extensions  { "_0" "_1" "_2" "_3" 
#@                                "_0" "_1" "_2" "_3" 
#@                                "_0" "_1" "_2" "_3" 
#@                                "_0" "_1" "_2" "_3" 
#@                                "" ""}
#@ set phy_fifo_clk_extensions2 { "[0]" "[1]" "[2]" "[3]" 
#@                                "[0]" "[1]" "[2]" "[3]" 
#@                                "[0]" "[1]" "[2]" "[3]" 
#@                                "[0]" "[1]" "[2]" "[3]" 
#@                                "" ""}
#@ 
#@ array set clock_info {
#@     core_clock      { period                { default               0.833
#@                                             }
#@                       setup_uncertainty     { default               { 0.233 0.100 }
#@                                               P6                    0.050
#@                                               q6core                0.050
#@                                               q6chip                0.050
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       portnames             { { core_clock_in     {} }
#@                                               { core_clock        {} }
#@                                               { core_clock__LEQ*  {} }
#@                                               { clock_in          {} }
#@                                               { {clock_a clock_b} {} }
#@                                               { sysclk            {} }
#@                                             }
#@                       source_pins           { {M/TC/U_core_pll/PLL/PLL/U/clk_pll_fd1_0 {} }
#@                                               {{P_CORE_PLLS clock}                     {} }
#@                                             }
#@                       virtual_clock_latency { 
#@                                               default               { 0.0 analpld }
#@                                               q6core                { 0.0 0.35    }
#@                                               q6chip                {}
#@                                               P6                    { 0.0 0.0     }
#@                                             }
#@                       generated             0
#@                     }
#@    dll_bist_clock  { # {Just for the aldl_wrapper compile. Period as core_clock}
#@                       period                0.950
#@                       setup_uncertainty     { default               { 0.250 0.100 }
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       portnames             { { dll_bist_clock {} }
#@                                             }
#@                       source_pins           { }
#@                       generated             0
#@                       virtual_clock_latency { }
#@                     }
#@     lcpref_clock    { period                1.00
#@                       setup_uncertainty     { default               { 0.200 0.125 }
#@                                               P6                    { 0.100 0.100 }
#@                                               q6core                { 0.100 0.100 }
#@                                               q6chip                { 0.100 0.100 }
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             { { lcpref_clock      {}                                            }
#@                                               { lcpref_clock_in   TESTCLKMUX_LCPREF/MUX_dont_touch/CK_OUT       }
#@                                               { LCPREFCLKP        {M/U_lcp_buffers/U_LCPREFCLKP/U/U/CLK 
#@                                                                      U_lcp_buffers/U_LCPREFCLKP/U/U/CLK
#@                                                                                    U_LCPREFCLKP/U/U/CLK}        }
#@                                             }
#@                       generated             0
#@                       virtual_clock_latency {
#@                                              #q6chip                {0.700 0.700}
#@                                               default               { 0.0 analpld }
#@                                               P6                    { 0.0 }
#@                                               q6core                { 0.0 }
#@                                               q6chip                { 0.0 }
#@                                             }
#@                     }
#@     lcprx_clock     { period                2.0
#@                       setup_uncertainty     { default               0.650
#@                                               P6                    0.500
#@                                               q6core                0.500
#@                                               q6chip                0.500
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             { { lcprx_clock         {} }
#@                                               { LCPINNCLK           {} N }
#@                                               { lcp_request_N_CLOCK {} N }
#@                                             }
#@                       generated             0
#@                       propagated            { lcp_top q6core q6chip }
#@                       virtual_clock_latency { }
#@                       #REVIEW {seems to exhibit two latencies one through the E/LCP40G/fe/RESETRESYNCP/RETIME/U1_reg/CK}
#@                       virtual_ref0_clock    { lcp_top q6core q6chip P6}
#@                     }
#@     lcprx_p_clock   { period                2.0
#@                       waveform              { default               {1.000 2.000}
#@                                             }
#@                       setup_uncertainty     { default               0.650
#@                                               P6                    0.500
#@                                               q6core                0.500
#@                                               q6chip                0.500
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             { { LCPINPCLK {} N }
#@                                               { lcp_request_P_CLOCK {} N }
#@                                             }
#@                       generated             0
#@                       propagated            { lcp_top q6core q6chip }
#@                       virtual_clock_latency { }
#@                       virtual_ref0_clock    { lcp_top q6core q6chip P6}
#@                     }
#@     fcx_clock       { repeat                {0 7 {fcx_clock_$n}}
#@                       period                1.9
#@                       setup_uncertainty     { default               0.650
#@                                               P6                    0.500
#@                                               q6core                0.500
#@                                               q6chip                0.500
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             { 
#@                                               { {FCX_[expr $n * 2]}    {} N no_propagate}
#@                                               { {fcx_in_[expr $n * 2]} {} N no_propagate}
#@                                               { {fcx_clock_$n}         {} N no_propagate}
#@                                             }
#@                       generated             0
#@                       propagated            { fcx2_receiver_fcx fcx2_rx_common fcx2_top q6core q6chip }
#@                       virtual_clock_latency { }
#@                       virtual_ref0_clock    { fcx_receiver_fcx fcx2_rx_common fcx2_top q6core q6chip P6 }
#@                       virtual_ref0_clock_ddr 1
#@                     }
#@     fcxref_clock_raw {
#@                       period                 0.95
#@                       waveform              { default               {0.000 0.475}
#@                                             }
#@                       setup_uncertainty     { default               0.200
#@                                               q6core                0.200
#@                                               q6chip                0.200
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       portnames             { { {fcxref_clock_raw} {} N Y}
#@                                             }
#@                       generated             0
#@                       source_pins           { }
#@                       #propagated           { fcx2_top }
#@                       #source_latency       { default { {0.150 -0.150} {0.150 -0.150} } }
#@                       virtual_clock_latency { default {} }
#@                     }
#@     fcxref_clock    {
#@                       period                0.95
#@                       setup_uncertainty     { default               {0.200 0.100}
#@                                               P6                    {0.200 0.075}
#@                                               q6core                {0.200 0.075}
#@                                               q6chip                {0.200 0.075}
#@                                             }
#@                       hold_uncertainty      { default               {0.030 0.025} }
#@                       source_pins           { { {FCXREF_PLL/PLL/PLL/U   o_aux_clkout_div2_p} {} }
#@                                               { {Q/FCXREF_PLL/PLL/PLL/U o_aux_clkout_div2_p} {} }
#@                                             }
#@                       portnames             { { {fcxref_clock} {} }
#@                                             }
#@                       generated             0
#@                       virtual_clock_latency {
#@                                               default { {0.279 0.180} {analpld} }
#@                                               P6      { {0.279 0.180} {}        }
#@                                               q6core  { {0.279 0.180} {}        }
#@                                               q6chip  { {0.279 0.180} {}        }
#@                                             }
#@                     }
#@     sdl_test_clock  { # {another (phase shifted) version of fcxref_clock}
#@                       period                0.975
#@                       setup_uncertainty     { default               0.200
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { 
#@                                               { FCXREF_PLL/TESTCLKBUF/U/o            {} }
#@                                               {{Q_FCXREF_PLL/cc_fcx_pll_test_clock_out CLK_OUT} {} } 
#@                                             }
#@                       portnames             { { sdl_test_clock {} N }
#@                                             }
#@                       propagated            { fcx3_oversampler_alt
#@                                               fcx3_oversampler
#@                                               fcx2_rx_common
#@                                               fcx2_top
#@                                               q6core
#@                                               q6chip
#@                                              }
#@                       generated             0
#@                     }
#@     dram_x2_clock   { repeat                {0 -1/-1 {dram_x2_clock_[format %c [expr 97+$n]]}}
#@                       period                { default                0.275
#@                                             }
#@                       setup_uncertainty     { default                0.050
#@                                               q6core                 0.050
#@                                               q6chip                 0.050
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { { DMFE[format %c [expr 65+$n]]/PLL/PLL/PLL/U/clk_pll_fd1_0 ideal }
#@                                             }
#@                       portnames             { { SPONG  {} }
#@                                             }
#@                       generated             0
#@                     }
#@     #dram_clock     { repeat                {0 -1/-1 {dram_clock_[format %c [expr 97+$n]]}}
#@                       period                { default                0.55
#@                                             }
#@                       setup_uncertainty     { default                { 0.100 0.100 }
#@                                               q6core                 0.050
#@                                               q6chip                 0.050
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { { DMFE[format %c [expr 65+$n]]/PLL/PLL/PLL/U/clk_pll_fd2_0 ideal }
#@                                             }
#@                       portnames             { }
#@                       virtual_clock_latency { 
#@                                               default               { 0.0 analpld }
#@                                               q6core                {}
#@                                               q6chip                {}
#@                                             }
#@                       generated             0
#@                     }
#@     dram_div2_clock { period                { default                1.0
#@                                             }
#@                       setup_uncertainty     { default               { 0.100 0.100 }
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { PHY_U_hbm_U/DFI_CLK}
#@                       portnames             { { dram_div2_clock {} } }
#@                       virtual_clock_latency { }
#@                       generated             0
#@                     }
#@     dram_div2_clock_DMFE_CORE { 
#@                       repeat                {0 3/-1 {dram_div2_clock_[format %d $n]}}
#@                       period                { default                1.0 }
#@                       setup_uncertainty     { default                { 0.100 0.100 } }
#@                       hold_uncertainty      { default                { 0.030 0.025 } }
#@                       source_pins           { }
#@                       portnames             { { dram_div2_clock_[format %d $n]       {} }
#@                                               { dram_div2_clock_[format %d $n]__LEQ* {} }
#@                                             }
#@                       virtual_clock_latency { default                { 0.0 analpld } }
#@                       generated             0
#@                     }
#@     dram_div2_clock_TOP { 
#@                       repeat                { 0 -1/3 {dram_div2_clock_[format "%c" [expr 97+$n]]} }
#@                       period                { default                1.0 }
#@                       setup_uncertainty     { default               { 0.080 0.080} }
#@                       hold_uncertainty      { default               { 0.025 0.025} }
#@                       source_pins           { { [lindex { DMFEA/PHY/U_hbm/U/DFI_CLK
#@                                                           DMFEB/PHY/U_hbm/U/DFI_CLK
#@                                                           DMFEC/PHY/U_hbm/U/DFI_CLK
#@                                                           DMFED/PHY/U_hbm/U/DFI_CLK
#@                                                           } $n] }
#@                                             }
#@                       portnames             { }
#@                       virtual_clock_latency { default                {} }
#@                       generated             0
#@                     }
#@     #dram_divn_clock { repeat                {0 -1/-1 {dram_divn_clock_[format %c [expr 97+$n]]}}
#@                       period                { default               10.000
#@                                             }
#@                       setup_uncertainty     { default                0.200
#@                                               q6core                 0.050
#@                                               q6chip                 0.050
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { { DMFE[format %c [expr 65+$n]]/PLL/PLL/PLL/U/DivN ideal }
#@                                             }
#@                       portnames             { }
#@                       generated             0
#@                     }
#@ 
#@     #dmfe_phy_fifo_clocks { 
#@                       repeat                {0 17/-1 {DMFE[format "%c" [expr 65 + ($n / 18)]]_[lindex $phy_fifo_clk_names [expr $n % 18]]_DFI_CLK_OUT[lindex $phy_fifo_clk_extensions [expr $n % 18]]} }
#@                       period                { default                0.990 }
#@                       setup_uncertainty     { default               { 0.100 0.100 } }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { }
#@                       portnames             { { FROM_PHY_[lindex $phy_fifo_clk_names [expr $n % 18]]_FIFO_DFI_CLK[lindex $phy_fifo_clk_extensions [expr $n % 18]] {} } }
#@                       virtual_clock_latency { default                { 0.0 0.0 }}
#@                       generated             0
#@                     }
#@     #dmfe_phy_fifo_clocks_OUT { 
#@                       repeat                {0 -1/71 {DMFE[format "%c" [expr 65 + ($n / 18)]]_[lindex $phy_fifo_clk_names [expr $n % 18]]_DFI_CLK_OUT[lindex $phy_fifo_clk_extensions [expr $n % 18]]} }
#@                       period                { 0.95 }
#@                       setup_uncertainty     { default               { 0.050 0.050 } 
#@                                               q6core                { 0.050 0.050 }
#@                                               P6                    { 0.050 0.050 }
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { { DMFE[format "%c" [expr 65 + ($n / 18)]]/PHY/U_hbm/U/[lindex $phy_fifo_clk_names [expr $n % 18]]_FIFO_DFI_CLK_OUT[lindex $phy_fifo_clk_extensions2 [expr $n % 18]]
#@                                                 ideal
#@                                                 DMFE[format "%c" [expr 65 + ($n / 18)]]/PHY/U_hbm/U/DFI_CLK
#@                                               }
#@                                             }
#@                       portnames             { }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       1
#@                     }
#@     #dmfe_phy_fifo_clocks_IN { 
#@                       repeat                {0 -1/71 {DMFE[format "%c" [expr 65 + ($n / 18)]]_[lindex $phy_fifo_clk_names [expr $n % 18]]_DFI_CLK_IN[lindex $phy_fifo_clk_extensions [expr $n % 18]]} }
#@                       period                { 0.95 }
#@                       setup_uncertainty     { default               { 0.050 0.050 } 
#@                                               q6core                { 0.050 0.050 }
#@                                               P6                    { 0.050 0.050 }
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { { DMFE[format "%c" [expr 65 + ($n / 18)]]/PHY/U_hbm/U/[lindex $phy_fifo_clk_names [expr $n % 18]]_FIFO_DFI_CLK_IN[lindex $phy_fifo_clk_extensions2 [expr $n % 18]]
#@                                                 {}
#@                                                 DMFE[format "%c" [expr 65 + ($n / 18)]]/PHY/U_hbm/U/DFI_CLK
#@                                               }
#@                                             }
#@                       portnames             { }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       1
#@                     }
#@ 
#@     #dmfe_phy_fifo_clocks_nwest_wrapper { 
#@                       repeat                {0 4/-1 {phy_fifo_clks_[format %d $n]} }
#@                       period                { default                0.990 }
#@                       setup_uncertainty     { default               { 0.100 0.100 } }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { }
#@                       portnames             { { phy_fifo_clks_[format %d $n] {} } }
#@                       generated             0
#@                     }
#@ 
#@     csr_clock       { 
#@                       period                { default                1.0
#@                                             }
#@                       setup_uncertainty     { default                0.080
#@                                             }
#@                       hold_uncertainty      0.030
#@                       source_pins           { }
#@                       portnames             { { csr_clock {} } }
#@                       generated             0
#@                     }
#@     xpl_clock       { repeat                { 0 -1/1 {xpl_clock_[format %c [expr 97+$n]]}}
#@                       period                1.140
#@                       setup_uncertainty     { default               { 0.200 0.100 }
#@                                               xpl2_phys             { 0.200 0.050 }
#@                                               q6chip                0.050
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       portnames             { {xpl_clock       {}   }
#@                                               {xpl_clock__LEQ* {}   }
#@                                               {xpl_clock_in    {} N }
#@                                             }
#@                       source_pins           { {X${n}/U_xpl_pll/PLL/PLL/U/clk_dll_fd1_0 {} }
#@                                             } 
#@                       generated             0
#@                       propagated            { }
#@                       virtual_clock_latency { 
#@                                               default               { 0.0 analpld }
#@                                               q6chip                {}
#@                                             }
#@                     }
#@     xplref_clock    { repeat                { 0 1 {xplref_clock_[format %c [expr 97+$n]]}}
#@                       period                3.2
#@                       setup_uncertainty     { default               0.200
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             { {XPL[format %c [expr 65+$n]]REFCLKP {} }
#@                                             }
#@                       source_pins           { } 
#@                       generated             0
#@                       propagated            { q6chip }
#@                     }
#@     serdes_rx_clock   
#@                     { repeat                {0 0     serdes_rx_clock}
#@                      #repeat                {0 15/63 serdes_rx_clock_$n}
#@                       period                1.08
#@                       setup_uncertainty     { default               { 0.200 0.089 }
#@                                               q6chip                0.050
#@                                             }
#@                       hold_uncertainty      { default               { 0.030 0.025 } }
#@                       source_pins           { { {X[expr $n/32]/SERDES_[expr ($n % 32)/16]/CM4_[expr $n % 16]/U/U rx_f64_fifo_clk_pam4} {} }
#@                                             } 
#@                       tree_latency          { q6chip                0.400
#@                                             }
#@                       portnames             { {serdes_rx_clock_$n  {}}
#@                                               {rec_serdes_rx_clock_$n {}}
#@                                             }
#@                       generated             0
#@                       propagated            { }
#@                       virtual_clock_latency { }
#@                     }
#@     sbus_clock {      # {used for block level compiles only}
#@                       period                5.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.050
#@                       portnames             { { sbus_clk_in {} }
#@                                               { sbus_in_CLK {} }
#@                                             }
#@                       source_pins           { }
#@                      #propagated            { dmfe_core dmfe_core_bis }
#@                       generated             0
#@                     }
#@     ext_spico_clock {  # {according to sbus master documentation (160202), max freq is 350 MHz}
#@                       period                3.0
#@                       waveform              { default              {0.0 1.0} }
#@                       setup_uncertainty     { default               0.300    }
#@                       hold_uncertainty      0.030
#@                       portnames             { spico_clock
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_0/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       2
#@                     }
#@     ext_sbus_ctrl_clock {
#@                       period                2.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             { sbus_master_clock
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_1/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       2
#@                     }
#@     pmro_clock {      # {according to documentation (150925), max freq is 500 MHz}
#@                       period                2.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             {
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_2/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       2
#@                     }
#@     tap_dft_clock {   # {according to documentation (150925), freq range is 10 MHz and 45 MHz}
#@                       period                28.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             {
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_3/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       28
#@                     }
#@     sensor_clock {    # {according to documentation (150925), freq range is 20 MHz to 2 GHz}
#@                       period                2.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             {
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_5/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       2
#@                     }
#@     spico_clock {     # {according to sbus master documentation (160202), max freq is 350 MHz}
#@                       period                3.0
#@                       waveform              { default              {0.0 1.0} }
#@                       setup_uncertainty     { default               0.300    }
#@                       hold_uncertainty      0.030
#@                       portnames             {
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_6/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       2
#@                     }
#@     sbus_ctrl_clock {
#@                       period                2.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             {
#@                                             }
#@                       source_pins           { { L/LCP40G/regs/slow_clock_reg_7/q {} {[get_ports LCPREFCLKP]} }
#@                                             }
#@                       virtual_clock_latency { }
#@                       generated             1
#@                       generate_divide       2
#@                     }
#@     example_clock   {
#@                       period                1.0
#@                       setup_uncertainty     { default               0.300
#@                                             }
#@                       hold_uncertainty      0.030
#@                       portnames             {
#@                                             }
#@                       generated             0
#@                     }
#@                     
#@ }
#@ 
#@ # Expand repeated clocks
#@ 
#@ #    dram_div2_clock_DMFE_CORE { 
#@ #                      repeat                {0 1/-1 {dram_div2_clock_[format %d $n]}}
#@ #    }
#@ 
#@ array unset clock_info #*
#@ 
#@ foreach clockname [array names clock_info] {
#@     array unset cc
#@     array set cc $clock_info($clockname)
#@     if { [info exists cc(repeat)] } {
#@         set lim [lsecond $cc(repeat)]
#@         if { [regexp {(.*)/(.*)} $lim dummy l1 l2] } {
#@             set lim [expr [is_top_level $version] ? $l2 : $l1]
#@         }
#@         puts "$clockname is array - expanding ([lfirst $cc(repeat)]..$lim)"
#@         if { $lim != -1 } {
#@             for {set n [lfirst $cc(repeat)]} {$n <= $lim} { incr n } {
#@                 array unset cc2
#@                 array set cc2 $clock_info($clockname)
#@                 foreach para [array names cc2] {
#@                     # regsub -all {\$n} $cc2($para) $n cc2($para)
#@                     eval "set cc2($para) \"$cc2($para)\""
#@                 }
#@                 set clockname2 [llast $cc2(repeat)]
#@                 array unset cc2 repeat
#@                 set clock_info($clockname2) [array get cc2]
#@             }
#@             array unset clock_info $clockname
#@         }
#@     }
#@ }
#@ 
#@ set clock_names [lsort -dictionary [array names clock_info]]
#@ 
#@ proc force_core_clock_period {val} {
#@     global clock_info
#@     global core_clock_info
#@ 
#@     array unset tmp
#@     array set tmp $clock_info(core_clock)
#@     set tmp(period) $val
#@     set clock_info(core_clock) [array get tmp]
#@     array set core_clock_info $clock_info(core_clock)
#@ }
#@ 
#@ # Strictly this should be technology specific
#@ # Better still, it should be controllable on a per clock_name basis
#@ # SPONG - Does it apply only to ideal clocks?
#@ global clock_transition
#@ # Somewhere between 0.06-0.08 for avago
#@ set clock_transition 0.080
#@ 
#@ #############################################################
#@ #
#@ # ASYNC CROSSING TABLE
#@ #
#@ # NB: This uses a list (and thence an array and a separe list of names) instead of a simple array to maintain a search order for the keys 
#@ 
#@ # Block name is regular expression
#@ # Resync cell name is string search glob
#@ # Note - first match has priority
#@ 
#@ # for entries marked "nonstandard" full pathname including [wildcarded] pin name(s) must be given.
#@ 
#@ # INT = subchip INTernal
#@ # SCI = SubChip Interface
#@ # EXT = EXTernal interface
#@ 
#@ # removed the following since no actual paths found:
#@ # X/TC/XPL2PHYS_?/U/PHASE_ALIGNER*/PHASE_ALIGN_CORE/NESPES2 {serdes_rx_clock      xpl_clock            INT2}
#@ # E/LCP40G/logic/ctl_logic/SYNC_0                           {lcprx_clock          lcpref_clock         INT}
#@ 
#@ # these are redundant, covered by  X/TC/XPL2TOP/XPL2FDX/CORE/*/X2C_? line:
#@ # X/TC/XPL2TOP/XPL2FDX/CORE/EVENTS                          {xpl_clock            core_clock           INT}
#@ # X/TC/XPL2TOP/XPL2FDX/CORE/REGBANK                         {xpl_clock            core_clock           INT}
#@ # X/TC/XPL2TOP/XPL2FDX/CORE/REGBANK/X2C_?                   {xpl_clock            core_clock           INT}
#@ 
#@ # these will work, if we want to put them in.
#@ # DMFE*/TC/CORE/INPUT_STAGE_*/fifo_read_data_reg*/d         {nds_clock            core_x2_clock        INT       nonstandard}
#@ # DMFE*/TC/CORE/INPUT_STAGE_*/retimed_neg_data_reg*/d       {nds_clock            core_x2_clock        INT       nonstandard}
#@ 
#@ # DMFE*/CORE/RESETRESYNCDRAM/RESYNC                         {core_clock         dram_clock          INT                 }
#@ 
#@ # X*/XPL2TOP/XPL2FDX/CORE/*/X2C_?                           {xpl_clock          core_clock          INT                 }
#@ # X*/XPL2TOP/XPL2FDX/XPL/TX/CAL_SCHED/C2X_4                 {external           xpl_clock                           EXT }
#@ # X*/XPL2TOP/XPL2FDX/XPL/*/C2X_?                            {core_clock         xpl_clock           INT                 }
#@ # X*/XPL2TOP/RESETRESYNCXPL/RESYNC                          {external           xpl_clock                   SCI         }
#@ 
#@ # X*/XPL2PHYS_*/RESETRESYNC/RESYNC                          {external           xpl_clock                   SCI         }
#@ 
#@ 
#@ set async_xing_info { E/GPIORESYNC                                              {external           core_clock                          EXT }
#@                       
#@                       F/RESYNCPLLST                                             {external           core_clock                  SCI         }
#@                       FCXREF_PLL/PLL/pll_config*                                {core_clock         sbus_clock_0                SCI         nonstandard }
#@                       
#@                       F/COMMON/RCVFCX_*/SDELAY/U/MONITOR                        {external           core_clock                          EXT }
#@                       F/COMMON/RCVFCX_*/RESETRESYNCFCX/RESYNC                   {lcpref_clock       fcx_clock                   SCI         }
#@                       F/COMMON/S*_*_0                                           {fcx_clock*         core_clock          INT                 }
#@ 
#@                       F/COMMON/RESETRESYNCFCX/RESYNC                            {lcpref_clock       fcxref_clock                SCI         }
#@                       F/COMMON/FCX3/SMPL/RESYNC_*                               {external           fcxref_clock_ovs                    EXT }
#@                       F/COMMON/FCX3/PES0                                        {core_clock         fcxref_clock        INT                 }
#@                       F/COMMON/FCX3/PES1                                        {core_clock         fcxref_clock        INT                 }
#@                       F/COMMON/FCX3/PES2                                        {core_clock         fcxref_clock        INT                 }
#@                       F/COMMON/FCX3/SMPL/PES0                                   {core_clock         fcxref_clock        INT                 }
#@                       F/COMMON/FCX3/SMPL/PES1                                   {core_clock         core_clock          INT                 }
#@                       F/COMMON/FCX3/SMPL/SDELAY_*/U/MONITOR                     {external           core_clock                          EXT }
#@                       F/COMMON/PES_DR_STATUS_CX0*                               {fcxref_clock       core_clock          INT                 }
#@                       F/COMMON/PES_DR_STATUS_CX1                                {core_clock         fcxref_clock_cts    INT                 }
#@                       F/COMMON/S*_*_1                                           {fcxref_clock       core_clock          INT                 }
#@                       F/COMMON/S*_*_2                                           {fcxref_clock       core_clock          INT                 }
#@ 
#@                       L/LCP40G/logic*/ctl_logic/SYNC_*                          {lcprx_clock        lcpref_clock        INT                 }
#@                       L/LCP40G/logic*/ctl_logic/SYNCE_0                         {external           lcpref_clock                        EXT }
#@                       L/LCP40G/logic*/ctl_logic/SYNCF_0                         {external           lcpref_clock                        EXT }
#@                       L/LCP40G/logic*/ctl_logic/SYNCC_?                         {core_clock         lcpref_clock        INT                 }
#@                       L/LCP40G/logic*/ctl_logic/SYNCB_?_?                       {core_clock         lcpref_clock        INT                 }
#@                       L/LCP40G/logic*/ctl_logic/SYNCD                           {core_clock         lcpref_clock        INT                 }
#@                       
#@                       L/LCP40G/core_if_?/SYNC_?                                 {various            core_clock          INT                 }
#@                       L/LCP40G/regs/S?                                          {various            lcpref_clock                SCI         }
#@                       L/LCP40G/regs/SBUS/S*                                     {sbus_ctrl_clock    lcpref_clock                SCI         }
#@                       L/LCP40G/MSYNC/SYNC*                                      {lcpref_clock       core_clock          INT                 }
#@                       L/LCP40G/fe/EXTEND/RESETRESYNC/RESYNC                     {external           lcpref_clock                        EXT }
#@                       L/LCP40G/fe/RESETRESYNCP/RESYNC                           {lcpref_clock       lcprx_clock         INT                 }
#@                       
#@                       L/RESETRESYNC_CORE_*/RESYNC                               {external           core_clock                  SCI         }
#@ 
#@                       DMFEA/PLL/PLL/pll_config*                                 {core_clock         sbus_clock_0                SCI         nonstandard }
#@                       DMFEB/PLL/PLL/pll_config*                                 {core_clock         sbus_clock_1                SCI         nonstandard }
#@                       DMFEC/PLL/PLL/pll_config*                                 {core_clock         sbus_clock_2                SCI         nonstandard }
#@                       DMFED/PLL/PLL/pll_config*                                 {core_clock         sbus_clock_3                SCI         nonstandard }
#@ 
#@                       DMFE*/CORE/MINI*/RESETRESYNCCORE/RESYNC                   {external           core_clock                  SCI         }
#@                       DMFE*/CORE/MINI*/RESETRESYNCDRAMDIV2*/RESYNC              {core_clock         dram_div2_clock*    INT                 }
#@                       
#@                       DMFE*/CORE/MINI*/PBIF*/DRAM/C2D_*                         {core_clock         dram_div2_clock*    INT                 }
#@                       DMFE*/CORE/MINI*/PBIF*/CORE/D2C_*                         {dram_div2_clock*   core_clock          INT                 }
#@ 
#@                       DMFE*/CORE/MINI*/PES0_*                                   {dram_div2_clock*   core_clock          INT                 }
#@                       DMFE*/CORE/MINI*/GP2CC_*                                  {external           dram_div2_clock*            SCI         }
#@                       
#@                       DMFE*/CORE/MINI*/NWCTRLR_*/PES                            {core_clock         dram_div2_clock     INT                 }
#@ 
#@                      #DMFE*/CORE/MINI*/RESYNCPLLST*                                 {external       core_clock                  SCI         }
#@                      #DMFE*/CORE/MINI*/NWCTRLR_*/PHYFIFO/RESETRESYNC*/RESETRESYNC   {dram_div2_clock* DMFE*_C*_DW_DFI_CLK_OUT_* INT            }
#@                      #DMFE*/CORE/MINI*/NWCTRLR_*/PHYFIFO/PHY2CTRLDWRD_*/a_*         {DMFE*_C*_DW_DFI_CLK_OUT_* dram_div2_clock* INT            nonstandard}
#@                      #DMFE*/CORE/MINI*/NWCTRLR_*/PHYFIFO/PHY2CTRLAWRD/a_*           {DMFE*_C*_AW_DFI_CLK_OUT_* dram_div2_clock* INT            nonstandard}
#@                      #DMFE*/CORE/MINI*/NWCTRLR_*/PHYFIFO/CTRL2PHYDWRD_*/a_*         {dram_div2_clock* DMFE*_C*_DW_DFI_CLK_OUT_* INT            nonstandard}
#@                      #DMFE*/CORE/MINI*/NWCTRLR_*/PHYFIFO/CTRL2PHYAWRD/a_*           {dram_div2_clock* DMFE*_C*_AW_DFI_CLK_OUT_* INT            nonstandard}
#@                       
#@                       T*/RESETRESYNC/RESYNC                                         {external       core_clock                  SCI         }
#@ }
#@ 
#@ 
#@ 
#@ # SPONG check no longer - DMFE*/CORE/NWCTRLR_*/NWEST/CHCTRL/RESETRESYNC/RESYNC      {dram_div2_clock    dram_div2_clock     INT                 }
#@ 
#@ proc lappend_dmfe_quad_async_xings {path} {
#@     
#@     upvar async_xing_info async_xing_info
#@     
#@     lappend async_xing_info  ${path}WR/PES*              {core_clock         dram_div2_clock     INT                 }
#@     
#@   # lappend async_xing_info  ${path}REASS_*/PES0         {core_clock         dram_div2_clock*    INT                 }
#@     lappend async_xing_info  ${path}RBUF/PES0*           {core_clock         dram_div2_clock*    INT                 }
#@     lappend async_xing_info  ${path}RD/PES*              {dram_div2_clock*   core_clock          INT                 }
#@     lappend async_xing_info  ${path}PES                  {core_clock         dram_div2_clock*    INT                 }
#@     
#@     lappend async_xing_info  ${path}PESS0                {dram_div2_clock*   core_clock          INT                 }
#@     lappend async_xing_info  ${path}PESS1                {dram_div2_clock*   core_clock          INT                 }
#@     lappend async_xing_info  ${path}PESSX                {core_clock         dram_div2_clock*    INT                 }
#@     lappend async_xing_info  ${path}PESE                 {dram_div2_clock*   core_clock          INT                 }
#@     
#@     lappend async_xing_info ${path}RESYNC_*/PES0_*_*     {dram_div2_clock* core_clock  INT}
#@ }
#@ 
#@ lappend_dmfe_quad_async_xings DMFE*/CORE/MINI*/QUAD_*/
#@ 
#@ # possible dmfe_core  DMFE*/CORE/MINI*/RESETRESYNCCORE/RESYNC                         {external             core_clock           EXT }
#@ 
#@ # split the PHASE_ALIGNER stuff up by instance, so we can create a skew group out of each
#@ #set phys_instances {0 1}  
#@ 
#@ # proc lappend_xpl2_phys_async_xings {clk torrent side chan} {
#@ #     upvar async_xing_info async_xing_info
#@ #     foreach link {0 1} {
#@ #        lappend async_xing_info  [list                                                                                               \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/G0_RDMUX/data_in*         \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/G1_RDMUX/data_in*         \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_CORE/PES1/a_*] [list "serdes_rx_clock_${clk}"   xpl_clock                INT    nonstandard]
#@ #        lappend async_xing_info        X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_CORE/PES0      [list "serdes_rx_clock_${clk}"   xpl_clock                INT]
#@ #        lappend async_xing_info        X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/RESETRESYNCRX_${link}/RESYNC                     [list external                   "serdes_rx_clock_${clk}" ignore]
#@ #        lappend async_xing_info  [list                                                                                               \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_CORE/PES2     \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_CORE/PES3]     [list "serdes_rx_clock_${clk}"   xpl_clock                INT]
#@ #        lappend async_xing_info  [list                                                                                               \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_CORE/PES4     \
#@ #                                       X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_CORE/PES5]     [list "serdes_rx_clock_${clk}"   xpl_clock                INT]
#@ #        lappend async_xing_info        X${torrent}/XPL2PHYS_${side}/XPL2PHYS_${chan}/PHASE_ALIGNER_${link}/PHASE_ALIGN_FE/PES         [list xpl_clock                  "serdes_rx_clock_${clk}" INT]
#@ #     }
#@ #    lappend async_xing_info        X${torrent}/XPL2PHYS_${side}/PES_${chan}                                                       [list external                   "serdes_rx_clock_${clk}" SCI]
#@ # }
#@ # 
#@ # #for {set clk 0} {$clk < 64} {incr clk} {
#@ # #    lappend_xpl2_phys_async_xings $clk [expr $clk/32] [expr ($clk%32)/16] [expr $clk % 16]
#@ # #}
#@ #     
#@ # for {set clk 0} {$clk < 16} {incr clk} {
#@ #     lappend_xpl2_phys_async_xings $clk * * $clk
#@ # }
#@ 
#@ proc needs_async_false_paths_file { block_name } {
#@     global async_xing_info
#@     array set axa $async_xing_info
#@     if { [is_top_level $block_name] } { return true }
#@     set tlp [get_block_info $block_name top_level_path]
#@     if { $tlp != {} } { 
#@         set tlp [quotemeta $tlp]
#@         foreach idx [array names axa] {
#@             # puts "$tlp $idx"
#@             if { [regexp "^$tlp" $idx] } { return true }
#@         }
#@     }
#@     return false
#@ }
#@ 
#@ #############################################################
#@ #
#@ # High fanout nets
#@ #
#@ # These nets will be set to ideal and dont_touch'ed during synthesis
#@ # NB: These cell types only exist until the netlist is flattened (i.e. during compile)
#@ 
#@ global cts_root_buffers
#@ array unset cts_root_buffers
#@ array set   cts_root_buffers { *clock_buffer_structural*                { U/o }
#@                                *clock_mux_structural*                   { MUX_dont_touch/ck_out }
#@                                *clock_buffer_top_level_structural*      { U/o }
#@                                #aldl_structural                         { clkout }
#@                                hand_mux2_ip16_HBM_ctc_stop_dp_0*        { hand_mux[0].hand_mux/o }
#@                              }
#@ 
#@ #############################################################
#@ #
#@ # Power supply nets (also dont_touch'ed)
#@ 
#@ global vdd_root_cells
#@ array unset vdd_root_cells
#@ array set   vdd_root_cells   { 
#@                              }
#@ 
#@ #############################################################
#@ #
#@ # TEST
#@ #
#@ # Array of test inputs used by mickey_mouse_test_inputs_stuff
#@ # It can be used to set an appropriate SCA for each port
#@ 
#@ global      test_input_port_values
#@ array unset test_input_port_values
#@ array set   test_input_port_values { 
#@                                      use_test_reset           0
#@                                      test_reset               0
#@                                      lv_test_mode             0
#@                                      lv_mcp_mode              0
#@                                      
#@                                      test_clock*              0
#@                                      func_clock_sel           1
#@                                      
#@                                     #from_dm_TEST_RESET       0
#@                                     #from_dm_USE_TEST_RESET   0
#@                                     #from_dm_POWERDOWN_CML    0
#@                                     #delay_test*              0
#@                                     #dram_test_clock          0
#@                                     #powerdown_cml            0
#@                                     #buf_test_control_*       0
#@                                     #tdi_dly                  0
#@                                     #stats_pll_test*          0
#@                                     #bypass_mindelays         0
#@                                    }
#@ 
#@ global test_output_portnames
#@ # set test_output_portnames { *_to_jpc pll_out_s* pudso_out tdo_dly }
#@ set test_output_portnames { }
#@ 
#@ #############################################################
#@ # RAMS
#@ 
#@ # In fact a general ram_info structure might be the way to go?
#@ # pfile - copied from SJ's project.tcl
#@ 
#@ global clock_x_dp_regfiles
#@ set clock_x_dp_regfiles " X/TC/XPL2TOP/XPL2FDX/RAMS/BUFRX/$BS_SS_U
#@                           X/TC/XPL2TOP/XPL2FDX/RAMS/BUFTX/$BS_SS_U
#@                           X/TC/XPL2TOP/XPL2FDX/RAMS/CAL_RX_BUFFER/$BS_SS_U
#@                           X/TC/XPL2TOP/XPL2FDX/RAMS/CAL_TX_BUFFER/$BS_SS_U
#@                         "
#@ 
#@ global clock_same_dp_rams
#@ #set clock_same_dp_rams " S/MEMS/VOQ/U/$BS_SS_U
#@ #                         D/OUTRESEG/VOQINFO/$BS_SS_U
#@ #                         D/OUTRESEG/BUFINFO/$BS_SS_U
#@ #                       "
#@ set clock_same_dp_rams  " D/OUTRESEG/VOQINFO/$BS_SS_U
#@                           D/OUTRESEG/BUFINFO/$BS_SS_U
#@                         "
#@ 
#@ #############################################################
#@ 
#@ set ilm_design_names {}
#@ foreach l $ilm_block_names {
#@     lappend ilm_design_names [designname $l]
#@ }
#@ 
#@ # Build the designname to blockname table
#@ 
#@ array unset local_designname_to_blockname
#@ array set   local_designname_to_blockname {}
#@ 
#@ foreach name [array names blocks_info] {
#@     set local_designname_to_blockname([designname $name]) $name
#@ }
#@ set local_designname_to_blockname($chip_top_name) $chip_top_name
#@ 
#@ # Set Synopsys variables
#@ 
#@ if { $running_design_compiler == 1} {
#@     set compile_enable_register_merging false
#@ }
#@ 
#@ if { [exists_and_true running_physical_compiler] || $running_design_compiler_topographical } {
#@     set enable_slew_degradation true
#@ }
#@ 
#@ # Set physical compile options
#@ if { $running_design_compiler == 1 && $running_design_compiler_topographical} {
#@     set spg_enable_via_resistance_support true 
#@     set physopt_area_critical_range -0.025
#@     
#@     set_host_options -max_cores 4
#@     #if { [sh_product_version_year] >= 2019 } {
#@     #    set disable_multicore_resource_checks true
#@     #    set_host_options -max_cores 8
#@     #} else {
#@     #    set_host_options -max_cores 2
#@     #}
#@     
#@     # Settings Michael has played with
#@     #set_app_var placer_enable_enhanced_router true
#@     #set_app_var placer_congestion_effort high
#@     #set_app_var spg_enable_via_resistance_support true
#@     #set_app_var psynopt_tns_high_effort true
#@     
#@     set dct_placement_ignore_scan true
#@     set placer_disable_auto_bound_for_gated_clock false
#@     set psynopt_tns_high_effort true
#@     
#@     set placer_max_cell_density_threshold 0.4
#@ }
#@ if { $running_design_compiler == 1 && ! $running_design_compiler_topographical} {
#@     set_host_options -max_cores 2
#@ }
#@ 
#@ # End project.tcl
#@ # -- End source ../scripts/project.tcl

#@ 
#@ if {$version != {default}} {
#@     restore_session $input_file_base.fss
#@ }
#@ 
#@ # -- End source ../common/fms.tcl

set synopsys_auto_setup true
set_svf ../PC_project/compile_computer.svf
create_container ref
set hdlin_vhdl_std 1993
set hdlin_vhdl_integer_range_constraint true
read_vhdl -libname work ../PC_project/ALU.vhd
read_vhdl -libname work ../PC_project/rom_128x8_sync.vhd
read_vhdl -libname work ../PC_project/rw_96x8_sync.vhd
read_vhdl -libname work ../PC_project/Output_Ports.vhd
read_vhdl -libname work ../PC_project/memory.vhd
read_vhdl -libname work ../PC_project/data_path.vhd
read_vhdl -libname work ../PC_project/control_unit.vhd
read_vhdl -libname work ../PC_project/cpu.vhd
read_vhdl -libname work ../PC_project/computer.vhd
set_top computer
create_container impl
read_ddc -container impl -libname work ../PC_project/computer.ddc
set_top impl:/computer
set_reference_design      ref:/work/computer
set_implementation_design impl:/work/computer
set verification_failing_point_limit 5000
verify
